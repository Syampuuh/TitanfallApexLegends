  
     
                                                             
                                                                                                        
  

#if SERVER
                                       
#endif
#if CLIENT
const bool DEBUG_CHARACTER_SELECT = false
#endif

const asset BACKGROUND_SMOKE_MODEL = $"mdl/levels_terrain/mp_lobby/mp_character_select_smoke.rmdl"       
const asset BACKGROUND_GEO_MODEL = $"mdl/levels_terrain/mp_lobby/mp_character_select_geo.rmdl"       
const asset LIGHT_RIG_MDL = $"mdl/empty/lights/empty_lights.rmdl"

global const string CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX = "characterSelectLockstepIndex"
global const string CHARACTER_SELECT_NETVAR_LOCK_STEP_START_TIME = "characterSelectLockstepStartTime"
global const string CHARACTER_SELECT_NETVAR_LOCK_STEP_END_TIME = "characterSelectLockstepEndTime"
global const string CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER = "hasLockedInCharacter"
global const string CHARACTER_SELECT_NETVAR_LOCKED_IN_CHARACTER_TIME = "lockedInCharacterTime"

global const string CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX = "characterSelectLockstepPlayerIndex"
global const string CHARACTER_SELECT_NETVAR_FOCUS_CHARACTER_GUID = "characterSelectFocusCharacterGUID"

#if SERVER
                                   
                                             
                                                         
#endif

#if UI
global function UI_InitCharacterSelectNewMenu
global function UI_RunCharacterSelect
global function UI_CloseCharacterSelect
global function ClientToUI_UpdateSquadMute
#endif

global function CharacterSelectSkinSelectionIsEnabled

#if SERVER || CLIENT
global function AddCallback_CustomIsCharacterLockedForPlayer
global function CharacterSelect_CustomIsCharacterLockedForPlayer
#endif

const int NUM_CHARACTER_SELECT_BUTTONS = 30

#if CLIENT
global function OpenCharacterSelectNewMenu
                        
                                            
      
global function DoSquadCardsPresentation
global function DoChampionSquadCardsPresentation
global function _OpenCharacterSelectNewMenu
global function CloseCharacterSelectNewMenu
global function OnCharacterSelectNewMenuClosed_RemoveCallbacks
global function UpdateMenuElementHandles
global function Client_TryUnlockCharacter
global function ServerCallback_CharacterLockRejected
global function ServerCallback_ForceCharacterLockFeedback
global function OnLoadoutButton_RightClick
global function UpdateCharacterDetailsMenu
global function GetOtherTeammates
global function SquadMuteLegendSelectEnabled
global function CharacterSelect_GetIsBrowseMode
global function CharacterSelect_SetIsBrowseMode
global function CharacterSelect_MenuIsOpen
global function CharacterSelect_SetTooltipUpdateFunc
global function AddCallback_OnCharacterSelectMenuOpened
global function AddCallback_OnCharacterSelectMenuClosed
global function AddCallback_CharacterSelectMenu_OnCharacterFocused
global function AddCallback_CharacterSelectMenu_OnCharacterLocked
global function AddCallback_OnCharacterSelectDetailsToggled
global function AddCallback_OnCharacterSelectBackgroundCreated
global function AddCallback_OnCharacterSelectModelChanged
global function AddCallback_OnCharacterSelectUpdateLights
global function CharacterSelect_UpdateMenuButtons
global function CharacterSelect_RestorePlayerView
global function CharacterSelect_ClearMenuAndRestoreView
global function UpdateBackgroundViaFunc
global function OverrideCharacterSelectCamera
global function RestoreCharacterSelectCamera
global function PanAwayCharacterSelect

const string CAMERA_ENT_NAME = "target_char_sel_camera_new"
const string CHARACTER_ENT_NAME = "target_char_sel_pilot_new"
const string BACKGROUND_ENT_NAME = "target_char_sel_bg_new"
const string LIGHT_KEY_NAME = "char_sel_light_key"
const string LIGHT_FILL_NAME = "char_sel_light_fill"
const string LIGHT_RIML_NAME = "char_sel_light_rim_l"
const string LIGHT_RIMR_NAME = "char_sel_light_rim_r"

const CAMERA_FOV = 35.5
const CAMERA_TRANSITION_DURATION = 0.25
const MAIN_DOF_NEAR_START = 7.5
const MAIN_DOF_NEAR_END = 7.7
const MAIN_DOF_FAR_START = 225.0
const MAIN_DOF_FAR_END = 450.0
const RUI_NAME_PLATE_WIDTH = 262
const RUI_NAME_PLATE_HEIGHT = 110
const COLOR_CORRECTION = "materials/correction/menu.raw_hdr"
const int MAX_TEAM_FOCUS_INDEX = 3
const float READY_ANIM_MIN_DURATION = 4.0
global const int CHAMPION_SQAUD_SMOKE_SKIN_INDEX = 9
global const int CHAMPION_SQAUD_BACKGROUND_SKIN_INDEX = 9

global enum eNewCharacterSelectMenuState
{
	COUNTDOWN,
	PICKING,
	LOCKED,
}

#endif

#if SERVER || CLIENT
global function CharacterSelectNewMenu_Init
#endif

                
#if SERVER
                                               
                                                       
#endif

#if CLIENT
global function ServerToClient_SetClubPartyBool
global function UIToClient_SetClubName
global function ServerToClient_SetChampionClubSquadName
global function GetClubPartyBool
#endif

#if UI
global function ClientToUI_GetClubName
#endif

                
const string FUNCNAME_CLUB_SETCLUBSQUADBOOL_SV = "ClientToServer_SetClubSquadBool"
const string FUNCNAME_CLUB_SETCLUBSQUADBOOL_CL = "ServerToClient_SetClubPartyBool"
const string FUNCNAME_CLUB_SETCLUBNAME_CL = "UIToClient_SetClubName"
const string FUNCNAME_CLUB_SETCHAMPIONCLUBNAME_SV = "ClientToServer_SetChampionClubSquadName"
const string FUNCNAME_CLUB_SETCHAMPIONCLUBNAME_CL = "ServerToClient_SetChampionClubSquadName"
const string FUNCNAME_CLUB_GETCLUBNAME = "ClientToUI_GetClubName"
global const string CLUB_NAME_EMPTY = "?Club!Name?"

#if CLIENT && DEV
global function Dev_CharacterSelectClearCamera
global function Dev_CharacterSelectRefreshLighting
#endif

#if CLIENT
                                                             
global function CreateCharacterSelectClientEnts
global function UpdateCamera
global function SetCharacterSelectSceneForChampionSquad
#endif

#if UI
struct FileForeverStruct
{
	var menu
}
FileForeverStruct& fileForever
#endif

struct FileLevelStruct
{
	#if (UI || CLIENT)
		bool isBrowseMode = false
		bool browseModeShowLockedCharacters = false
		float isBrowseModeStartTime
	#endif                  

	#if SERVER || CLIENT
		bool menuEntsExist = false
	#endif

	#if SERVER
		                                  
	#endif

	#if CLIENT
		bool lightEntsExist = false

		bool detailsPanelVisible = false

		var        menu
		var        whiteFlash
		var        portraitsPanel
		var        detailsPanel
		var        detailsRui
		var        buttonHintPanel
		var        buttonHintRui
		array<var> characterButtons
		array<var> characterButtonRuis
		int        colorCorrection

		int localClientLockstepIndex

		entity camera
		entity cameraToRestore
		entity characterModel
		entity characterNode
		entity characterNodeMover
		entity lightRigModel
		entity keyLight
		entity fillLight
		entity rimLightL
		entity rimLightR
#if NX_PROG || PC_PROG_NX_UI
		entity nxCharacterNode
		int  buttonIdxToUpdate
		bool operationModeChanged
#endif

		entity backgroundModelSmoke
		entity backgroundModelGeo

		var                              backgroundRuiTopo
		var                              backgroundRui
		var                              countdownRui
		var								 mapModeDetailsRui
		array<var>                       ruiPlayerBarRuis
		array<var>                		 gCardRuiHandles
                        
                                        
      
		array<NestedGladiatorCardHandle> nestedGladiatorCardHandles

		table<int, ItemFlavor> buttonIndexCharacterMap
		array<int>             buttonIndexUsed
		array<int>             lockedButtonIndexes
		array<int>             disabledButtonIndexes

		array<ItemFlavor> characterSkins

		ItemFlavor ornull desiredCharacterOrNull = null
		ItemFlavor ornull desiredSkinOrNull = null

		entity            lastLockedPlayer
		int               desiredMenuState = eNewCharacterSelectMenuState.PICKING
		table             signalDummy
		float             lockSequenceAnimTime = 0.0

		table<int, string> connectedPlayerNames

		table<var, void functionref( var button )> buttonEventHandlersAdded_Click
		table<var, void functionref( var button )> buttonEventHandlersAdded_Focus

		bool menuEntsReady = false
		bool menuIsOpen = false

		int championEHI = -1
		int championSquad1EHI = -1
		int championSquad2EHI = -1

		bool isUpdatePlayerModelRunning = false

		void functionref( ItemFlavor, ToolTipData, bool, bool ) tooltipUpdateFunc
	#endif
}
FileLevelStruct& fileLevel

struct {
	array< void functionref() > Callbacks_OnCharacterMenuOpened
	array< void functionref() > Callbacks_OnCharacterMenuClosed
	array< void functionref(ItemFlavor) > Callbacks_OnCharacterFocused
	array< void functionref(ItemFlavor) > Callbacks_OnCharacterLocked
	array< void functionref(bool) > Callbacks_OnCharacterDetailsToggled

	#if SERVER || CLIENT
	array< bool functionref( ItemFlavor, entity ) > Callbacks_CustomIsCharacterLocked
	#endif

	#if CLIENT
		array< void functionref(var) > Callbacks_CustomizeBackgroundRui
		array< void functionref(ItemFlavor, entity, entity, entity, var) > Callbacks_OnCharacterModelChanged
		array< void functionref( entity, entity, entity, entity, entity ) > Callbacks_CustomUpdateLights
		bool isFullClubSquad = false
		string clubName = CLUB_NAME_EMPTY
		string championClubName = CLUB_NAME_EMPTY
	#endif
} file


                                                                         
                                                                           
                                                              
                                                                
                                                              
                                                            

#if UI
void function UI_InitCharacterSelectNewMenu( var newMenuArg )
                                              
{
	fileForever.menu = GetMenu( "CharacterSelectMenuNew" )

	AddMenuEventHandler( fileForever.menu, eUIEvent.MENU_NAVIGATE_BACK, UI_OnCharacterSelectMenu_NavBack )

	AddMenuFooterOption( fileForever.menu, RIGHT, BUTTON_X, true, "", "", UI_OnLoadoutButton_RightClick )           
	AddMenuFooterOption( fileForever.menu, RIGHT, MOUSE_RIGHT, true, "", "", UI_OnLoadoutButton_RightClick )      

	AddMenuFooterOption( fileForever.menu, RIGHT, BUTTON_Y, true, "", "", UI_OnToggleMuteButtonClick, UI_ShouldShowToggleMuteFooter )           
	AddMenuFooterOption( fileForever.menu, RIGHT, KEY_F, true, "", "", UI_OnToggleMuteButtonClick, UI_ShouldShowToggleMuteFooter )      

	AddMenuEventHandler( fileForever.menu, eUIEvent.MENU_CLOSE, void function() {
		RunClientScript( "OnCharacterSelectNewMenuClosed_RemoveCallbacks" )
	} )

	ToolTips_AddMenu( newMenuArg )

	#if PC_PROG
		AddMenuFooterOption( fileForever.menu, RIGHT, KEY_ENTER, true, "", "", UI_OnLoadoutButton_Enter )
	#endif

	                      
	  	                                                       
	  	                                                                            
	  	                                                                          
	  	                                                                       
	        
}

bool function UI_ShouldShowToggleMuteFooter()
{
	return IsFullyConnected() ? SquadMuteLegendSelectEnabled() : false
}

void function UI_OnLoadoutButton_Enter( var button )
{
	var chatbox = Hud_GetChild( fileForever.menu, "LobbyChatBox" )

	if ( !HudChat_HasAnyMessageModeStoppedRecently() )
		Hud_StartMessageMode( chatbox )

	Hud_SetVisible( chatbox, true )
}

void function UI_OnLoadoutButton_RightClick( var button )
{
	if ( CanRunClientScript() )
		RunClientScript( "OnLoadoutButton_RightClick" )
}


void function UI_OnToggleMuteButtonClick( var button )
{
	if ( CanRunClientScript() )
		RunClientScript( "UIToClient_ToggleMute" )
}

void function ClientToUI_UpdateSquadMute( bool muteState )
{

}
#endif

#if SERVER || CLIENT
void function CharacterSelectNewMenu_Init()
{
	PrecacheModel( BACKGROUND_GEO_MODEL )
	PrecacheModel( BACKGROUND_SMOKE_MODEL )
	PrecacheModel( LIGHT_RIG_MDL )

	Remote_RegisterServerFunction( "ClientCallback_UpdateCharacterSelectFocus", "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX )

	#if SERVER
		                                                                  
		                                                                                             
	#endif

	#if CLIENT
		RegisterSignal( "UpdateScene" )
		RegisterSignal( "UpdatingModel" )
		RegisterSignal( "PlayerModelUpdated" )
		RegisterSignal( "UpdatingAnim" )
		RegisterSignal( "CharacterSelectClosing" )
		RegisterSignal( "LocalPlayerPickingSounds" )
		RegisterSignal( "CloseCharacterSelectMenuAtTime" )

		RegisterNetVarIntChangeCallback( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX, OnLockStepPickIndexChanged )
		RegisterNetVarTimeChangeCallback( CHARACTER_SELECT_NETVAR_LOCK_STEP_START_TIME, OnLockStepPickTimeChanged )
		RegisterNetVarTimeChangeCallback( CHARACTER_SELECT_NETVAR_LOCK_STEP_END_TIME, OnLockStepPickTimeChanged )
		RegisterNetVarBoolChangeCallback( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER, OnPlayerUpdatedCharacterLock )
		RegisterNetVarTimeChangeCallback( CHARACTER_SELECT_NETVAR_LOCKED_IN_CHARACTER_TIME, OnPlayerUpdatedCharacterLockTime )

		RegisterNetVarIntChangeCallback( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX, OnLockStepPlayerIndexChanged )
		RegisterNetVarIntChangeCallback( CHARACTER_SELECT_NETVAR_FOCUS_CHARACTER_GUID, OnPlayerUpdatedCharacterFocus )

		AddCallback_FullUpdate( Client_FullUpdate )
		AddCallback_UIScriptReset( Client_UIScriptReset )
		if ( SquadMuteLegendSelectEnabled() )
			AddCallback_OnSquadMuteChanged( Client_MuteChanged )

		fileLevel.colorCorrection = ColorCorrection_Register( COLOR_CORRECTION )
	#endif

	                        
	#if SERVER || CLIENT
		                                                         
		Remote_RegisterServerFunction( FUNCNAME_CLUB_SETCLUBSQUADBOOL_SV )
		Remote_RegisterClientFunction( FUNCNAME_CLUB_SETCLUBSQUADBOOL_CL, "bool" )
		Remote_RegisterClientFunction( FUNCNAME_CLUB_SETCLUBNAME_CL, "string" )

		Remote_RegisterServerFunction( FUNCNAME_CLUB_SETCHAMPIONCLUBNAME_SV, "string" )
		Remote_RegisterClientFunction( FUNCNAME_CLUB_SETCHAMPIONCLUBNAME_CL, "string" )
	#endif
}
#endif

bool function CharacterSelectSkinSelectionIsEnabled()
{
	return GetCurrentPlaylistVarBool( "character_select_do_skin_selection", false )
}

  	                                                                                                                                                                                                            
  	                                                                                                                                                                                                                          
  	                                                                                                                                                                                            
  	                                                                                                                                                                                            
  	                                                                                                                                                                                                                            
  	                                                                                                                                                                                                                

#if CLIENT
void function OpenCharacterSelectNewMenu( bool isBrowseMode = false, bool browseModeShowLockedCharacters = false )
{
	fileLevel.isBrowseMode = isBrowseMode
	fileLevel.isBrowseModeStartTime = Time()
	fileLevel.browseModeShowLockedCharacters = browseModeShowLockedCharacters

	fileLevel.menuEntsExist = DoMenuEntsExist()
	fileLevel.lightEntsExist = DoMenuLightsExist()
	fileLevel.detailsPanelVisible = isBrowseMode && !browseModeShowLockedCharacters

	foreach( func in file.Callbacks_OnCharacterDetailsToggled )
		func( isBrowseMode && !browseModeShowLockedCharacters )

	NotifyCharacterSelectBeginEnd( true )
	RunUIScript( "UI_RunCharacterSelect", fileLevel.isBrowseMode, fileLevel.menuEntsExist )

	foreach ( func in file.Callbacks_OnCharacterMenuOpened )
		func()
}

bool function CharacterSelect_MenuIsOpen()
{
	return fileLevel.menuIsOpen
}

void function CharacterSelect_SetTooltipUpdateFunc( void functionref( ItemFlavor, ToolTipData, bool, bool ) func )
{
	fileLevel.tooltipUpdateFunc = func
}

void function AddCallback_OnCharacterSelectMenuOpened( void functionref() callbackFunc )
{
	file.Callbacks_OnCharacterMenuOpened.append( callbackFunc )
}

void function AddCallback_CharacterSelectMenu_OnCharacterFocused( void functionref(ItemFlavor) callbackFunc )
{
	file.Callbacks_OnCharacterFocused.append( callbackFunc )
}

void function AddCallback_CharacterSelectMenu_OnCharacterLocked( void functionref(ItemFlavor) callbackFunc )
{
	file.Callbacks_OnCharacterLocked.append( callbackFunc )
}

void function AddCallback_OnCharacterSelectMenuClosed( void functionref() callbackFunc )
{
	file.Callbacks_OnCharacterMenuClosed.append( callbackFunc )
}

void function AddCallback_OnCharacterSelectDetailsToggled( void functionref(bool) callbackFunc )
{
	file.Callbacks_OnCharacterDetailsToggled.append( callbackFunc )
}

void function AddCallback_OnCharacterSelectBackgroundCreated( void functionref( var ) callbackFunc )
{
	file.Callbacks_CustomizeBackgroundRui.append( callbackFunc )
}

void function AddCallback_OnCharacterSelectModelChanged( void functionref( ItemFlavor, entity, entity, entity, var ) callbackFunc )
{
	file.Callbacks_OnCharacterModelChanged.append( callbackFunc )
}

void function AddCallback_OnCharacterSelectUpdateLights( void functionref( entity, entity, entity, entity, entity ) callbackFunc )
{
	file.Callbacks_CustomUpdateLights.append( callbackFunc )
}

void function UpdateBackgroundViaFunc( void functionref( entity, entity, var ) callbackFunc )
{
	callbackFunc( fileLevel.backgroundModelGeo, fileLevel.backgroundModelSmoke, fileLevel.backgroundRui )
}

void function PanAwayCharacterSelect()
{
	RunUIScript( "UI_CloseCharacterSelect" )

	if ( !IsValid( fileLevel.camera ) )
		return

	fileLevel.nestedGladiatorCardHandles.clear()
	fileLevel.gCardRuiHandles.clear()
                        
                                        
      

	RuiSetFloat( fileLevel.backgroundRui, "gcardsStartTime", Time() )
	RuiSetFloat( fileLevel.mapModeDetailsRui, "gcardsStartTime", Time() )
	fileLevel.detailsPanelVisible = false

	foreach( func in file.Callbacks_OnCharacterDetailsToggled )
		func(false)

	UpdateButtonStates()

	float outroSceneChangeDuration = CharSelect_GetOutroSceneChangeDuration()
	fileLevel.characterNodeMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", GetEntByScriptName( CAMERA_ENT_NAME ).GetOrigin(), GetEntByScriptName( CAMERA_ENT_NAME ).GetAngles() )

	entity charNode = fileLevel.characterNode
#if NX_PROG || PC_PROG_NX_UI
	if( IsNxHandheldMode() )
	{
		charNode = fileLevel.nxCharacterNode
	}
#endif

	charNode.SetParent( fileLevel.characterNodeMover, "", true )
	fileLevel.characterNodeMover.NonPhysicsRotateTo( fileLevel.characterNodeMover.GetAngles() + <0, 135, 0>, outroSceneChangeDuration, 1.0, 1.0 )

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_LegendPanLeft" )

	wait (outroSceneChangeDuration / 3.0)

	                                                                                                         
	NotifyCharacterSelectBeginEnd( false )
}

void function Client_MuteChanged()
{
	UpdateButtonStates()
}

                        
                                                            
 
                                                        
        

                                                
                                                               

                                                                    
                            
  
                                          
  

                                                        

                                                             
                                                                              
                              
                                                                                                                      
 
                                    
  
                        
                                                              

                                                            
                               

                                                                                             

                                                         

                                                                                
                                                                                
                                                                                                

                              
                                                      

                                                                                                                           

                                                      
   
                                                                                           
                                                                                                                           

                                                                                                
                                                                     
                                                                                             
   

                                                       

                             
   
                                               
    
                                    
                                                                                                                         

                                                   
    
   
  

                        
                                           
                                

                                                                                   

                                                                                                            
                                                                                                               
                                                                                                                                         
                                                

                                            
  
                                
   
                                                                                          
                                                                                              
                                                                 
   
      
   
                                                            
                                                        
                                                                  
   
  

                                                                                        

                                                    

             
                                 
   
                                                        
                            

                                 
   
  

                                              
             
 
      

void function DoSquadCardsPresentation( string endTime, bool showTitleFrame )
{
	foreach( func in file.Callbacks_OnCharacterMenuClosed )
		func()

	                                               
	Remote_ServerCallFunction( FUNCNAME_CLUB_SETCLUBSQUADBOOL_SV )

	                                                                   
	if ( file.isFullClubSquad )
	{
		RunUIScript( FUNCNAME_CLUB_GETCLUBNAME )
	}

	array<float> offsets = [-1.0, 0.0, 1.0]
	if ( MAX_TEAM_PLAYERS == 1 )
		offsets = [0.0]
	if ( MAX_TEAM_PLAYERS == 2 )
		offsets = [-0.5, 0.5]

	array<entity> teammates = GetPlayerSquad()
	ArrayRemoveInvalid( teammates )
	foreach( entity teammate in teammates )
	{
		int index = teammate.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX )
		if ( index < 0 )
			continue

		if ( index >= offsets.len() )
			break

		                 
		var gladCardsRui = CreateFullscreenRui( $"ui/round_end_squad_member_gcard.rpak", -100 )
		fileLevel.gCardRuiHandles.append( gladCardsRui )
		NestedGladiatorCardHandle nestedGCHandle = CreateNestedGladiatorCard( gladCardsRui, "card", eGladCardDisplaySituation.GAME_INTRO_MY_SQUAD_ANIMATED, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( nestedGCHandle, ToEHI( teammate ), null, eGladCardLifestateOverride.ALIVE )
		RuiSetFloat( gladCardsRui, "offset", offsets[index] )
		RuiSetFloat (gladCardsRui, "elementScale", 1.0)      
		fileLevel.nestedGladiatorCardHandles.append( nestedGCHandle )

		       
		var playerStatsRui = CreateFullscreenPostFXRui( $"ui/round_end_squad_member_stats.rpak", 2 )
		fileLevel.gCardRuiHandles.append( playerStatsRui )
		RuiSetFloat( playerStatsRui, "offset", offsets[index] )
		RuiSetBool( playerStatsRui, "showStats", false )
		RuiSetString( playerStatsRui, "playerName", teammate.GetPlayerName() )
		RuiSetFloat( playerStatsRui, "playerNameFontScale", 2.0 )
		RuiTrackInt( playerStatsRui, "micStatus", teammate, RUI_TRACK_MIC_STATUS )


		if ( teammate == GetLocalViewPlayer() )
		{
			LoadoutEntry characterSlot = Loadout_Character()
			ItemFlavor character       = LoadoutSlot_GetItemFlavor( ToEHI( teammate ), characterSlot )
			SetChromaCharacter( character )
		}
	}

	                       
	var borderRui = CreateFullscreenPostFXRui( $"ui/round_end_squads_border.rpak", 3 )
	if ( IsSoloMode() )
	{
		RuiSetString( borderRui, "headerText", "#SOLO_HEADER_YOU_SELECTION" )
	}
	else
	{
		if ( file.clubName != "" && file.clubName != CLUB_NAME_EMPTY )
			RuiSetString( borderRui, "headerText", file.clubName )
		else
			RuiSetString( borderRui, "headerText", "#SQUAD_HEADER_YOUR_SQUAD" )
	}

	RuiSetString( borderRui, "gameModeString", GetCurrentPlaylistVarString( "name", "#PLAYLIST_UNAVAILABLE" ) )
	RuiSetString( borderRui, "mapNameString", GetCurrentPlaylistVarString( "map_name", "#PLAYLIST_UNAVAILABLE" ) )
	RuiSetColorAlpha( borderRui, "headerColor", SrgbToLinear( GetKeyColor( COLORID_FRIENDLY ) / 255.0 ), 1.0 )
	RuiSetBool( borderRui, "compactTitles", true )
	RuiSetBool( borderRui, "showTitleFrame", showTitleFrame )

	for ( int index = 0 ; index < 4 ; index++ )
	{
		if ( index < teammates.len() )
		{
			RuiSetString( borderRui, "playerName" + (index + 1), teammates[index].GetPlayerName() )
			RuiTrackInt( borderRui, "playerMic" + (index + 1), teammates[index], RUI_TRACK_MIC_STATUS )
			RuiSetBool( borderRui, "playerAvailable" + (index + 1), true )
		}
		else
		{
			RuiSetString( borderRui, "playerName" + (index + 1), "" )
			RuiSetInt( borderRui, "playerMic" + (index + 1), -1 )
			RuiSetBool( borderRui, "playerAvailable" + (index + 1), false )
		}
	}

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Appear" )

	fileLevel.gCardRuiHandles.append( borderRui )

	OnThreadEnd(
		void function() : ( borderRui )
		{
			foreach( var rui in fileLevel.gCardRuiHandles )
				RuiDestroyIfAlive( rui )

			foreach( NestedGladiatorCardHandle handle in fileLevel.nestedGladiatorCardHandles )
				CleanupNestedGladiatorCard( handle, true )
			fileLevel.nestedGladiatorCardHandles.clear()

			RuiDestroyIfAlive( borderRui )
		}
	)

	while( Time() < GetGlobalNetTime( endTime ) )
		WaitFrame()
}

void function DoChampionSquadCardsPresentation( string endTime )
{
	printt( "CHARACTER SELECT: DoChampionSquadCardsPresentation" )

	PauseMainDialogueQueue()

	int championEHI       = EHI_null
	int championSquad1EHI = EHI_null
	int championSquad2EHI = EHI_null

                       
	if( IsArenaMode() )
	{
		                                                              
		array<entity> otherTeam = GetPlayerArrayOfTeam( GetOtherTeam( GetLocalViewPlayer().GetTeam() ) )
		if( otherTeam.len() > 0 ) championEHI 		= ToEHI( otherTeam[0] )
		if( otherTeam.len() > 1 ) championSquad1EHI = ToEHI( otherTeam[1] )
		if( otherTeam.len() > 2 ) championSquad2EHI = ToEHI( otherTeam[2] )
	}
	else
      
	{
		championEHI			= GetGlobalNetInt( "championEEH" )
		championSquad1EHI	= GetGlobalNetInt( "championSquad1EEH" )
		championSquad2EHI	= GetGlobalNetInt( "championSquad2EEH" )
	}
	float fadeToBlackDuration   = 0.5
	float fadeFromBlackDuration = 0.5
	float blackDuration         = 0.25

	bool shouldPlayChampionVO = true
                       
	if( IsArenaMode() )
		shouldPlayChampionVO = false
      
                                                                                 
	                                             
	if ( IsMadMaggieHost() )
	{
		shouldPlayChampionVO = false
	}
                                

	               
	if( shouldPlayChampionVO )
	{
		string voLine = GetAnyDialogueAliasFromName( PickCommentaryLineFromBucket( eSurvivalCommentaryBucket.INTRO_CHAMPION_CARD ) )
		blackDuration = max( GetSoundDuration( voLine ) * 0.5, 2.0 )
		EmitSoundOnEntity( GetLocalClientPlayer(), voLine )
	}

	int me = GetLocalViewPlayer().GetEncodedEHandle()
	if ( me == championEHI || me == championSquad1EHI || me == championSquad2EHI )
		Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_BLEND, {[0.0] = <1, .75, 0>, [1.0] = <.75, .3, 0>}, 2.0 )        
	else
		Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_BLEND, {[0.0] = <0, 0, 0>, [1.0] = <.5, .5, .5>}, 2.0 )        

	if ( me == championEHI && file.isFullClubSquad )
		Remote_ServerCallFunction( FUNCNAME_CLUB_SETCHAMPIONCLUBNAME_SV, file.clubName )

	                                                    
	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Disappear" )
	ScreenFade( GetLocalClientPlayer(), 0, 0, 0, 255, fadeToBlackDuration, blackDuration, FFADE_OUT | FFADE_PURGE )
	wait fadeToBlackDuration
	SetCharacterSelectSceneForChampionSquad()
	wait blackDuration
	ScreenFade( GetLocalClientPlayer(), 0, 0, 0, 255, fadeFromBlackDuration, 0.0, FFADE_IN | FFADE_PURGE )

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Appear" )

	             
	var rui = CreateFullscreenRui( $"ui/gladiator_card_intro_screen.rpak", RUI_SORT_SCREENFADE - 1 )
	string topHeader
	if ( IsSoloMode() )
		topHeader = "#GLADIATOR_CARD_INTRO_CHAMPION_SOLO"
	else if ( file.championClubName != CLUB_NAME_EMPTY )
		topHeader = file.championClubName
                       
	else if( IsArenaMode() )
		topHeader = "#PL_ENEMY_SQUAD"
      
	else
		topHeader = "#GLADIATOR_CARD_INTRO_CHAMPION_SQUAD"


	RuiSetString( rui, "topHeader", topHeader )
	RuiSetGameTime( rui, "transitionInAt", Time() )
	RuiSetGameTime( rui, "transitionOutAt", GetGlobalNetTime( endTime ) )
	RuiSetFloat( rui, "xpBonusAmount", XpEventTypeData_GetAmount( eXPType.KILL_CHAMPION_MEMBER ) )
	RuiSetBool( rui, "isDuoMode", GetExpectedSquadSize( GetLocalClientPlayer() ) == 2 )
	RuiSetString( rui, "gameModeString", GetCurrentPlaylistVarString( "name", "#PLAYLIST_UNAVAILABLE" ) )
	RuiSetString( rui, "mapNameString", GetCurrentPlaylistVarString( "map_name", "#PLAYLIST_UNAVAILABLE" ) )

	array<entity> teammates = GetPlayerSquad()
	ArrayRemoveInvalid( teammates )
	for ( int index = 0 ; index < 4 ; index++ )
	{
		if ( index < teammates.len() )
		{
			string displayName = GetPlayerNameUnlessAnonymized( ToEHI( teammates[index] ) )
			RuiSetString( rui, "playerName" + (index + 1), displayName )
			RuiTrackInt( rui, "playerMic" + (index + 1), teammates[index], RUI_TRACK_MIC_STATUS )
			RuiSetBool( rui, "playerAvailable" + (index + 1), true )
		}
		else
		{
			RuiSetString( rui, "playerName" + (index + 1), "" )
			RuiSetInt( rui, "playerMic" + (index + 1), -1 )
			RuiSetBool( rui, "playerAvailable" + (index + 1), false )
		}
	}

	bool showBottomText = !IsRankedGame()
                       
	if( IsArenaMode() )
		showBottomText = false                                                                             
      

	RuiSetBool( rui, "showBottomText", showBottomText )

	array<NestedGladiatorCardHandle> nestedGCHandles

	if ( championSquad1EHI != EHI_null && EHIHasValidScriptStruct( championSquad1EHI ) )
	{
		NestedGladiatorCardHandle handle = CreateNestedGladiatorCard( rui, "cardBoxLeft", eGladCardDisplaySituation.GAME_INTRO_CHAMPION_SQUAD_STILL, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( handle, championSquad1EHI, Time(), eGladCardLifestateOverride.ALIVE )
		nestedGCHandles.append( handle )
	}
	if ( championEHI != EHI_null && EHIHasValidScriptStruct( championEHI ) )
	{
		NestedGladiatorCardHandle handle = CreateNestedGladiatorCard( rui, "cardBoxMiddle", eGladCardDisplaySituation.GAME_INTRO_CHAMPION_SQUAD_ANIMATED, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( handle, championEHI, Time() + 0.2, eGladCardLifestateOverride.ALIVE )
		nestedGCHandles.append( handle )
	}
	if ( championSquad2EHI != EHI_null && EHIHasValidScriptStruct( championSquad2EHI ) )
	{
		NestedGladiatorCardHandle handle = CreateNestedGladiatorCard( rui, "cardBoxRight", eGladCardDisplaySituation.GAME_INTRO_CHAMPION_SQUAD_STILL, eGladCardPresentation.FULL_BOX )
		ChangeNestedGladiatorCardOwner( handle, championSquad2EHI, Time() + 0.4, eGladCardLifestateOverride.ALIVE )
		nestedGCHandles.append( handle )
	}

	OnThreadEnd(
		void function() : ( rui, nestedGCHandles )
		{
			ResumeMainDialogueQueue()
			foreach ( NestedGladiatorCardHandle ngch in nestedGCHandles )
				CleanupNestedGladiatorCard( ngch )
			RuiDestroyIfAlive( rui )
			EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_GladiatorCard_Disappear" )

			Chroma_EndCharacterSelect()
		}
	)

	if ( ShouldPlayIntroQuip() && championEHI != EHI_null )
	{
		thread PlayIntroQuipThread( GetLocalClientPlayer(), championEHI )
	}

	wait 1.5

	EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Survival_Intro_BannerChampion" )

	while( Time() < GetGlobalNetTime( endTime ) )
		WaitFrame()
}

bool function ShouldPlayIntroQuip()
{
                  
		                                          
		if ( IsFallLTM() )
			return false
       

                               
	                                          
		if ( IsShadowRoyaleMode() )
			return false
       

                                                                                  
		                                        
		if ( IsMadMaggieHost() )
			return false
       

	return true
}
#endif

#if UI
void function UI_RunCharacterSelect( bool isBrowseMode, bool menuEntsExist )
{
	if ( !isBrowseMode )
		CloseAllMenus()

	fileLevel.isBrowseMode = isBrowseMode
	fileLevel.isBrowseModeStartTime = UITime()

	if ( !CanRunClientScript() )
		return

	if ( !menuEntsExist )
		SetBlurEnabled( true )

	var portraitsPanel = Hud_GetChild( fileForever.menu, "PortraitsPanel" )
	for ( int i = 0; i < NUM_CHARACTER_SELECT_BUTTONS; i++ )
	{
		                 
		var button = Hud_GetChild( portraitsPanel, "Button" + i )
		ToolTipData td
		td.tooltipFlags = eToolTipFlag.CLIENT_UPDATE
		td.tooltipStyle = eTooltipStyle.DEFAULT
		Hud_SetToolTipData( button, td )
	}

	RunClientScript( "_OpenCharacterSelectNewMenu", fileForever.menu )

	FlashGameWindow()
	AdvanceMenu( fileForever.menu )
}
#endif

#if CLIENT
void function _OpenCharacterSelectNewMenu( var menu )
{
	RemoveCallback_OnPlayerDisconnected( OnPlayerDisconnected )
	AddCallback_OnPlayerDisconnected( OnPlayerDisconnected )

	RemoveDestroyCallback( "player", OnPlayerDestroyed )
	AddDestroyCallback( "player", OnPlayerDestroyed )

	UpdateMenuElementHandles( menu )

	if ( !fileLevel.isBrowseMode )
	{
		thread FlashScreenWhite()
		float gameStartTime = GetGlobalNetTime( "pickLoadoutGamestateEndTime" )
		Assert( gameStartTime > -1 )
		thread CloseCharacterSelectMenuAtTime( gameStartTime )
	}

	if ( !fileLevel.menuEntsExist )
		printt( "CHARACTER SELECT MAP INSTANCE NOT IN THIS BSP" )

	fileLevel.localClientLockstepIndex = GetLocalClientPlayer().GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX )

	CreateCharacterSelectClientEnts()
	UpdateCamera()
	if ( !fileLevel.isBrowseMode )
		FooterRui()

	                                   
	if (fileLevel.mapModeDetailsRui == null)
	{
		var mapModeNameRui = CreateFullscreenRui( $"ui/character_select_map_mode_details.rpak", 300 )
		RuiSetString( mapModeNameRui, "gameModeString", GetCurrentPlaylistVarString( "name", "#PLAYLIST_UNAVAILABLE" ) )
		RuiSetString( mapModeNameRui, "mapNameString", GetCurrentPlaylistVarString( "map_name", "#PLAYLIST_UNAVAILABLE" ) )
		fileLevel.mapModeDetailsRui = mapModeNameRui
	}

	fileLevel.menuEntsReady = true
	fileLevel.menuIsOpen = true

	UpdateMenuButtons()
	thread UpdateSceneThink()

	#if DEBUG_CHARACTER_SELECT
		                       
	#endif

	if ( !fileLevel.isBrowseMode )
	{
		Assert( fileLevel.localClientLockstepIndex >= 0 )

		foreach( entity player in GetPlayerSquad() )
		{
			                                                                   
			int teammatePickingIndex = player.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX )
			if ( teammatePickingIndex >= 0 && player != GetLocalClientPlayer() )
				Assert( teammatePickingIndex != fileLevel.localClientLockstepIndex )
		}

		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_Character(), OnTeammateLoadoutSelectionChanged, false )
		foreach( ItemFlavor character in GetAllCharacters() )
		{
			LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( skinSlot, OnTeammateLoadoutSelectionChanged, false )
		}
	}

	if ( fileLevel.isBrowseMode )
	{
		ItemFlavor selectedCharacter = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
		int buttonIndex = GetButtonIndexForCharacter( selectedCharacter )
		if ( buttonIndex >= 0)
		{
			EmitSoundOnEntity( GetLocalClientPlayer(), "ui_menu_focus_legendselectscreen" )
			UpdateForFocusOnButtonIndex( buttonIndex )
		}

		if ( fileLevel.browseModeShowLockedCharacters )
		{
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_Character(), OnTeammateLoadoutSelectionChanged, false )
			foreach( ItemFlavor character in GetAllCharacters() )
			{
				LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
				AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( skinSlot, OnTeammateLoadoutSelectionChanged, false )
			}
		}
	}
}

void function UpdateMenuElementHandles( var menu )
{
	fileLevel.menu = menu
	fileLevel.whiteFlash = Hud_GetChild( menu, "WhiteFlash" )
	fileLevel.portraitsPanel = Hud_GetChild( menu, "PortraitsPanel" )
	fileLevel.detailsPanel = Hud_GetChild( menu, "DetailsRuiPanel" )
	fileLevel.buttonHintPanel = Hud_GetChild( menu, "ButtonHintRuiPanel" )

	fileLevel.characterButtons = []
	fileLevel.characterButtonRuis = []
	fileLevel.detailsRui = Hud_GetRui( fileLevel.detailsPanel )
	fileLevel.buttonHintRui = Hud_GetRui( fileLevel.buttonHintPanel )

	for ( int i = 0; i < NUM_CHARACTER_SELECT_BUTTONS; i++ )
	{
		                 
		var button = Hud_GetChild( fileLevel.portraitsPanel, "Button" + i )
		fileLevel.characterButtons.append( button )

		var buttonRui = Hud_GetRui( button )
		fileLevel.characterButtonRuis.append( buttonRui )

		                       
		if ( button in fileLevel.buttonEventHandlersAdded_Click )
		{
			Hud_RemoveEventHandler( button, UIE_CLICK, fileLevel.buttonEventHandlersAdded_Click[ button ] )
			delete fileLevel.buttonEventHandlersAdded_Click[ button ]
		}
		Hud_AddEventHandler( button, UIE_CLICK, OnLoadoutButton_Activate )
		fileLevel.buttonEventHandlersAdded_Click[ button ] <- OnLoadoutButton_Activate

		if ( button in fileLevel.buttonEventHandlersAdded_Focus )
		{
			Hud_RemoveEventHandler( button, UIE_GET_FOCUS, fileLevel.buttonEventHandlersAdded_Focus[ button ] )
			delete fileLevel.buttonEventHandlersAdded_Focus[ button ]
		}
		Hud_AddEventHandler( button, UIE_GET_FOCUS, OnLoadoutButton_Focused )
		fileLevel.buttonEventHandlersAdded_Focus[ button ] <- OnLoadoutButton_Focused

		                                                                             

		                                                                          

		Hud_SetVisible( button, false )
	}
}

void function CharacterSelect_UpdateMenuButtons()
{
    UpdateMenuButtons()
#if NX_PROG || PC_PROG_NX_UI
	if( fileLevel.detailsPanelVisible )
	{
		fileLevel.operationModeChanged = true
		UpdateForFocusOnButtonIndex( fileLevel.buttonIdxToUpdate )
	}
#endif
}

void function UpdateMenuButtons()
{
	fileLevel.lockedButtonIndexes.clear()
	fileLevel.disabledButtonIndexes.clear()

	array<ItemFlavor> shippingCharacters
	array<ItemFlavor> lockedCharacters
	array<ItemFlavor> disabledCharacters
	array<ItemFlavor> allCharacters

	foreach( ItemFlavor itemFlav in GetAllCharacters() )
	{
		if ( !ItemFlavor_ShouldBeVisible( itemFlav, null, GetConVarInt( "mtx_svEdition" ) ) )
			continue

		bool isAvailable = IsItemFlavorUnlockedForLoadoutSlot( LocalClientEHI(), Loadout_Character(), itemFlav, true )
		bool isOwned     = Character_IsCharacterOwnedByPlayer( itemFlav, GetLocalClientPlayer() )

		if ( !isAvailable || CharacterSelect_CustomIsCharacterLockedForPlayer( itemFlav, GetLocalClientPlayer() ) )
		{
			disabledCharacters.append( itemFlav )
		}
		else
		{
			if ( !isOwned )
				lockedCharacters.append( itemFlav )
			else
				shippingCharacters.append( itemFlav )
		}
	}
	allCharacters.extend( shippingCharacters )
	allCharacters.extend( lockedCharacters )
	allCharacters.extend( disabledCharacters )

	if ( CharacterSelectSkinSelectionIsEnabled() && (allCharacters.len() == 1) )
	{
		array<ItemFlavor> skins = RegisterReferencedItemFlavorsFromArray( allCharacters[0], "skins", "flavor" )
		skins.remove( 0 )

		if ( skins.len() > 0 )
			allCharacters.resize( skins.len(), allCharacters[0] )

		if ( allCharacters.len() > NUM_CHARACTER_SELECT_BUTTONS )
			allCharacters.resize( NUM_CHARACTER_SELECT_BUTTONS )

		fileLevel.characterSkins = skins
	}
	else
	{
		fileLevel.characterSkins.clear()
	}

	Assert( allCharacters.len() <= NUM_CHARACTER_SELECT_BUTTONS, "Character select doesn't have enough character buttons. Has " + NUM_CHARACTER_SELECT_BUTTONS + " but needs " + allCharacters.len() )
	fileLevel.buttonIndexUsed.clear()

	array<ItemFlavor> orderedCharacters = GetCharacterButtonOrder( allCharacters, NUM_CHARACTER_SELECT_BUTTONS )
	array<var> characterButtons

	foreach ( index, character in orderedCharacters )
	{
		characterButtons.append( fileLevel.characterButtons[index] )

		if ( lockedCharacters.contains( character ) )
			fileLevel.lockedButtonIndexes.append( index )

		if ( disabledCharacters.contains( character ) )
			fileLevel.disabledButtonIndexes.append( index )

		                                                     
		fileLevel.buttonIndexCharacterMap[ index ] <- character
		fileLevel.buttonIndexUsed.append( index )

		                              
		var buttonRui = fileLevel.characterButtonRuis[index]
		RuiSetImage( buttonRui, "portraitImage", CharacterClass_GetGalleryPortrait( character ) )
		RuiSetImage( buttonRui, "portraitBackground", CharacterClass_GetGalleryPortraitBackground( character ) )
		RuiSetString( buttonRui, "portraitName", Localize( ItemFlavor_GetLongName( character ) ) )
		RuiSetImage( buttonRui, "roleImage", CharacterClass_GetCharacterRoleImage( character ) )
		RuiSetColorAlpha( buttonRui, "baseNameBackgroundColor", SrgbToLinear( (fileLevel.characterSkins.len() > 0) ? CharacterSkin_GetCharacterSelectLabelColorOverride( fileLevel.characterSkins[index] ) : <1.0, 1.0, 1.0> ), 1.0 )
	}

	array< array<var> > buttonRows = GetCharacterButtonRows( characterButtons )
	LayoutCharacterButtons( buttonRows )
	UpdateButtonStates()
}
#endif         

#if UI
void function UI_OnCharacterSelectMenu_NavBack()
{
	                                                
	if ( fileLevel.isBrowseMode )
	{
		RunClientScript( "CloseCharacterSelectNewMenu" )
		return
	}

	RunClientScript( "Client_TryUnlockCharacter" )
}

void function UI_CloseCharacterSelect()
{
	SetBlurEnabled( false )
	if ( GetActiveMenu() == fileForever.menu )
		CloseActiveMenu()
	else if ( MenuStack_Contains( fileForever.menu ) )
		MenuStack_Remove( fileForever.menu )
}
#endif     

#if CLIENT

const float CHARACTER_SELECT_FADE_HOLD_TIME = 1.0

void function CloseCharacterSelectMenuAtTime( float closeTimeStamp )
{
	Signal( GetLocalClientPlayer(), "CloseCharacterSelectMenuAtTime" )
	EndSignal( GetLocalClientPlayer(), "CloseCharacterSelectMenuAtTime" )

	while ( Time() < closeTimeStamp - SCREEN_COVER_TRANSITION_OUT_DURATION - 0.1 )
		WaitFrame()

	waitthread ScreenCoverTransition( Time() + CharSelect_GetOutroTransitionDuration() )

	CloseCharacterSelectNewMenu()

	FlashGameWindow()
}

void function CloseCharacterSelectNewMenu()
{
	Signal( fileLevel.signalDummy, "CharacterSelectClosing" )

	RunUIScript( "UI_CloseCharacterSelect" )

	RemoveCallback_OnPlayerDisconnected( OnPlayerDisconnected )
	RemoveDestroyCallback( "player", OnPlayerDestroyed )

	CharacterSelect_ClearMenuAndRestoreView()

	fileLevel.menuIsOpen = false

	OnCharacterSelectNewMenuClosed_RemoveCallbacks()

	foreach( func in file.Callbacks_OnCharacterMenuClosed )
		func()

	NotifyCharacterSelectBeginEnd( false )
}

void function CharacterSelect_ClearMenuAndRestoreView()
{
	CharacterSelect_RestorePlayerView()
	DeleteMenuEntities()
}

void function CharacterSelect_RestorePlayerView()
{
	                                               
	if ( IsValid( fileLevel.camera ) )
		fileLevel.camera.SetFOV( CAMERA_FOV )
	GetLocalClientPlayer().ClearMenuCameraEntity()
	DoF_SetNearDepthToDefault()
	DoF_SetFarDepthToDefault()
	DoFSetDilateInfocus( false )
	ColorCorrection_SetWeight( fileLevel.colorCorrection, 0.0 )
	ColorCorrection_SetExclusive( fileLevel.colorCorrection, false )
	SetMapSetting_FogEnabled( true )

	if ( fileLevel.lightEntsExist )
	{
		fileLevel.keyLight.SetTweakLightRealtimeShadows( false )
		fileLevel.keyLight.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.fillLight.SetTweakLightRealtimeShadows( false )
		fileLevel.fillLight.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.rimLightL.SetTweakLightRealtimeShadows( false )
		fileLevel.rimLightL.SetTweakLightUpdateShadowsEveryFrame( false )

		fileLevel.rimLightR.SetTweakLightRealtimeShadows( false )
		fileLevel.rimLightR.SetTweakLightUpdateShadowsEveryFrame( false )
	}
}

void function OnCharacterSelectNewMenuClosed_RemoveCallbacks()
{
	RemoveCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_Character(), OnTeammateLoadoutSelectionChanged, false )
	foreach( ItemFlavor character in GetAllCharacters() )
	{
		LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
		RemoveCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( skinSlot, OnTeammateLoadoutSelectionChanged, false )
	}
}

void function OverrideCharacterSelectCamera( entity ent )
{
	fileLevel.cameraToRestore = fileLevel.camera

	int attachIndex       = ent.LookupAttachment( "VDU" )
	entity overrideCamera = CreateClientSidePointCamera( ent.GetAttachmentOrigin( attachIndex ), ent.GetAttachmentAngles( attachIndex ), CAMERA_FOV )
	overrideCamera.SetParent( ent )

	fileLevel.camera = overrideCamera
	GetLocalClientPlayer().SetMenuCameraEntity( fileLevel.camera )
}

void function RestoreCharacterSelectCamera()
{
	Assert( IsValid( fileLevel.cameraToRestore ) )

	entity cameraToDestroy = fileLevel.camera

	fileLevel.camera = fileLevel.cameraToRestore
	GetLocalClientPlayer().SetMenuCameraEntity( fileLevel.camera )

	cameraToDestroy.Destroy()
}

void function CreateCharacterSelectClientEnts()
{
	if ( !fileLevel.menuEntsExist )
	{
		fileLevel.menuEntsExist = DoMenuEntsExist()
		fileLevel.lightEntsExist = DoMenuLightsExist()
	}

	if ( !fileLevel.menuEntsExist )
		return

	entity targetCamera = GetEntByScriptName( CAMERA_ENT_NAME )
	vector cameraOrigin = targetCamera.GetOrigin()

	entity targetPilot = GetEntByScriptName( CHARACTER_ENT_NAME )

	fileLevel.camera = CreateClientSidePointCamera( cameraOrigin, targetCamera.GetAngles(), CAMERA_FOV )

	fileLevel.characterNode = CreateScriptRef( targetPilot.GetOrigin(), targetPilot.GetAngles() )
#if NX_PROG || PC_PROG_NX_UI
	fileLevel.nxCharacterNode = CreateScriptRef( targetPilot.GetOrigin() + <-4,0,0>, targetPilot.GetAngles() )
#endif	

	asset defaultModel = GetGlobalSettingsAsset( DEFAULT_PILOT_SETTINGS, "bodyModel" )
	CreateNewCharacterModel( defaultModel )

	if ( DoesBackgroundEntExist() )
	{
		                                 

		entity targetBackground = GetEntByScriptName( BACKGROUND_ENT_NAME )

		vector offset = <0, 0, 24>
		UISize screenSize = GetScreenSize()
		float nearestAspectRatio = GetNearestAspectRatio( screenSize.width, screenSize.height )
		if ( nearestAspectRatio > 2.25 )
			offset += <0, 25, 0>

		if ( IsValid( fileLevel.backgroundModelGeo ) )
			fileLevel.backgroundModelGeo.Destroy()

		fileLevel.backgroundModelGeo = CreateClientSidePropDynamic( targetBackground.GetOrigin() - offset, targetBackground.GetAngles(), BACKGROUND_GEO_MODEL )
		fileLevel.backgroundModelGeo.kv.solid = 0
		fileLevel.backgroundModelGeo.kv.disableshadows = 1
		fileLevel.backgroundModelGeo.kv.fadedist = -1
		fileLevel.backgroundModelGeo.MakeSafeForUIScriptHack()

		if ( IsValid( fileLevel.backgroundModelSmoke ) )
				fileLevel.backgroundModelSmoke.Destroy()

		fileLevel.backgroundModelSmoke = CreateClientSidePropDynamic( targetBackground.GetOrigin() - offset, targetBackground.GetAngles(), BACKGROUND_SMOKE_MODEL )
		fileLevel.backgroundModelSmoke.kv.solid = 0
		fileLevel.backgroundModelSmoke.kv.disableshadows = 1
		fileLevel.backgroundModelSmoke.kv.fadedist = -1
		fileLevel.backgroundModelSmoke.MakeSafeForUIScriptHack()
	}

	if ( DoMenuLightsExist() )
	{
		CreateNewLightRigModel()
		fileLevel.keyLight = GetEntByScriptName( LIGHT_KEY_NAME )
		fileLevel.keyLight.SetTweakLightRealtimeShadows( true )
		fileLevel.keyLight.SetTweakLightUpdateShadowsEveryFrame( true )

		fileLevel.fillLight = GetEntByScriptName( LIGHT_FILL_NAME )
		fileLevel.fillLight.SetTweakLightRealtimeShadows( true )
		fileLevel.fillLight.SetTweakLightUpdateShadowsEveryFrame( true )

		fileLevel.rimLightL = GetEntByScriptName( LIGHT_RIML_NAME )
		fileLevel.rimLightL.SetTweakLightRealtimeShadows( true )
		fileLevel.rimLightL.SetTweakLightUpdateShadowsEveryFrame( true )

		fileLevel.rimLightR = GetEntByScriptName( LIGHT_RIMR_NAME )
		fileLevel.rimLightR.SetTweakLightRealtimeShadows( true )
		fileLevel.rimLightR.SetTweakLightUpdateShadowsEveryFrame( true )
	}

	                        
	vector backgroundRuiOrigin = cameraOrigin + (targetCamera.GetForwardVector() * 200)
	vector backgroundRuiAngles = targetPilot.GetAngles()

	fileLevel.backgroundRuiTopo = CreateRUITopology_Worldspace( backgroundRuiOrigin, backgroundRuiAngles * -1, RUI_NAME_PLATE_WIDTH, RUI_NAME_PLATE_HEIGHT )
	fileLevel.backgroundRui = RuiCreate( $"ui/character_select_name_plate_new.rpak", fileLevel.backgroundRuiTopo, RUI_DRAW_WORLD, 0 )

	foreach ( func in file.Callbacks_CustomizeBackgroundRui )
		func( fileLevel.backgroundRui )

	Chroma_BeginCharacterSelect()

	if ( !fileLevel.isBrowseMode )
	{
		fileLevel.countdownRui = CreateFullscreenRui( $"ui/character_select_timer_new.rpak" )
		RuiSetResolutionToScreenSize( fileLevel.countdownRui )
		float pickStartTime = GetGlobalNetTime( "pickLoadoutGamestateStartTime" )
		Assert( pickStartTime > -1 )
		RuiSetGameTime( fileLevel.countdownRui, "countdownEndTime", pickStartTime )
		RuiSetInt( fileLevel.countdownRui, "yourPick", fileLevel.localClientLockstepIndex + 1 )
		thread CountdownTimerSounds()
	}
}

void function CountdownTimerSounds()
{
	entity player = GetLocalClientPlayer()
	EndSignal( player, "OnDestroy" )

	wait max( 0.0, SCREEN_COVER_TRANSITION_IN_DURATION + SCREEN_COVER_TRANSITION_OUT_DURATION - 1.0 )

	float timeRemaining = GetGlobalNetTime( "pickLoadoutGamestateStartTime" ) - Time()

	if ( timeRemaining <= 1.0 )
		return

	wait max( 0.0, timeRemaining % 1.0 )
	wait 0.5

	while( Time() < GetGlobalNetTime( "pickLoadoutGamestateStartTime" ) )
	{
		timeRemaining = GetGlobalNetTime( "pickLoadoutGamestateStartTime" ) - Time()
		EmitSoundOnEntity( player, "UI_Survival_Intro_PreLegendSelect_Countdown" )
		wait 1.0
	}
}

void function UpdateCamera()
{
	if ( fileLevel.menuEntsExist )
	{
		entity player = GetLocalClientPlayer()
		player.SetMenuCameraEntity( fileLevel.camera )
		fileLevel.camera.SetTargetFOV( CAMERA_FOV, true, EASING_CUBIC_INOUT, CAMERA_TRANSITION_DURATION )
	}

	ColorCorrection_SetExclusive( fileLevel.colorCorrection, true )
	ColorCorrection_SetWeight( fileLevel.colorCorrection, 1.0 )
	SetMapSetting_FogEnabled( false )

	                                                            
	                                                         
	                                                                                                
}

void function FooterRui()
{
	int NUM_PLAYERS = MAX_TEAM_PLAYERS
	float startTime = Time()
	bool refreshedRui = false

	                                                                                                                                                                                                                                                                                          
	                                                                                                                                                                   
	foreach( var rui in fileLevel.ruiPlayerBarRuis )
	{
		RuiDestroyIfAlive( rui )
		refreshedRui = true
	}

	fileLevel.ruiPlayerBarRuis = []

	for ( int i = 0 ; i < NUM_PLAYERS ; i++ )
	{
		var rui = CreateFullscreenRui( $"ui/character_select_footer_bars.rpak", 300 )

		UISize screenSize = GetScreenSize()
		float aspectRatio = float( screenSize.width ) / float( screenSize.height )
		RuiSetResolution( rui, 1080.0 * aspectRatio, 1080.0 )

		RuiSetInt( rui, "numPlayers", NUM_PLAYERS )
		RuiSetInt( rui, "playerIndex", i )
		RuiSetBool( rui, "lockedCharacter", false )
		RuiSetBool( rui, "isSelecting", false )
		RuiSetBool( rui, "statusTextVisible", true )
		RuiSetBool( rui, "isDisconnected", false )
		RuiSetString( rui, "playerName", "" )
		RuiSetBool( rui, "isJumpmaster", false )

		UISize virtualSize = GetScreenSize()                                      
		RuiSetFloat2( rui, "virtualRes", <1080.0 * aspectRatio, 1080.0, 0> )
		
		#if NX_PROG
			RuiSetFloat( rui, "footerBarsProgressBarHeight", 32 )
			RuiSetFloat( rui, "footerBarDiagSize", 43 )
		#endif
		
		entity ornull playerForSlot = GetTeammateForPickingIndex( i )
		if ( playerForSlot != null )
		{
			entity player = expect entity( playerForSlot )
			Assert( IsValid( player ) )
			RuiSetInt( rui, "playerTeamColorIndex", player.GetTeamMemberIndex() )
		}

		fileLevel.ruiPlayerBarRuis.append( rui )
	}

	if ( refreshedRui )
		UpdateButtonStates()
}

void function DeleteMenuEntities()
{
	if ( IsValid( fileLevel.camera ) )
		fileLevel.camera.Destroy()
	if ( IsValid( fileLevel.characterModel ) )
		fileLevel.characterModel.Destroy()
	if ( IsValid( fileLevel.characterNode ) )
		fileLevel.characterNode.Destroy()
	if ( IsValid( fileLevel.characterNodeMover ) )
		fileLevel.characterNodeMover.Destroy()
	if ( IsValid( fileLevel.backgroundModelSmoke ) )
		fileLevel.backgroundModelSmoke.Destroy()
	if ( IsValid( fileLevel.backgroundModelGeo ) )
		fileLevel.backgroundModelGeo.Destroy()
	if ( IsValid( fileLevel.lightRigModel ) )
		fileLevel.lightRigModel.Destroy()
#if NX_PROG || PC_PROG_NX_UI
	if( IsValid( fileLevel.nxCharacterNode ) )
		fileLevel.nxCharacterNode.Destroy()
#endif
	                  
	foreach( var rui in fileLevel.ruiPlayerBarRuis )
		RuiDestroyIfAlive( rui )
	fileLevel.ruiPlayerBarRuis = []

	if ( fileLevel.mapModeDetailsRui != null )
	{
		RuiDestroyIfAlive( fileLevel.mapModeDetailsRui )
		fileLevel.mapModeDetailsRui = null
	}

	               
	if ( fileLevel.backgroundRui != null )
	{
		RuiDestroyIfAlive( fileLevel.backgroundRui )
		fileLevel.backgroundRui = null
	}
	if ( fileLevel.backgroundRuiTopo != null )
	{
		RuiTopology_Destroy( fileLevel.backgroundRuiTopo )
		fileLevel.backgroundRuiTopo = null
	}
	if ( fileLevel.countdownRui != null )
	{
		RuiDestroyIfAlive( fileLevel.countdownRui )
		fileLevel.countdownRui = null
	}

	foreach( var rui in fileLevel.gCardRuiHandles )
		RuiDestroyIfAlive( rui )

	foreach( NestedGladiatorCardHandle handle in fileLevel.nestedGladiatorCardHandles )
		CleanupNestedGladiatorCard( handle, true )
	fileLevel.nestedGladiatorCardHandles.clear()

	fileLevel.menuEntsReady = false

	          
	                                                   
	  	                                                  
}

void function Client_FullUpdate()
{
	                               
	printt( "Client_FullUpdate" )
	                               

	thread FixMenuCamera()
}

void function FixMenuCamera()
{
	if ( !fileLevel.menuEntsExist )
		return

	                                             
	wait 0.1
	entity localClientPlayer = GetLocalClientPlayer()
	if ( IsValid( localClientPlayer ) && IsValid( fileLevel.camera ) )
		localClientPlayer.SetMenuCameraEntity( fileLevel.camera )
}

void function Client_UIScriptReset()
{
	                             
	printt( "UI Script Reset" )
	                             

	if ( GetGameState() == eGameState.PickLoadout  || GetCurrentPlaylistVarBool( "character_reselect_enabled", false ))
		thread ReloadMenu()
}

void function ReloadMenu()
{
	WaitFrame()

	if ( GetGameState() != eGameState.PickLoadout || GetCurrentPlaylistVarBool( "character_reselect_enabled", false ))
		return

	CloseCharacterSelectNewMenu()
	WaitFrame()

	if ( GetGameState() != eGameState.PickLoadout || GetCurrentPlaylistVarBool( "character_reselect_enabled", false ))
		return

	OpenCharacterSelectNewMenu()
}

#endif         

#if SERVER || CLIENT
void function AddCallback_CustomIsCharacterLockedForPlayer( bool functionref( ItemFlavor, entity ) func )
{
	Assert( !file.Callbacks_CustomIsCharacterLocked.contains(func) )
	file.Callbacks_CustomIsCharacterLocked.append( func )
}

bool function CharacterSelect_CustomIsCharacterLockedForPlayer( ItemFlavor character, entity player )
{
	foreach ( func in file.Callbacks_CustomIsCharacterLocked )
	{
		if ( func( character, player ) )
			return true
	}
	return false
}
#endif

  	                                                                                                                                                                                                                                                                                 
  	                                                                                                                                                                                                                                                                                                     
  	                                                                                                                                                                                                                                               
  	                                                                                                                                                                                                                                                   
  	                                                                                                                                                                                                                                                                       
  	                                                                                                                                                                                                                                                   

#if CLIENT

ItemFlavor ornull function GetCharacterSkinOrNullForButtonIndex( int index )
{
	if ( index < fileLevel.characterSkins.len() )
		return fileLevel.characterSkins[index]

	return null
}

void function UpdateForFocusOnButtonIndex( int buttonIndex )
{
#if NX_PROG || PC_PROG_NX_UI
	fileLevel.buttonIdxToUpdate = buttonIndex
#endif
	ItemFlavor character = fileLevel.buttonIndexCharacterMap[buttonIndex]
	ItemFlavor ornull skin = GetCharacterSkinOrNullForButtonIndex( buttonIndex )

	UpdateCharacterDetailsMenu( fileLevel.detailsRui, character, false )
	Hud_SetVisible( fileLevel.detailsPanel, fileLevel.detailsPanelVisible )

	foreach( func in file.Callbacks_OnCharacterFocused )
		func( character )

	                                                                                          
	if ( !fileLevel.isBrowseMode && !GetLocalClientPlayer().GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) )
	{
		int characterGUID = ItemFlavor_GetGUID( character )
		int skinGUID = ((skin == null) ? -1 : ItemFlavor_GetGUID( expect ItemFlavor( skin ) ))
		Remote_ServerCallFunction("ClientCallback_UpdateCharacterSelectFocus", characterGUID, skinGUID)
	}

	                                                         
	if ( !fileLevel.isBrowseMode && GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) != fileLevel.localClientLockstepIndex )
		return

	                                                                                                                          
	if ( !( fileLevel.isBrowseMode && fileLevel.browseModeShowLockedCharacters ) && GetLocalClientPlayer().GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) )
		return

	               
	fileLevel.desiredCharacterOrNull = character
	fileLevel.desiredSkinOrNull = skin
	Signal( fileLevel.signalDummy, "UpdateScene" )
}

void function OnLoadoutButton_Focused( var button )
{
	if ( fileLevel.isBrowseMode && ((Time() - fileLevel.isBrowseModeStartTime) < 0.1) )
		return

	int index = fileLevel.characterButtons.find( button )
	UpdateForFocusOnButtonIndex( index )
}

void function DoBrowseModeCharacterSelectEffects()
{
	  
	ScreenFlash( 0.0, 0.0, 0.0, 0.25, 2.0 )

	  
	thread function() : ()
	{
		wait(0.5)
		entity player = GetLocalClientPlayer()
		if ( IsAlive( player ) )
			PlayClientDialogueOnEntity( GetAnyAliasIdForName( "bc_returnFromRespawn" ), 0, player )
	}()
}

void function OnLoadoutButton_Activate( var button )
{
	if ( Hud_IsLocked( button ) )
		return

	                                                         
	if ( !fileLevel.isBrowseMode && GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) != fileLevel.localClientLockstepIndex )
		return

	                                                                   
	if ( GetLocalClientPlayer().GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) && !fileLevel.isBrowseMode )
		return

	int buttonIndex      = fileLevel.characterButtons.find( button )
	ItemFlavor character = fileLevel.buttonIndexCharacterMap[ buttonIndex ]
	ItemFlavor ornull skinOrNull = GetCharacterSkinOrNullForButtonIndex( buttonIndex )

	if ( fileLevel.isBrowseMode )
	{
		entity player = GetLocalClientPlayer()
		ItemFlavor currentCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )
		ItemFlavor currentSkin = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterSkin( currentCharacter ) )
		if ( (character == currentCharacter) && ((skinOrNull == null) || (skinOrNull == currentSkin)) )
		{
			EmitSoundOnEntity( player, "ui_menu_back" )
			CloseCharacterSelectNewMenu()
			return
		}
	}

	                                        
	entity ornull playerWithThisCharacterLocked = GetPlayerWithLockedCharacter( character, skinOrNull, GetPlayerSquad() )
	if ( playerWithThisCharacterLocked != null )
		return

	                         
	if ( skinOrNull != null )
		RequestSetItemFlavorLoadoutSlot( LocalClientEHI(), Loadout_CharacterSkin( character ), expect ItemFlavor( skinOrNull ) )
	RequestSetItemFlavorLoadoutSlot( LocalClientEHI(), Loadout_Character(), character )

	                                          
	if ( fileLevel.isBrowseMode )
	{
		if ( fileLevel.browseModeShowLockedCharacters )
		{
			LockCharacter()

			foreach( func in file.Callbacks_OnCharacterLocked )
				func( character )
		}

		CloseCharacterSelectNewMenu()
		DoBrowseModeCharacterSelectEffects()
		return
	}

	                                              
	LockCharacter()

	foreach( func in file.Callbacks_OnCharacterLocked )
		func( character )

	               
	fileLevel.desiredCharacterOrNull = character
	fileLevel.desiredSkinOrNull = skinOrNull
	SetMenuState( eNewCharacterSelectMenuState.LOCKED )
}

void function LockCharacter()
{
	entity localClientPlayer = GetLocalClientPlayer()
	if ( !IsValid( localClientPlayer ) )
		return

	Remote_ServerCallFunction( "ClientCallback_Sur_UpdateCharacterLock", true )

	EmitSoundOnEntity( localClientPlayer, "UI_Survival_Intro_LegendSelect" )

	thread FlashScreenWhite( 0.1, 0.3 )

	                                                                    
	Remote_ServerCallFunction( "ClientCommand_Sur_MakeEligibleForJumpMaster" )
}

void function Client_TryUnlockCharacter()
{
	                                             
	if ( !GetLocalClientPlayer().GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) )
		return

	                                  
	if ( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) != fileLevel.localClientLockstepIndex )
		return

	                                                    
	float timeRemaining = GetGlobalNetTime( CHARACTER_SELECT_NETVAR_LOCK_STEP_END_TIME ) - Time()
	if ( timeRemaining <= 0.0 )                                                                                                                                    
		return

	UnlockCharacter()
}

void function UnlockCharacter()
{
	Remote_ServerCallFunction( "ClientCallback_Sur_UpdateCharacterLock", false )
	StopSoundOnEntity( GetLocalClientPlayer(), "UI_InGame_FD_TitanSelected" )
	SetMenuState( eNewCharacterSelectMenuState.PICKING )
}

void function OnLoadoutButton_RightClick()
{
	if ( fileLevel.isBrowseMode && !fileLevel.browseModeShowLockedCharacters )
	{
		UpdateButtonStates()
		return
	}

	if ( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) < 0 )
		return

	if ( Time() >= GetGlobalNetTime( "allSquadsPresentationStartTime" ) + 1.0 && !fileLevel.browseModeShowLockedCharacters )
		return

	if ( !fileLevel.detailsPanelVisible )
		EmitSoundOnEntity( GetLocalClientPlayer(), "UI_Menu_Legend_Details" )
	fileLevel.detailsPanelVisible = !fileLevel.detailsPanelVisible
	UpdateButtonStates()

	foreach( func in file.Callbacks_OnCharacterDetailsToggled )
		func( fileLevel.detailsPanelVisible )
}
#endif         


  	                                                                                                                                                                                           
  	                                                                                                                                                                                                               
  	                                                                                                                                                                                                      
  	                                                                                                                                                                                                        
  	                                                                                                                                                                                                                  
  	                                                                                                                                                                                       

#if CLIENT

void function OnPlayerDestroyed( entity player )
{
	thread PlayerLeftTeam()
}

void function OnPlayerDisconnected( entity player )
{
	thread PlayerLeftTeam()
}

void function PlayerLeftTeam()
{
	WaitFrame()
	if ( IsConnected() && GetLocalClientPlayer() != null )
		UpdateButtonStates()
}

void function OnLockStepPickIndexChanged( entity player, int new )
{
	if ( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) == fileLevel.localClientLockstepIndex )
	{
		thread LocalPlayerPickingSounds()
		FlashGameWindow()
	}

	entity ornull pickingPlayer = GetTeammateForPickingIndex( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )
	if ( pickingPlayer != null )
	{
		expect entity( pickingPlayer )
		LoadoutEntry characterSlot = Loadout_Character()
		EHI pickingPlayerEHI       = ToEHI( pickingPlayer )
		if ( LoadoutSlot_IsReady( pickingPlayerEHI, characterSlot ) )
		{
			ItemFlavor character = LoadoutSlot_GetItemFlavor( pickingPlayerEHI, characterSlot )
			fileLevel.desiredCharacterOrNull = character
			fileLevel.desiredSkinOrNull = null
		}
	}

	SetMenuState( eNewCharacterSelectMenuState.PICKING )

	UpdateButtonStates()
}

void function OnLockStepPickTimeChanged( entity player, float new )
{
	UpdateButtonStates()
}

void function ServerCallback_ForceCharacterLockFeedback( entity player, bool isLocked )
{
	entity localPlayer = GetLocalClientPlayer()
	if ( !IsValid( localPlayer ) )
		return

	EHI playerEHI     = ToEHI( player )

	if ( isLocked )
	{
		                            

		                       
		LoadoutEntry characterSlot = Loadout_Character()
		if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
			return
		ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )

		bool doFlash = (player != localPlayer)
		if ( doFlash )
		{
			                                                                                                                                             
			EmitSoundOnEntity( localPlayer, "UI_InGame_FD_TitanSelected" )
			thread FlashScreenWhite( 0.1, 0.3 )
		}

		               
		fileLevel.desiredCharacterOrNull = character
		fileLevel.desiredSkinOrNull = null
		                                                 
		fileLevel.lastLockedPlayer = player
		SetMenuState( eNewCharacterSelectMenuState.LOCKED )
	}
	else
	{
		                                  

		               
		fileLevel.desiredCharacterOrNull = null
		fileLevel.desiredSkinOrNull = null
		SetMenuState( eNewCharacterSelectMenuState.PICKING )
	}

	                       
	UpdateButtonStates()
}

void function OnPlayerUpdatedCharacterLock( entity player, bool isLocked )
{
	if ( !fileLevel.menuEntsReady )
		return

	if ( !IsValid( player ) )
		return

	entity localPlayer = GetLocalClientPlayer()
	if ( !IsValid( localPlayer ) )
		return

	EHI playerEHI     = ToEHI( player )
	int lockstepIndex = player.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX )
	if ( lockstepIndex < 0 )
		return

	if ( player.GetTeam() != localPlayer.GetTeam() )
	{
		UpdateButtonStates()
		return
	}

	ServerCallback_ForceCharacterLockFeedback( player, isLocked )
}

void function OnPlayerUpdatedCharacterFocus( entity player, int newCharacterGUID )
{
	if ( !fileLevel.menuEntsReady )
		return

	if ( !IsValid( player ) )
		return

	entity localPlayer = GetLocalClientPlayer()
	if ( !IsValid( localPlayer ) )
		return

	                              
	if ( player.GetTeam() != localPlayer.GetTeam() )
		return

	                                                                                              
	if ( player == localPlayer )
		return

	                       
	UpdateButtonStates()

	                                                                                          
	entity ornull playerForSlot = GetTeammateForPickingIndex( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )
	if ( playerForSlot == null || expect entity( playerForSlot )  != player )
		return

	  
	                
	                               
	                                                     
	                                                       
		      
	                                                                            
	           
	                                                          
	                                                  
		      
	                                                                    
	  

	if ( !IsValidItemFlavorGUID( newCharacterGUID ) )
		return

	ItemFlavor character = GetItemFlavorByGUID( newCharacterGUID )

	               
	fileLevel.desiredCharacterOrNull = character
	fileLevel.desiredSkinOrNull = null
	Signal( fileLevel.signalDummy, "UpdateScene" )
}

void function OnLockStepPlayerIndexChanged( entity player, int newValue )
{
	if ( player == GetLocalClientPlayer() )
	{
		if ( fileLevel.countdownRui != null )
			RuiSetInt( fileLevel.countdownRui, "yourPick", newValue + 1 )
	}

	                       
	UpdateButtonStates()
}

void function OnTeammateLoadoutSelectionChanged( EHI playerEHI, ItemFlavor unused )
{
	                                                                                              
	if ( playerEHI == LocalClientEHI() )
		return

	                                         
	entity player = FromEHI( playerEHI )
	if ( player == null || !IsValid( player ) )
		return

	entity localClientPlayer = GetLocalClientPlayer()
	if ( !IsValid( localClientPlayer ) )
		return

	if ( player.GetTeam() != localClientPlayer.GetTeam() )
		return

	                                                                                                                     
	entity ornull playerForSlot = GetTeammateForPickingIndex( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )
	if ( playerForSlot == null || ToEHI( expect entity( playerForSlot ) ) != playerEHI )
		return

	                
	LoadoutEntry characterSlot = Loadout_Character()
	if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
		return
	ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )

	           
	LoadoutEntry skinSlot = Loadout_CharacterSkin( character )
	if ( !LoadoutSlot_IsReady( playerEHI, skinSlot ) )
		return
	                                                                    

	               
	fileLevel.desiredCharacterOrNull = character
	fileLevel.desiredSkinOrNull = null
	Signal( fileLevel.signalDummy, "UpdateScene" )

	                       
	UpdateButtonStates()
}

void function ServerCallback_CharacterLockRejected()
{
	UnlockCharacter()
	EmitSoundOnEntity( GetLocalClientPlayer(), "ui_ingame_fd_armoryclose" )
}

void function OnPlayerUpdatedCharacterLockTime( entity player, float newTime )
{
	if ( fileLevel.isBrowseMode && fileLevel.browseModeShowLockedCharacters )
		UpdateButtonStates()
}
#endif         

















  	                                                                                                                                                                                                                                                                  
  	                                                                                                                                                                                                                                                                              
  	                                                                                                                                                                                                                                        
  	                                                                                                                                                                                                                                        
  	                                                                                                                                                                                                                                                            
  	                                                                                                                                                                                                                                                  

#if CLIENT

void function UpdateButtonStates()
{
	if ( !fileLevel.menuEntsReady )
		return

	Assert( fileLevel.characterButtons.len() == fileLevel.characterButtonRuis.len() )

	entity localPlayer    = GetLocalClientPlayer()
	array<entity> players = GetPlayerSquad()

	int currentLockStepIndex   = GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX )
	bool localPlayerIsLockedIn = localPlayer.GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER )

	for ( int i = 0 ; i < fileLevel.characterButtons.len() ; i++ )
	{
		var button = fileLevel.characterButtons[i]

		                                       
		if ( !IsValid( button ) )
			return

		if ( (!fileLevel.isBrowseMode && (currentLockStepIndex < -1 || currentLockStepIndex >= MAX_TEAM_PLAYERS)) || !fileLevel.buttonIndexUsed.contains( i ) )
		{
			                                                                              
			     
			                                                                                                                          
			                                                      

			if ( (currentLockStepIndex < -1) || (Time() >= GetGlobalNetTime( "allSquadsPresentationStartTime" )) )
				Hud_SetVisible( button, false )

			Hud_SetEnabled( button, false )
			continue
		}

		var buttonRui        = fileLevel.characterButtonRuis[i]
		ItemFlavor character = fileLevel.buttonIndexCharacterMap[ i ]
		ItemFlavor ornull skin = GetCharacterSkinOrNullForButtonIndex( i )

		                               
		Hud_SetVisible( button, true )
		Hud_SetLocked( button, false )
		Hud_SetEnabled( button, true )
		RuiSetBool( buttonRui, "isDisabledCharacter", false )
		RuiSetBool( buttonRui, "isFakeDisabled", false )
		RuiSetBool( buttonRui, "isSelecting", currentLockStepIndex == localPlayer.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX ) )

		RuiSetInt( buttonRui, "teamSelectedIndex", -1 )
		RuiSetInt( buttonRui, "teamSelectedTeamColorIndex", -1 )

		for ( int k = 0 ; k < MAX_TEAM_FOCUS_INDEX ; k++ )
			RuiSetBool( buttonRui, "teamFocused" + k, false )

		if ( IsValid( localPlayer ) )
		{
			RuiSetInt( buttonRui, "localPlayerLockstepIndex", localPlayer.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX ) )
			RuiSetInt( buttonRui, "localPlayerTeamColorIndex", localPlayer.GetTeamMemberIndex() )
		}

		Hud_ClearToolTipData( button )
		ToolTipData td
		td.tooltipFlags = eToolTipFlag.HIDDEN
		td.tooltipStyle = eTooltipStyle.DEFAULT
		Hud_SetToolTipData( button, td )

		if ( fileLevel.tooltipUpdateFunc != null )
		{
			fileLevel.tooltipUpdateFunc( character, td, fileLevel.lockedButtonIndexes.contains( i ), fileLevel.disabledButtonIndexes.contains( i ) )
		}

		if ( fileLevel.lockedButtonIndexes.contains( i ) )
		{
			Hud_SetLocked( button, true )
			Hud_SetEnabled( button, false )
			                                                                                                            
		}
		if ( fileLevel.disabledButtonIndexes.contains( i ) )
		{
			                               
			Hud_SetEnabled( button, false )
			RuiSetBool( buttonRui, "isDisabledCharacter", true )
			continue
		}

		                                                                                                       
		                                                                          
		if ( fileLevel.isBrowseMode && !fileLevel.browseModeShowLockedCharacters )
			continue

		               
		foreach( entity player in players )
		{
			if ( PlayerHasCharacterLockedInOrFocused( player, character, skin ) )
			{
				int playerPickIndex = player.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX )
				if ( playerPickIndex <= MAX_TEAM_FOCUS_INDEX && playerPickIndex >= 0 )
				{
					RuiSetBool( buttonRui, "teamFocused" + playerPickIndex, true )
					RuiSetInt( buttonRui, "teamColorIndex" + playerPickIndex, player.GetTeamMemberIndex() )
				}
			}
		}

		                       
		entity ornull playerWithThisCharacterLocked = GetPlayerWithLockedCharacter( character, skin, players )
		if ( playerWithThisCharacterLocked != null )
		{
			int playerPickIndex = expect entity( playerWithThisCharacterLocked ).GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX )
			RuiSetInt( buttonRui, "teamSelectedIndex", playerPickIndex )
			RuiSetInt( buttonRui, "teamSelectedTeamColorIndex", expect entity( playerWithThisCharacterLocked ).GetTeamMemberIndex() )
		}

		                                                                                 
		if ( localPlayerIsLockedIn && !fileLevel.isBrowseMode )
		{
			                                 
			RuiSetBool( buttonRui, "isFakeDisabled", true )
		}
	}

	                            
	LoadoutEntry characterSlot = Loadout_Character()
	for ( int i = 0 ; i < fileLevel.ruiPlayerBarRuis.len() ; i++ )
	{
		var playerRui = fileLevel.ruiPlayerBarRuis[i]

		float pickStartTime = GetGlobalNetTime( "pickLoadoutGamestateStartTime" )
		RuiSetGameTime( playerRui, "countdownEndTime", pickStartTime )
		RuiSetInt( playerRui, "yourPick", fileLevel.localClientLockstepIndex + 1 )

		                          
		RuiSetBool( playerRui, "isSelecting", currentLockStepIndex == i )
		RuiSetBool( playerRui, "showingCharacterDetails", fileLevel.detailsPanelVisible )
		RuiSetFloat( playerRui, "gcardsStartTime", GetGlobalNetTime( "allSquadsPresentationStartTime" ) )

		if ( i == currentLockStepIndex )
		{
			RuiSetGameTime( playerRui, "selectingStartTime", GetGlobalNetTime( CHARACTER_SELECT_NETVAR_LOCK_STEP_START_TIME ) )
			RuiSetGameTime( playerRui, "selectingEndTime", GetGlobalNetTime( CHARACTER_SELECT_NETVAR_LOCK_STEP_END_TIME ) )
		}
		else if ( i < currentLockStepIndex )
		{
			RuiSetGameTime( playerRui, "selectingStartTime", 0.0 )
			RuiSetGameTime( playerRui, "selectingEndTime", 0.0 )
		}

		entity ornull playerOrNull = GetTeammateForPickingIndex( i )
		if ( IsValid( playerOrNull ) )
		{
			                     
			entity player = expect entity( playerOrNull )
			EHI playerEHI = ToEHI( player )

			RuiSetInt( playerRui, "playerTeamColorIndex", player.GetTeamMemberIndex() )

			bool isJumpmaster = IsPlayerJumpMaster( player )

			if ( !(i in fileLevel.connectedPlayerNames) )
				fileLevel.connectedPlayerNames[ i ] <- player.GetPlayerNameWithClanTag()
			else
				fileLevel.connectedPlayerNames[ i ] = player.GetPlayerNameWithClanTag()

			if ( player.GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) && LoadoutSlot_IsReady( playerEHI, characterSlot ) )
			{
				                          
				ItemFlavor character = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
				asset lockedPortrait = CharacterClass_GetCharacterLockedPortrait( character )
				if ( lockedPortrait == $"" )
					lockedPortrait = CharacterClass_GetCharacterSelectPortrait( character )
				RuiSetBool( playerRui, "lockedCharacter", true )
				RuiSetString( playerRui, "characterName", ItemFlavor_GetLongName( character ) )
				RuiSetString( playerRui, "playerName", player.GetPlayerNameWithClanTag() )
				RuiTrackInt( playerRui, "micStatus", player, RUI_TRACK_MIC_STATUS )
				RuiSetImage( playerRui, "lockedPortraitImage", lockedPortrait )
				RuiSetBool( playerRui, "statusTextVisible", true )
				RuiSetBool( playerRui, "isDisconnected", false )
				RuiSetBool( playerRui, "isJumpmaster", isJumpmaster )
			}
			else
			{
				                         
				RuiSetBool( playerRui, "lockedCharacter", false )
				RuiSetString( playerRui, "characterName", "" )
				RuiSetString( playerRui, "playerName", player.GetPlayerNameWithClanTag() )
				RuiTrackInt( playerRui, "micStatus", player, RUI_TRACK_MIC_STATUS )
				RuiSetImage( playerRui, "lockedPortraitImage", $"" )
				RuiSetBool( playerRui, "statusTextVisible", true )
				RuiSetBool( playerRui, "isDisconnected", false )
				RuiSetBool( playerRui, "isJumpmaster", isJumpmaster )
			}
		}
		else
		{
			                                       
			RuiSetBool( playerRui, "lockedCharacter", false )
			RuiSetImage( playerRui, "lockedPortraitImage", $"" )
			RuiSetInt( playerRui, "playerTeamColorIndex", -1 )

			if ( i in fileLevel.connectedPlayerNames )
			{
				                      
				string playerName = fileLevel.connectedPlayerNames[ i ]
				RuiSetString( playerRui, "characterName", "Disconnected" )
				RuiSetString( playerRui, "playerName", playerName )
				RuiSetInt( playerRui, "micStatus", 3 )
				RuiSetBool( playerRui, "statusTextVisible", true )
				RuiSetBool( playerRui, "isDisconnected", true )
				RuiSetBool( playerRui, "isJumpmaster", false )
			}
			else
			{
				                     
				RuiSetString( playerRui, "characterName", "" )
				RuiSetString( playerRui, "playerName", "" )
				RuiSetInt( playerRui, "micStatus", 3 )
				RuiSetBool( playerRui, "statusTextVisible", false )
				RuiSetBool( playerRui, "isDisconnected", false )
				RuiSetBool( playerRui, "isJumpmaster", false )
			}
		}
	}

	                       
	if ( fileLevel.detailsPanelVisible )
	{
		Hud_SetVisible( fileLevel.detailsPanel, true )

		ItemFlavor ornull detailsCharacter = null

		                                       
		for ( int i = 0 ; i < fileLevel.characterButtons.len() ; i++ )
		{
			var button = fileLevel.characterButtons[i]

			if ( !Hud_IsFocused( button ) )
				continue

			detailsCharacter = fileLevel.buttonIndexCharacterMap[ i ]
			break
		}

		                                                                 
		if ( detailsCharacter == null )
			detailsCharacter = fileLevel.desiredCharacterOrNull

		if ( detailsCharacter != null )
		{
			UpdateCharacterDetailsMenu( fileLevel.detailsRui, expect ItemFlavor( detailsCharacter ), false )
			Hud_SetVisible( fileLevel.detailsPanel, true )
		}
		else if ( !fileLevel.isBrowseMode )
		{
			Hud_SetVisible( fileLevel.detailsPanel, false )
		}
	}
	else
	{
		Hud_SetVisible( fileLevel.detailsPanel, false )
	}

	                     
	RuiSetBool( fileLevel.buttonHintRui, "showingCharacterDetails", fileLevel.detailsPanelVisible )

	string topString    = ""
	string bottomString = ""
	if ( currentLockStepIndex >= 0 && currentLockStepIndex < MAX_TEAM_PLAYERS )
	{
		if ( SquadMuteLegendSelectEnabled() && !IsSoloMode() )
			topString = Localize( IsSquadMuted() ? "#CHAR_SEL_BUTTON_UNMUTE" : "#CHAR_SEL_BUTTON_MUTE" )

		if ( currentLockStepIndex == fileLevel.localClientLockstepIndex )
		{
			if ( localPlayerIsLockedIn )
				bottomString = Localize( "#CHAR_SEL_BUTTON_HINT_CANEL_DETAILS" )
			else
				bottomString = Localize( "#CHAR_SEL_BUTTON_HINT_SELECT_DETAILS" )
		}
		else
		{
			bottomString = Localize( "#CHAR_SEL_BUTTON_HINT_DETAILS" )
		}
	}
	else if ( SquadMuteLegendSelectEnabled() )
	{
                        
                                                                               
    
                                                                     
    
                            
    
                                                                                                   
    
       
    
                     
    
       
			if ( !IsSoloMode() )
				bottomString = Localize( IsSquadMuted() ? "#CHAR_SEL_BUTTON_UNMUTE" : "#CHAR_SEL_BUTTON_MUTE" )
			else
				bottomString = ""
        
	}

	string finalString = Localize( "#CHAR_SEL_BUTTON_HINT_N_N", topString, bottomString )
	RuiSetString( fileLevel.buttonHintRui, "hintString", finalString )

	Hud_SetVisible( fileLevel.buttonHintPanel, currentLockStepIndex >= 0 && currentLockStepIndex < MAX_TEAM_PLAYERS )
	Hud_SetVisible( fileLevel.buttonHintPanel, true )
}

void function LocalPlayerPickingSounds()
{
	entity player = GetLocalClientPlayer()
	if ( !IsValid( player ) )
		return

	Signal( player, "LocalPlayerPickingSounds" )
	EndSignal( player, "LocalPlayerPickingSounds" )
	EndSignal( player, "OnDestroy" )

	                      
	EmitSoundOnEntity( player, "pilot_collectible_pickup" )

	while( Time() < GetGlobalNetTime( CHARACTER_SELECT_NETVAR_LOCK_STEP_END_TIME ) )
	{
		float timeRemaining = GetGlobalNetTime( CHARACTER_SELECT_NETVAR_LOCK_STEP_END_TIME ) - Time()
		EmitSoundOnEntity( player, "UI_Survival_Intro_LegendSelectCountDown" )
		wait 1.0
	}
}

void function SetMenuState( int state )
{
	fileLevel.desiredMenuState = state
	Signal( fileLevel.signalDummy, "UpdateScene" )
}

void function UpdateSceneThink()
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	int currentMenuState                     = -1
	ItemFlavor ornull currentCharacterOrNull = null
	ItemFlavor ornull currentSkinOrNull = null
	bool playedPickingAnimForCharacter       = false
	bool playedReadyAnimForCharacter         = false

	while( true )
	{
		WaitSignal( fileLevel.signalDummy, "UpdateScene" )

		if ( fileLevel.desiredMenuState == -1 || fileLevel.desiredCharacterOrNull == null )
			continue

		bool shouldUpdateModel = false
		bool shouldUpdateAnim  = false
		int currentPickIndex   = GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX )

		bool menuStateChanged = fileLevel.desiredMenuState != currentMenuState
		if ( menuStateChanged )
			currentMenuState = fileLevel.desiredMenuState

		                                                                        
		if ( (fileLevel.desiredCharacterOrNull != currentCharacterOrNull) || (fileLevel.desiredSkinOrNull != currentSkinOrNull) )
		{
			shouldUpdateModel = true
			shouldUpdateAnim = true
			currentCharacterOrNull = fileLevel.desiredCharacterOrNull
			currentSkinOrNull = fileLevel.desiredSkinOrNull
		}

		                                                                          
		if ( currentPickIndex != fileLevel.localClientLockstepIndex && fileLevel.lastLockedPlayer != GetTeammateForPickingIndex( currentPickIndex ) && Time() - fileLevel.lockSequenceAnimTime < READY_ANIM_MIN_DURATION )
		{
			shouldUpdateAnim = false
			shouldUpdateModel = false
		}


		                                 
		if ( menuStateChanged && currentMenuState == eNewCharacterSelectMenuState.LOCKED )
		{
			shouldUpdateAnim = true
			shouldUpdateModel = true
		}

		                                                                              
		if ( currentMenuState == eNewCharacterSelectMenuState.PICKING && playedReadyAnimForCharacter )
		{
			shouldUpdateAnim = false
		}

#if NX_PROG || PC_PROG_NX_UI
		if( fileLevel.operationModeChanged )
		{
			fileLevel.operationModeChanged = false
			shouldUpdateModel = true
			shouldUpdateAnim = true
		}
#endif

		                                                            
		                                                                                                    
		if ( shouldUpdateModel )
			shouldUpdateAnim = true

		printt( "| -------- UpdateScene --------" )
		printt( "| shouldUpdateModel:", shouldUpdateModel )
		printt( "| shouldUpdateAnim:", shouldUpdateAnim )
		printt( "| -----------------------------" )

		if ( shouldUpdateModel )
		{
			                                                            
			shouldUpdateAnim = true
			playedPickingAnimForCharacter = false
			playedReadyAnimForCharacter = false

			                   
			thread UpdatePlayerModel( expect ItemFlavor(currentCharacterOrNull), currentSkinOrNull )
		}

		if ( shouldUpdateAnim )
		{
			                  

			                                                                     

			if ( currentMenuState == eNewCharacterSelectMenuState.PICKING )
				playedPickingAnimForCharacter = true
			if ( currentMenuState == eNewCharacterSelectMenuState.LOCKED )
				playedReadyAnimForCharacter = true

			thread UpdatePlayerAnim( expect ItemFlavor(currentCharacterOrNull), currentMenuState )
		}
	}
}

void function TryUpdateLightingRig( ItemFlavor character, ItemFlavor characterSkin )
{
	if ( !fileLevel.lightEntsExist )
	{
		printt( "Map doesn't have menu lights compiled in. Make sure the latest menu box instance is in the level and recompile the map." )
		return
	}

	CharacterMenuLightData lightData

	if ( CharacterSkin_HasMenuCustomLighting( characterSkin ) )
	{
		lightData = CharacterSkin_GetMenuCustomLightData( characterSkin )
	}
	else
	{
		lightData = CharacterClass_GetMenuLightData( character )
	}

	        
	fileLevel.keyLight.SetTweakLightColor( lightData.key_color )
	fileLevel.keyLight.SetTweakLightBrightness( lightData.key_brightness )
	fileLevel.keyLight.SetTweakLightCone( lightData.key_cone )
	fileLevel.keyLight.SetTweakLightInnerCone ( lightData.key_innercone )
	fileLevel.keyLight.SetTweakLightDistance( lightData.key_distance )
	fileLevel.keyLight.SetTweakLightHalfBrightFrac( lightData.key_halfbrightfrac )
	fileLevel.keyLight.SetTweakLightSpecIntensity( lightData.key_specint )
	fileLevel.keyLight.SetTweakLightPBRFalloff( lightData.key_pbrfalloff )
	fileLevel.keyLight.SetTweakLightRealtimeShadows( lightData.key_castshadows )
	fileLevel.fillLight.SetTweakLightColor( lightData.fill_color )
	fileLevel.fillLight.SetTweakLightBrightness( lightData.fill_brightness )
	fileLevel.fillLight.SetTweakLightCone( lightData.fill_cone )
	fileLevel.fillLight.SetTweakLightInnerCone ( lightData.fill_innercone )
	fileLevel.fillLight.SetTweakLightDistance( lightData.fill_distance )
	fileLevel.fillLight.SetTweakLightHalfBrightFrac( lightData.fill_halfbrightfrac )
	fileLevel.fillLight.SetTweakLightSpecIntensity( lightData.fill_specint )
	fileLevel.fillLight.SetTweakLightPBRFalloff( lightData.fill_pbrfalloff )
	fileLevel.fillLight.SetTweakLightRealtimeShadows( lightData.fill_castshadows )
	fileLevel.rimLightL.SetTweakLightColor( lightData.rimL_color )
	fileLevel.rimLightL.SetTweakLightBrightness( lightData.rimL_brightness )
	fileLevel.rimLightL.SetTweakLightCone( lightData.rimL_cone )
	fileLevel.rimLightL.SetTweakLightInnerCone ( lightData.rimL_innercone )
	fileLevel.rimLightL.SetTweakLightDistance( lightData.rimL_distance )
	fileLevel.rimLightL.SetTweakLightHalfBrightFrac( lightData.rimL_halfbrightfrac )
	fileLevel.rimLightL.SetTweakLightSpecIntensity( lightData.rimL_specint )
	fileLevel.rimLightL.SetTweakLightPBRFalloff( lightData.rimL_pbrfalloff )
	fileLevel.rimLightL.SetTweakLightRealtimeShadows( lightData.rimL_castshadows )
	fileLevel.rimLightR.SetTweakLightColor( lightData.rimR_color )
	fileLevel.rimLightR.SetTweakLightBrightness( lightData.rimR_brightness )
	fileLevel.rimLightR.SetTweakLightCone( lightData.rimR_cone )
	fileLevel.rimLightR.SetTweakLightInnerCone ( lightData.rimR_innercone )
	fileLevel.rimLightR.SetTweakLightDistance( lightData.rimR_distance )
	fileLevel.rimLightR.SetTweakLightHalfBrightFrac( lightData.rimR_halfbrightfrac )
	fileLevel.rimLightR.SetTweakLightSpecIntensity( lightData.rimR_specint )
	fileLevel.rimLightR.SetTweakLightPBRFalloff( lightData.rimR_pbrfalloff )
	fileLevel.rimLightR.SetTweakLightRealtimeShadows( lightData.rimR_castshadows )

	           
	fileLevel.lightRigModel.Anim_Play( lightData.animSeq )
	int attachIdx_fill = fileLevel.lightRigModel.LookupAttachment( "LIGHT_1" )
	int attachIdx_rimL = fileLevel.lightRigModel.LookupAttachment( "LIGHT_2" )
	int attachIdx_rimR = fileLevel.lightRigModel.LookupAttachment( "LIGHT_3" )
	int attachIdx_key = fileLevel.lightRigModel.LookupAttachment( "LIGHT_4" )

	fileLevel.fillLight.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_fill ) )
	fileLevel.fillLight.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_fill ) )

	fileLevel.rimLightL.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_rimL ) )
	fileLevel.rimLightL.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_rimL ) )

	fileLevel.rimLightR.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_rimR ) )
	fileLevel.rimLightR.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_rimR ) )

	fileLevel.keyLight.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_key ) )
	fileLevel.keyLight.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_key ) )

	foreach ( func in file.Callbacks_CustomUpdateLights )
	{
		func( fileLevel.lightRigModel, fileLevel.keyLight, fileLevel.fillLight, fileLevel.rimLightL, fileLevel.rimLightR )
	}
}

void function SetChromaCharacter( ItemFlavor character )
{
	Chroma_SetBaseLayer( CHROMALOOP_SMOKE, CHROMATRANS_VERTICAL, CharacterClass_GetChromaGradient( character ), 0.5 )
}

ItemFlavor function GetCharacterSkinForPlayerSelection( EHI pickingPlayerEHI, ItemFlavor character, ItemFlavor ornull characterSkinOverride )
{
	if ( characterSkinOverride != null )
		return (expect ItemFlavor( characterSkinOverride ))

	return LoadoutSlot_WaitForItemFlavor( pickingPlayerEHI, Loadout_CharacterSkin( character ) )
}

void function UpdatePlayerModel( ItemFlavor character, ItemFlavor ornull characterSkinOverride )
{
	Signal( fileLevel.signalDummy, "UpdatingModel" )
	EndSignal( fileLevel.signalDummy, "UpdatingModel" )

	fileLevel.isUpdatePlayerModelRunning = true
	OnThreadEnd( void function() {
		fileLevel.isUpdatePlayerModelRunning = false
	} )

	if ( !fileLevel.menuEntsExist )
		return

	if ( !IsValid( fileLevel.characterModel ) )
		return

	entity ornull pickingPlayer = GetTeammateForPickingIndex( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )
	if ( fileLevel.isBrowseMode )                                               
		pickingPlayer = GetLocalClientPlayer()
	if ( pickingPlayer == null )
			return                                                               

	expect entity( pickingPlayer )

	                       
	                                                                                                              
	ItemFlavor characterSkin = GetCharacterSkinForPlayerSelection( ToEHI( pickingPlayer ), character, characterSkinOverride )
	if ( !IsValid( fileLevel.characterModel ) )
		return

	CreateNewCharacterModel( CharacterSkin_GetBodyModel( characterSkin ) )
	CharacterSkin_Apply( fileLevel.characterModel, characterSkin )
	                                                                                                                                                                                  
	fileLevel.characterModel.Show()

	Signal( fileLevel.signalDummy, "PlayerModelUpdated" )

	                    
	vector flashColor = ItemFlavor_GetQualityColor( characterSkin ) / 255
	thread FlashMenuModel( fileLevel.characterModel, eMenuModelFlashType.CHARACTER_SELECT, flashColor )

	             
	int backgroundSkinIndex = CharacterClass_GetMenuBackgroundSkinIndex( character )
	if ( IsValid( fileLevel.backgroundModelGeo ) )
		fileLevel.backgroundModelGeo.SetSkin( backgroundSkinIndex )

	                   
	int smokeSkinIndex = CharacterClass_GetMenuSmokeSkinIndex( character )
	if ( IsValid( fileLevel.backgroundModelSmoke ) )
		fileLevel.backgroundModelSmoke.SetSkin( smokeSkinIndex )

	TryUpdateLightingRig( character, characterSkin )

	SetChromaCharacter( character )

	                 
	RuiSetString( fileLevel.backgroundRui, "nameString", Localize( ItemFlavor_GetLongName( character ) ) )
	RuiSetString( fileLevel.backgroundRui, "footnoteString", Localize( ItemFlavor_GetShortDescription( character ) ) )
	RuiSetFloat( fileLevel.backgroundRui, "startTime", Time() )

	foreach ( func in file.Callbacks_OnCharacterModelChanged )
	{
		func( character, fileLevel.characterModel, fileLevel.backgroundModelGeo, fileLevel.backgroundModelSmoke, fileLevel.backgroundRui )
	}
}

void function UpdatePlayerAnim( ItemFlavor character, int currentMenuState )
{
	if ( !fileLevel.menuEntsExist )
		return

	Signal( fileLevel.signalDummy, "UpdatingAnim" )
	EndSignal( fileLevel.signalDummy, "UpdatingAnim" )
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	if ( fileLevel.isUpdatePlayerModelRunning )
	{
		WaitSignal( fileLevel.signalDummy, "PlayerModelUpdated" )
	}

	entity ornull pickingPlayer = GetTeammateForPickingIndex( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )

	if ( fileLevel.isBrowseMode )
		pickingPlayer = GetLocalClientPlayer()

	if ( pickingPlayer == null )
		return

	expect entity( pickingPlayer )

	                       
	ItemFlavor characterSkin = LoadoutSlot_WaitForItemFlavor( ToEHI( pickingPlayer ), Loadout_CharacterSkin( character ) )

	if ( currentMenuState == eNewCharacterSelectMenuState.PICKING )
	{
		printt( "| PICKING ANIM", string(fileLevel.characterModel.GetModelName()) )

		asset customIntroAnim = CharacterSkin_GetCustomCharSelectIntroAnim( characterSkin )
		asset customIdleAnim  = CharacterSkin_GetCustomCharSelectIdleAnim( characterSkin )
		Assert( (customIntroAnim == $"") == (customIdleAnim == $""), format( "Char skin '%s' has only one char select custom anim set!", ItemFlavor_GetHumanReadableRef( characterSkin ) ) )
		if ( (customIntroAnim != $"") && ShipHackCheckForAnim( customIntroAnim, fileLevel.characterModel, characterSkin ) && ShipHackCheckForAnim( customIdleAnim, fileLevel.characterModel, characterSkin ) )
		{
			                                                                                                                                                                         
			fileLevel.characterModel.Anim_Play( customIntroAnim )
			WaittillAnimDone( fileLevel.characterModel )
			                                                                                                                                                                         
			fileLevel.characterModel.Anim_Play( customIdleAnim )
			WaittillAnimDone( fileLevel.characterModel )
		}
		else
		{
			entity charNode = fileLevel.characterNode
#if NX_PROG || PC_PROG_NX_UI
			if( IsNxHandheldMode() )
			{
				charNode = fileLevel.nxCharacterNode
			}
#endif
			                                                                                                                                                                    
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_MAIN_INTRO", charNode )
			                                                                                                                                                                   
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_MAIN_IDLE", charNode )
		}
	}
	else if ( currentMenuState == eNewCharacterSelectMenuState.LOCKED )
	{
		printt( "| LOCKED ANIM", string(fileLevel.characterModel.GetModelName()) )
		Chroma_AddOverlay( CHROMALOOP_SMOKE, CHROMAWAVE_FLASH, {[0.0] = <1, 1, 1>}, 2.0 )
		thread PlayCharacterReadyUpLine( character )
		fileLevel.lockSequenceAnimTime = Time()

		asset customReadyIntroAnim = CharacterSkin_GetCustomCharSelectReadyIntroAnim( characterSkin )
		asset customReadyIdleAnim  = CharacterSkin_GetCustomCharSelectReadyIdleAnim( characterSkin )
		Assert( (customReadyIntroAnim == $"") == (customReadyIdleAnim == $""), format( "Char skin '%s' has only one char select custom anim set!", ItemFlavor_GetHumanReadableRef( characterSkin ) ) )

		if ( (customReadyIntroAnim != $"") && ShipHackCheckForAnim( customReadyIntroAnim, fileLevel.characterModel, characterSkin ) && ShipHackCheckForAnim( customReadyIdleAnim, fileLevel.characterModel, characterSkin ) )
		{
			                                                                                                                                                                              
			fileLevel.characterModel.Anim_Play( customReadyIntroAnim )
			WaittillAnimDone( fileLevel.characterModel )
			                                                                                                                                                                             
			fileLevel.characterModel.Anim_Play( customReadyIdleAnim )
			WaittillAnimDone( fileLevel.characterModel )
		}
		else
		{
			entity charNode = fileLevel.characterNode
#if NX_PROG || PC_PROG_NX_UI
			if( IsNxHandheldMode() )
			{
				charNode = fileLevel.nxCharacterNode
			}
#endif
			                                                                                                                                                                       
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_READYUP_INTRO", charNode )
			                                                                                                                                                                    
			PlayAnim( fileLevel.characterModel, "ACT_MP_MENU_READYUP_IDLE", charNode )
		}
	}
}

bool function ShipHackCheckForAnim( asset reqAnim, entity characterModel, ItemFlavor characterSkin )
{
	if ( !characterModel.Anim_HasSequence( reqAnim ) )
	{
		Warning( "%s() - Character model '%s' is missing expected animation '%s'. Character skin being referenced is '%s'.", FUNC_NAME(), string( characterModel.GetModelName() ), string( reqAnim ), ItemFlavor_GetHumanReadableRef( characterSkin ) )
		return false
	}

	return true
}

void function PlayCharacterReadyUpLine( ItemFlavor character )
{
	                                                    
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	array<string> readyUpLines = CharacterClass_GetReadyUpVoicelineEventList( character )
	if ( readyUpLines.len() == 0 )
		return

	wait 0.2

	entity player = GetLocalClientPlayer()
	if ( IsValid( player ) )
		EmitSoundOnEntity( player, readyUpLines.getrandom() )
}

void function DebugMenuThink()
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )
	while( true )
	{
		string desiredCharacter = "null"
		if ( fileLevel.desiredCharacterOrNull != null )
			desiredCharacter = ItemFlavor_GetHumanReadableRef( expect ItemFlavor( fileLevel.desiredCharacterOrNull ) )

		string debugString = "-- Menu State --"
		debugString += "\n" + format( "My Turn: %i", fileLevel.localClientLockstepIndex )
		debugString += "\n" + format( "Current Turn: %i", GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )
		debugString += "\n" + format( "Browse Mode: %s", fileLevel.isBrowseMode ? "true" : "false" )
		debugString += "\n" + format( "Desired Character: %s", desiredCharacter )
		debugString += "\n" + format( "Desired Menu State: %s", DEV_GetEnumStringSafe( "eNewCharacterSelectMenuState", fileLevel.desiredMenuState ) )

		DebugScreenText( 0.05, 0.5, debugString )

		WaitFrame()
	}
}

#endif         
                                   
  
                                                                
                                          
                                                          
                                              
                                                                              
  
                                   


#if SERVER
                                                              
 
	                         
		      

	                                   
		      

	                                                           

  	                  
  		                                                                       
  	    
  		                                                                         

	                                                                                    
 

                                                                                       
 
	                                           
	                                        
	 
		                         
		 
			                                                                                     
		 
	 
 
#endif


#if CLIENT
void function ServerToClient_SetClubPartyBool( bool isClubSquad )
{
	if ( !IsConnected() )
		return

  	                  
  		                                                                                               
  	    
  		                                                                                                

	file.isFullClubSquad = isClubSquad
}


bool function GetClubPartyBool()
{
	return file.isFullClubSquad
}


void function UIToClient_SetClubName( string clubName )
{
  	                                                                                                    
	if ( clubName != "" )
	{
		file.clubName = clubName
		Clubs_SetMyStoredClubName( clubName )
	}
}


void function ServerToClient_SetChampionClubSquadName( string clubName )
{
  	                                                                                                                   
	if ( clubName != "" )
		file.championClubName = clubName
}
#endif

#if UI
void function ClientToUI_GetClubName()
{
	string clubName = CLUB_NAME_EMPTY

	if ( Clubs_IsEnabled() && ClubIsValid() )
		clubName = ClubGetHeader().name

  	                                                                                                                                   
	RunClientScript( FUNCNAME_CLUB_SETCLUBNAME_CL, clubName )
}
#endif
















                                                                                                                                    
                                                                                                                                        
                                                                                                             
                                                                                                        
                                                                                                                   
                                                                                                               

#if SERVER
                                   
 
	                        
		                                               
		                                               
		                                               
	      

	                                                                        

	                                                            
	 
		                         
			        

		                        
			                                                 
		      

		                             
		                   

                        
			                                                                         
			 
				                              
				                       
				                       
			 
        

		                     
		                                   
		 
			                        
				                                                                              
			      

			                                                                                       
			               
		 
	 

	                                      

	                        
		                                               
		                                               
	      
 

  
                                                                           
 
	                        
		                                                            
	      

	                                             
	                                          
	 
		                                                        

		                                   

		                        
			             
				                      
			                                               
			                                     
			 
				            
					                     
				                                      
			 
			                     
		      
	 

	                        
		                        
	      

	                                              
	 
		                                 
			      

		                                                                  

		                           
		                                   
		                                

		                                                                           
		                        
			                                                
		      
		                                           
	 
 

                                                                                                       
 
	                                                                                                                                     
	                     
	                                                            
		                        
	                   

	                        
		                                                        
	      

	                   
	                    
	                                   
	 
		                                   
		                                           

		                                             
		                        
			                                                            
		      

		                                             
		 
			                     
			                   
		 
	 

	                                 

	                   
 

                                                               
 
	                                                                                     

	                 
	                                 

	                                         
	 
		                  
			        
		                              
			        
		                    
	 

	             
 

                                                                     
 
	                                                                                     
	                                 
	                                                                             
	                                                                         
 
  
                                                  
 
	                                                                                                                                                                                                       
	 
		                              
		 
			                                      
				                                                                                 
		 
	 
 

                                                                
 
	                                                                                                                                                                                
	                                           
		      

	                                       
		      

	                                                                          

	                                             
	                                                         
	
	                                       

	                                             
	 
		                                                                                                                  
	 

	                                        

	                                                                
	                                     
	                                              
		                                 

	                                                      
	                                             
	 
		                                                                                                    
		                                                         
			                                                       
	 
	                                                                                                                                                  

	                                       
	 
		                     

		                                                                    
		 
			                                                                                          
		 

		                                                                                                                                                                             
		                                                                                                                                                                                                                                                                                                                                                                         
		                                                                                                                                                                                                                                                                                                                                      
	 

	                                                                                                                                                                                                                                        
	                                           
	                                                            

	                                            
	                                             
	 
		                                                                                                    
	 

	                                                                                   
 

                                                                                                        
 
	                         
		      

	                                              
	 
		                                                                                                            
		                  
	 

	                                                                  
	 
		                                                                                                  
		             
	 

	                                                                                         
	 
		                                                
		                                            
		                                                      
		 
			                                                                            
			                                               

			                                                                                         
			                                     
		 
	 

	                                                                                     
	                                                                  

	      
 

#endif         

#if CLIENT

void function CreateNewCharacterModel( asset model )
{
	Assert( IsValid( fileLevel.characterNode ) )

	if ( IsValid( fileLevel.characterModel ) )
		fileLevel.characterModel.Destroy()

	entity charNode = fileLevel.characterNode
#if NX_PROG || PC_PROG_NX_UI
	if( IsNxHandheldMode() )
	{
		charNode = fileLevel.nxCharacterNode
	}
#endif
	fileLevel.characterModel = CreateClientSidePropDynamic( charNode.GetOrigin(), charNode.GetAngles(), model )
	fileLevel.characterModel.MakeSafeForUIScriptHack()
	fileLevel.characterModel.SetParent( charNode ) 
	
	fileLevel.characterModel.Hide()
}

void function CreateNewLightRigModel()
{
	Assert( DoesBackgroundEntExist() )

	if ( IsValid( fileLevel.lightRigModel ) )
		fileLevel.lightRigModel.Destroy()

	entity targetBackground = GetEntByScriptName( BACKGROUND_ENT_NAME )

	fileLevel.lightRigModel = CreateClientSidePropDynamic( targetBackground.GetOrigin(), targetBackground.GetAngles(), LIGHT_RIG_MDL )
	fileLevel.lightRigModel.MakeSafeForUIScriptHack()
	fileLevel.lightRigModel.SetParent( targetBackground )
	fileLevel.lightRigModel.Hide()
}
  
                                                                               
 
	                                   
	 
		                                                                                                                                             
			           
	 
	            
 
  

bool function PlayerHasCharacterLockedInOrFocused( entity player, ItemFlavor character, ItemFlavor ornull skin )
{
	                                 
	if ( PlayerHasCharacterLockedIn( player, character, skin ) )
		return true

	                                                       
	if ( player.GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) )
		return false

	                                     
	if ( player.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_FOCUS_CHARACTER_GUID ) != ItemFlavor_GetGUID( character ) )
		return false

	if ( skin != null )
	{
		expect ItemFlavor( skin )
		if ( player.GetPlayerNetInt( "characterSelectFocusSkinGUID" ) != ItemFlavor_GetGUID( skin ) )
			return false
		}

	return true
}

bool function PlayerHasCharacterLockedIn( entity player, ItemFlavor character, ItemFlavor ornull skin )
{
	LoadoutEntry characterSlot = Loadout_Character()

	if ( !player.GetPlayerNetBool( CHARACTER_SELECT_NETVAR_HAS_LOCKED_IN_CHARACTER ) )
		return false

	EHI playerEHI = ToEHI( player )
	if ( !LoadoutSlot_IsReady( playerEHI, characterSlot ) )
		return false

	ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( playerEHI, characterSlot )
	if ( playerCharacter != character )
		return false

	if ( skin != null )
	{
		expect ItemFlavor( skin )
		ItemFlavor playerSkin = LoadoutSlot_GetItemFlavor( playerEHI, Loadout_CharacterSkin( playerCharacter ) )
		if ( skin != playerSkin )
			return false
	}

	return true
}

entity ornull function GetPlayerWithLockedCharacter( ItemFlavor character, ItemFlavor ornull skin, array<entity> players )
{
	                                                                           
	LoadoutEntry characterSlot = Loadout_Character()
	foreach( entity player in players )
	{
		if ( PlayerHasCharacterLockedIn( player, character, skin ) )
			return player
	}

	return null
}

int function GetButtonIndexForCharacter( ItemFlavor character )
{
	foreach( int index, ItemFlavor itemFlav in fileLevel.buttonIndexCharacterMap )
	{
		if ( character == itemFlav )
			return index
	}
	return -1
}

array<entity> function GetPlayerSquad()
{
	int team                   = GetLocalClientPlayer().GetTeam()
	array<entity> squadPlayers = GetPlayerArrayOfTeam( team )

	ArrayRemoveInvalid( squadPlayers )

	if ( squadPlayers.len() > MAX_TEAM_PLAYERS )
		squadPlayers = squadPlayers.slice( 0, MAX_TEAM_PLAYERS )

	return squadPlayers
}

array<entity> function GetOtherTeammates()
{
	array<entity> teammates = GetPlayerSquad()
	teammates.fastremovebyvalue( GetLocalClientPlayer() )

	if ( teammates.len() > MAX_TEAM_PLAYERS - 1 )
		teammates = teammates.slice( 0, MAX_TEAM_PLAYERS - 1 )

	return teammates
}

void function CharacterSelect_SetIsBrowseMode( bool isBrowseMode )
{
	fileLevel.isBrowseMode = isBrowseMode
}

bool function CharacterSelect_GetIsBrowseMode()
{
	return fileLevel.isBrowseMode
}

bool function IsPlayerJumpMaster( entity player )
{
	if( GameRules_GetGameMode() == SURVIVAL )
		return player == GetLastPickingPlayer()

	return false
}

entity ornull function GetLastPickingPlayer()
{
	entity ornull validPlayer
	for ( int i = MAX_TEAM_PLAYERS - 1 ; i >= 0 ; i-- )
	{
		entity ornull player = GetTeammateForPickingIndex( i )
		if ( !IsValid( player ) )
			continue

		                                                                   
		if ( validPlayer == null )
			validPlayer = player

		                                                                                 
		                                                       
		  	        

		return player
	}

	if ( validPlayer != null )
		return validPlayer

	Assert( 0, "GetLastPickingPlayer wasn't able to get the last picking player on local client team" )

	entity invalidPlayer
	return invalidPlayer
}

entity ornull function GetTeammateForPickingIndex( int index )
{
	int team                   = GetLocalClientPlayer().GetTeam()
	array<entity> squadPlayers = GetPlayerArrayOfTeam( team )
	if ( squadPlayers.len() > MAX_TEAM_PLAYERS )
		squadPlayers = squadPlayers.slice( 0, MAX_TEAM_PLAYERS )

	foreach( entity player in squadPlayers )
	{
		if ( player.GetPlayerNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_PLAYER_INDEX ) == index )
			return player
	}

	return null
}

bool function DoMenuEntsExist()
{
	array<string> entNames =
	[
		CAMERA_ENT_NAME,
		CHARACTER_ENT_NAME,
	]

	                     

	foreach ( name in entNames )
	{
		if ( GetEntArrayByScriptName( name ).len() != 1 )
			return false
	}

	return true
}

bool function DoMenuLightsExist()
{
	array<string> entNames =
	[
		LIGHT_KEY_NAME,
		LIGHT_FILL_NAME,
		LIGHT_RIML_NAME,
		LIGHT_RIMR_NAME,
	]

	foreach ( name in entNames )
	{
		if ( GetEntArrayByScriptName( name ).len() != 1 )
			return false
	}

	return true
}

bool function DoesBackgroundEntExist()
{
	                                     
	return GetEntArrayByScriptName( BACKGROUND_ENT_NAME ).len() > 0
}

void function FlashScreenWhite( float holdTime = 0.5, float fadeOutDuration = 2.0 )
{
	EndSignal( fileLevel.signalDummy, "CharacterSelectClosing" )

	if ( !IsValid( fileLevel.whiteFlash ) )
		return

	OnThreadEnd(
		void function() : ()
		{
			if ( !IsValid( fileLevel.whiteFlash ) )
				return

			Hud_Hide( fileLevel.whiteFlash )
		}
	)

	Hud_SetEnabled( fileLevel.whiteFlash, false )
	Hud_SetAlpha( fileLevel.whiteFlash, 255 )
	Hud_Show( fileLevel.whiteFlash )

	wait holdTime

	if ( !IsValid( fileLevel.whiteFlash ) )
		return

	Hud_FadeOverTime( fileLevel.whiteFlash, 0, fadeOutDuration )

	wait fadeOutDuration
}

void function UpdateCharacterDetailsMenu( var detailsRui, ItemFlavor character, bool showCharacterName )
{
	RuiSetGameTime( detailsRui, "initTime", Time() )
	if ( LoadoutSlot_IsReady( ToEHI( GetLocalClientPlayer() ), Loadout_Character() ) )
	{
		CharacterHudUltimateColorData colorData = CharacterClass_GetHudUltimateColorData( character )
		RuiSetColorAlpha( detailsRui, "ultimateColor", SrgbToLinear( colorData.ultimateColor ), 1 )
		RuiSetColorAlpha( detailsRui, "ultimateColorHighlight", SrgbToLinear( colorData.ultimateColorHighlight ), 1 )
	}

	RuiSetImage( detailsRui, "ultimateIcon", ItemFlavor_GetIcon( CharacterClass_GetUltimateAbility( character ) ) )
	RuiSetString( detailsRui, "ultimateName", Localize( ItemFlavor_GetLongName( CharacterClass_GetUltimateAbility( character ) ) ) )
	RuiSetString( detailsRui, "ultimateDesc", Localize( ItemFlavor_GetLongDescription( CharacterClass_GetUltimateAbility( character ) ) ) )
	RuiSetString( detailsRui, "ultimateType", Localize( "#ULTIMATE" ) )

	RuiSetImage( detailsRui, "tacticalIcon", ItemFlavor_GetIcon( CharacterClass_GetTacticalAbility( character ) ) )
	RuiSetString( detailsRui, "tacticalName", Localize( ItemFlavor_GetLongName( CharacterClass_GetTacticalAbility( character ) ) ) )
	RuiSetString( detailsRui, "tacticalDesc", Localize( ItemFlavor_GetLongDescription( CharacterClass_GetTacticalAbility( character ) ) ) )
	RuiSetString( detailsRui, "tacticalType", Localize( "#TACTICAL" ) )

	ItemFlavor ornull passiveAbility = null
	foreach ( ItemFlavor ability in CharacterClass_GetPassiveAbilities( character ) )
	{
		if ( CharacterAbility_ShouldShowDetails( ability ) )
		{
			                                  
			passiveAbility = ability
			break
		}
	}
	expect ItemFlavor( passiveAbility )

	RuiSetImage( detailsRui, "passiveIcon", ItemFlavor_GetIcon( passiveAbility ) )
	RuiSetString( detailsRui, "passiveName", Localize( ItemFlavor_GetLongName( passiveAbility ) ) )
	RuiSetString( detailsRui, "passiveDesc", Localize( ItemFlavor_GetLongDescription( passiveAbility ) ) )
	RuiSetString( detailsRui, "passiveType", Localize( "#PASSIVE" ) )

	float damageScale = CharacterClass_GetDamageScale( character )

	if ( damageScale < 1.0 )
	{
		int percent = int( ((1.0 - damageScale)*100) + 0.5 )
		string finalString = Localize( "#SPECIAL_PERK_N_N", Localize( "#PAS_FORTIFIED" ), Localize( "#PAS_FORTIFIED_DESC", percent ) )
		RuiSetImage( detailsRui, "specialPerkIcon", $"rui/hud/passive_icons/juggernaut" )
		RuiSetString( detailsRui, "specialPerkDesc", finalString )
		RuiSetBool( detailsRui, "hasModelPerk", true )
	}
	else if ( damageScale > 1.0 )
	{
		int percent = int( (fabs( 1.0 - damageScale ) * 100) + 0.5 )
		string finalString = Localize( "#SPECIAL_PERK_N_N", Localize( "#PAS_LOW_PROFILE" ), Localize( "#PAS_LOW_PROFILE_DESC", percent ) )
		RuiSetImage( detailsRui, "specialPerkIcon", $"rui/hud/passive_icons/low_profile" )
		RuiSetString( detailsRui, "specialPerkDesc", finalString )
		RuiSetBool( detailsRui, "hasModelPerk", true )
	}
	else
	{
		RuiSetImage( detailsRui, "specialPerkIcon", $"" )
		RuiSetString( detailsRui, "specialPerkDesc", "" )
		RuiSetBool( detailsRui, "hasModelPerk", false )
	}


                    
                                                           
      
		string roleDesc = CharacterClass_GetCharacterRolePerkDesc( character )
       
	if ( roleDesc == "" )
	{
		RuiSetImage( detailsRui, "rolePerkIcon", $"" )
		RuiSetBool( detailsRui, "hasRolePerk", false )
	}
	else
	{
		RuiSetImage( detailsRui, "rolePerkIcon", CharacterClass_GetCharacterRoleImage( character )  )
		RuiSetBool( detailsRui, "hasRolePerk", true )
	}
	RuiSetString( detailsRui, "rolePerkDesc", roleDesc )

}

void function SetCharacterSelectSceneForChampionSquad()
{
	                              
	foreach( var rui in fileLevel.gCardRuiHandles )
		RuiDestroyIfAlive( rui )

	foreach( NestedGladiatorCardHandle handle in fileLevel.nestedGladiatorCardHandles )
		CleanupNestedGladiatorCard( handle, true )
	fileLevel.nestedGladiatorCardHandles.clear()

	                   

	if ( IsValid( fileLevel.backgroundModelGeo ) )
		fileLevel.backgroundModelGeo.SetSkin( GetCurrentPlaylistVarInt( "champion_screen_bgModel_skin_override", CHAMPION_SQAUD_BACKGROUND_SKIN_INDEX ) )

	if ( IsValid( fileLevel.backgroundModelSmoke ) )
		fileLevel.backgroundModelSmoke.SetSkin( GetCurrentPlaylistVarInt( "champion_screen_smokeModel_skin_override", CHAMPION_SQAUD_SMOKE_SKIN_INDEX ) )

	fileLevel.lightEntsExist = DoMenuLightsExist()
	if ( fileLevel.lightEntsExist && IsValid( fileLevel.lightRigModel ) )
	{
		fileLevel.keyLight.SetTweakLightColor( < 0.5, 0.5, 0.5 > )
		fileLevel.keyLight.SetTweakLightBrightness( 4.0 )
		fileLevel.keyLight.SetTweakLightCone( 18.0 )
		fileLevel.keyLight.SetTweakLightInnerCone ( 15.0 )
		fileLevel.keyLight.SetTweakLightDistance( 1800.0 )
		fileLevel.keyLight.SetTweakLightHalfBrightFrac( 0.3 )
		fileLevel.keyLight.SetTweakLightSpecIntensity( 1.0 )
		fileLevel.keyLight.SetTweakLightPBRFalloff( false )
		fileLevel.keyLight.SetTweakLightRealtimeShadows( true )
		fileLevel.fillLight.SetTweakLightColor( < 0.2, 0.2, 0.2 > )
		fileLevel.fillLight.SetTweakLightBrightness( 0.4 )
		fileLevel.fillLight.SetTweakLightCone( 15.0 )
		fileLevel.fillLight.SetTweakLightInnerCone ( 12.0 )
		fileLevel.fillLight.SetTweakLightDistance( 800.0 )
		fileLevel.fillLight.SetTweakLightHalfBrightFrac( 0 )
		fileLevel.fillLight.SetTweakLightSpecIntensity( 1.0 )
		fileLevel.fillLight.SetTweakLightPBRFalloff( false )
		fileLevel.fillLight.SetTweakLightRealtimeShadows( true )
		fileLevel.rimLightL.SetTweakLightColor( < 0.75, 0.75, 0.75 > )
		fileLevel.rimLightL.SetTweakLightBrightness( 4.0 )
		fileLevel.rimLightL.SetTweakLightCone( 24.0 )
		fileLevel.rimLightL.SetTweakLightInnerCone ( 20.0 )
		fileLevel.rimLightL.SetTweakLightDistance( 800.0 )
		fileLevel.rimLightL.SetTweakLightHalfBrightFrac( 0 )
		fileLevel.rimLightL.SetTweakLightSpecIntensity( 1.0 )
		fileLevel.rimLightL.SetTweakLightPBRFalloff( false )
		fileLevel.rimLightL.SetTweakLightRealtimeShadows( true )
		fileLevel.rimLightR.SetTweakLightColor( < 0.6, 0.6, 0.6 > )
		fileLevel.rimLightR.SetTweakLightBrightness( 4.0 )
		fileLevel.rimLightR.SetTweakLightCone( 24.0 )
		fileLevel.rimLightR.SetTweakLightInnerCone ( 20.0 )
		fileLevel.rimLightR.SetTweakLightDistance( 800.0 )
		fileLevel.rimLightR.SetTweakLightHalfBrightFrac( 0 )
		fileLevel.rimLightR.SetTweakLightSpecIntensity( 2.0 )
		fileLevel.rimLightR.SetTweakLightPBRFalloff( false )
		fileLevel.rimLightR.SetTweakLightRealtimeShadows( true )

		           
		fileLevel.lightRigModel.Anim_Play( $"animseq/humans/class/char_select_light_default.rseq" )
		int attachIdx_fill = fileLevel.lightRigModel.LookupAttachment( "LIGHT_1" )
		int attachIdx_rimL = fileLevel.lightRigModel.LookupAttachment( "LIGHT_2" )
		int attachIdx_rimR = fileLevel.lightRigModel.LookupAttachment( "LIGHT_3" )
		int attachIdx_key = fileLevel.lightRigModel.LookupAttachment( "LIGHT_4" )

		fileLevel.fillLight.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_fill ) )
		fileLevel.fillLight.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_fill ) )

		fileLevel.rimLightL.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_rimL ) )
		fileLevel.rimLightL.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_rimL ) )

		fileLevel.rimLightR.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_rimR ) )
		fileLevel.rimLightR.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_rimR ) )

		fileLevel.keyLight.SetTweakLightOrigin( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_key ) )
		fileLevel.keyLight.SetTweakLightAngles( fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_key ) )
	}
	else
	{
		printt( "Map doesn't have menu lights compiled in. Make sure the latest menu box instance is in the level and recompile the map." )
	}
}
#endif


#if SERVER
                                                                           
 
	                                                         
	                                            
		                                                        

	                                        
	 
		                                                                                        
			             
	 

	           
 
#endif

bool function SquadMuteLegendSelectEnabled()
{
	return GetCurrentPlaylistVarBool( "squad_mute_legend_select_enable", true )
}

#if CLIENT && DEV
void function Dev_CharacterSelectClearCamera()
{
	vector nodeOrigin = fileLevel.characterNode.GetOrigin() + fileLevel.characterNode.GetForwardVector() * 128 + <0,0,64>
	vector nodeAngles = VectorToAngles( fileLevel.characterNode.GetForwardVector() * -1 )

	                          
	RunUIScript( "UI_CloseCharacterSelect" )
	GetLocalClientPlayer().ClearMenuCameraEntity()

	                       
	foreach( var rui in fileLevel.ruiPlayerBarRuis )
		RuiDestroyIfAlive( rui )
	fileLevel.ruiPlayerBarRuis = []

	             
	GetLocalClientPlayer().ClientCommand( "setpos " + nodeOrigin.x + " " + nodeOrigin.y + " " + nodeOrigin.z + ";setang " + nodeAngles.x + " " + nodeAngles.y + " " + nodeAngles.z)

	                             
	int attachIdx_fill = fileLevel.lightRigModel.LookupAttachment( "LIGHT_1" )
	int attachIdx_rimL = fileLevel.lightRigModel.LookupAttachment( "LIGHT_2" )
	int attachIdx_rimR = fileLevel.lightRigModel.LookupAttachment( "LIGHT_3" )
	int attachIdx_key = fileLevel.lightRigModel.LookupAttachment( "LIGHT_4" )
	DebugDrawAngles( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_fill ), fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_fill ), 15.0 )
	DebugDrawAngles( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_rimL ), fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_rimL ), 15.0 )
	DebugDrawAngles( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_rimR ), fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_rimR ), 15.0 )
	DebugDrawAngles( fileLevel.lightRigModel.GetAttachmentOrigin( attachIdx_key ), fileLevel.lightRigModel.GetAttachmentAngles( attachIdx_key  ), 15.0 )
}

void function Dev_CharacterSelectRefreshLighting()
{
	if( fileLevel.desiredCharacterOrNull != null )
		thread Dev_CharacterSelectRefreshLighting_Thread()
}


void function Dev_CharacterSelectRefreshLighting_Thread()
{
	ItemFlavor character = expect ItemFlavor( fileLevel.desiredCharacterOrNull )
	ItemFlavor ornull characterSkinOverride = fileLevel.desiredSkinOrNull

	entity ornull pickingPlayer = GetTeammateForPickingIndex( GetGlobalNetInt( CHARACTER_SELECT_NETVAR_LOCK_STEP_INDEX ) )
	if ( fileLevel.isBrowseMode )                                               
		pickingPlayer = GetLocalClientPlayer()
	if ( pickingPlayer == null )
		return                                                               

	expect entity( pickingPlayer )

	ItemFlavor characterSkin = GetCharacterSkinForPlayerSelection( ToEHI( pickingPlayer ), character, characterSkinOverride )

	TryUpdateLightingRig( character, characterSkin )
}
#endif

#if CLIENT
void function TestBGupdate( int skin )
{
	fileLevel.backgroundModelGeo.Destroy()
}
#endif