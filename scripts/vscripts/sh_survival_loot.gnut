global function SURVIVAL_Loot_InitShared

global function SURVIVAL_Loot_GetAllLoot

global function CodeCallback_WeaponModCommandCheckMods

global function Survival_PickupItem
global function SURVIVAL_Loot_GetGeneralTypeString
global function SURVIVAL_Loot_GetDetailTypeString
global function SURVIVAL_Loot_GetDetailType2String
global function SURVIVAL_Loot_GetHealthPickupTypeFromRef
global function SURVIVAL_Loot_GetHealthPickupRefFromType
global function SURVIVAL_Loot_GetHealthKitDataFromStruct
global function SURVIVAL_Loot_GetHealthPickupCategoryFromData
global function SURVIVAL_Loot_GetTotalHealthItems
global function SURVIVAL_Loot_RegisterConditionalCheck
global function SURVIVAL_Loot_RunConditionalCheck
global function IsAmmoInUse
global function SetPlayerRequireLootType
global function SURVIVAL_HasSpecificItemInInventory
global function SurvivalBasicUsable_CanUseFunction
global function DeathBox_ShouldUseBlockReload

global function SURVIVAL_CountSquaresInInventory
global function SURVIVAL_CountItemsInInventory
global function SURVIVAL_CountItemsTypesInInventory

global function GetCategoryTitleFromPriority
global function SortByPriorityThenTier
global function GetPriorityForLootType
global function GetCommsActionEnumForName
global function GetWeaponClassNameWithLockedSet
global function WeaponLootRefIsLockedSet

global function SURVIVAL_GetActiveWeapon
global function SURVIVAL_GetLastActiveWeapon
global function SURVIVAL_GetActiveWeaponSlot
global function SURVIVAL_GetPrimaryWeaponRefs
global function SURVIVAL_GetWeaponBySlot
global function SURVIVAL_GetWeaponAttachmentForPoint
global function SURVIVAL_AddToInventory
global function SURVIVAL_AddToPlayerInventory
global function SURVIVAL_RemoveFromInventory
global function SURVIVAL_RemoveFromPlayerInventory
global function SURVIVAL_GetPlayerInventory
global function SURVIVAL_CountPrimaryWeapons

global function GetAttachPointsForAttachment
global function GetAttachPointForAttachmentOnWeapon
global function CanAttachmentEquipToAttachPoint
global function CanAttachmentEquipToOneOfAttachPoints
global function IsAttachmentAmbiguousForWeapon
global function IsModTypeSight
global function GetWeaponAmmoType
global function IsAttachmentAnUpgrade
global function GetOtherWeapon

global function SURVIVAL_GetActionForGroundItem
global function SURVIVAL_GetActionForEquipment
global function SURVIVAL_GetAltActionForEquipment
global function SURVIVAL_GetActionForBackpackItem
global function SURVIVAL_GetAltActionForBackpackItem
global function SURVIVAL_GetActionForAttachment
global function SURVIVAL_CreateLootRef
global function SURVIVAL_CreateLootRefFromLootEnt
global function SURVIVAL_GetPlayerShieldHealthFromArmor
global function SURVIVAL_GetArmorShieldCapacity
global function SURVIVAL_GetCharacterShieldHealthMaxForArmor
global function SURVIVAL_EquipmentPretendsToBeBlank

global function EvolvingArmor_GetEvolvingArmorHealthForTier
global function EvolvingArmor_IsEquipmentEvolvingArmor
global function EvolvingArmor_GetRequirementForEvolution
global function EvolvingArmor_GetEvolutionProgress
global function EvolvingArmor_ExceedsMaxIntLimit

#if CLIENT
global function ServerCallback_PlayFPEvoShieldUpgradeFX
global function ServerCallback_Play3PEvoShieldUpgradeFX
global function ServerCallback_SetLockedSet
#endif          

#if SERVER
                                               
                                            
                                                  
                                                       
                                            
                                              
#endif         

global const string NV_EVOLVING_ARMOR_KILL_COUNT = "playerEvolvingArmorKillCount"

global const string CMDNAME_PLAYER_SWITCHED_WEAPONS = "ClientCallback_PlayerSwitchedWeapons"

global function SURVIVAL_IsLootIrrelevant
global function SURVIVAL_IsLootAnUpgrade
global function SURVIVAL_GetActionForItem
global function SURVIVAL_GetInventorySlotCountForPlayer

global function GetAllDeathBoxes
global function ShouldPickupDNAFromDeathBox
global function DestroyAllDeathBoxes

#if CLIENT
global function SURVIVAL_BuildStringForAction
global function SURVIVAL_UpdateStringForEquipmentAction
#endif

#if SERVER
                                  
                                                       
                                                              
                                     
                                               
                                                 
                                                                  
                                                                 
                                                  
                                                  
                                                    
       
                                        
                                                 
                                                                
                                                                     
      
#endif

global function SURVIVAL_GetRefFromProp
global function SURVIVAL_CanDismantleMods
global function SURVIVAL_CanReplaceWeapon
global function SURVIVAL_GetModToRemoveForAttachment
global function AmmoType_GetRefFromIndex
global function WeaponType_GetRefFromIndex
global function AmmoType_GetTypeFromRef
global function SURVIVAL_GetTitanWeaponStoreCount
global function SURVIVAL_IsKnownLootItem
global function SURVIVAL_GetPrimaryWeapons
global function SURVIVAL_GetPrimaryWeaponsSorted
global function SURVIVAL_CanQuickAttach
global function SURVIVAL_CanQuickAttachWithMod
global function SURVIVAL_CanAddModToWeapon
global function GetInstalledWeaponAttachmentForPoint
global function GetAllWeaponAttachments

global function SURVIVAL_GetAllPlayerOrdnance
global function SURVIVAL_PlayerCanUse_AnimatedInteraction
global function SURVIVAL_CanPlayerPickup
global function SURVIVAL_PlayerAllowedToPickup
global function PlayerCommonItemPickupCheck
global function SURVIVAL_PlayerCanSwitchOrdnance
global function SURVIVAL_IsPlayerCarryingLoot
global function SURVIVAL_GetHighlightForTier
global function SURVIVAL_Loot_UpdateHighlightForLoot
global function SURVIVAL_GetBestHealthPickupType
global function SURVIVAL_GetPotentialAppliedHealing
global function SURVIVAL_CreateKitHealData
global function GetCompatibleAttachmentsFromInventory
global function GetCompatibleAttachmentsFromWeapon
global function GetCompatibleAttachmentMap

global function SURVIVAL_GetMaxInventoryLimit
global function SURVIVAL_GetInventoryLimit
global function SURVIVAL_GetInventoryCount
global function SURVIVAL_GetCountToFillStack
global function GetStringForTagId

global function Inventory_RegisterNetworking
global function SURVIVAL_SetShieldHealthMaxOverrideCallback

#if SERVER
                                   
                                 
#elseif CLIENT
global function AddCallback_LocalPlayerPickedUpLoot
global function ServerToClient_PickedupItem
global function ServerCallback_DroppedItem
global function ServerCallback_AttachedMod
#endif

#if SERVER
                                            
                                            
                                                   
#endif          

#if CLIENT
global function SURVIVAL_UpdateIcons
#endif

global function SortByLootTier
global function SortInventoryByLootTier

global function GetAttachmentsWithToggleModsList
global function GetToggleModsRequiredAttachmentsList
global function VerifyToggleMods
global function ApplyDefaultToggledMods
global function ReplaceOpticInMods
global function GetAltModsToRemoveOnCleanup
global function CleanupAltMods

global function SURVIVAL_GetLootDataFromWeapon
global function SURVIVAL_Weapon_IsAttachmentLocked
global function SURVIVAL_IsAttachmentPointLocked
global function SURVIVAL_Weapon_IsFullyKitted
global function SURVIVAL_Weapon_GetBaseMods

global function SURVIVAL_GetStowedWeaponSlot

global function IsValidAttachment
global function GetAttachmentData

global function PropSurvivalFlagsHas
global function GetPropSurvivalMainProperty
global function GetPropSurvivalExtraProperty
global function GetPropSurvivalMainPropertyFromEnt
global function GetPropSurvivalExtraPropertyFromEnt
#if SERVER
                                       
                                    
                                      
                                           
                                            
                                                
                                                 
#endif

#if SERVER
                                                                                                                                                                    
#endif

#if SERVER || CLIENT
global function IsValidAndUsableDeathBoxEnt
global function IsLootEntAccessibleViaDeathBox
#endif

#if SERVER || CLIENT
global function GetDeathBoxLootEnts
global function IsValidAndStandardGrabbableLootEnt
global function IsLootEntInsideDeathBox
global function DoesDeathBoxSupportAddingLoot
global function ShouldUseAltInteractForArmorSwap
global function GetDeathboxArmorSwap
#endif

global function GetFadeDistForLoot

#if DEV && CLIENT
global function DEV_PrintAllLootRefsWithNames
#endif

  
global const string WEAPON_LOCKEDSET_SUFFIX_GOLD = "_gold"
global const string WEAPON_LOCKEDSET_MOD_GOLD = "gold"

global const string WEAPON_LOCKEDSET_SUFFIX_WHITESET = "_whiteset"
global const string WEAPON_LOCKEDSET_MOD_WHITESET = "whiteset"

global const string WEAPON_LOCKEDSET_SUFFIX_BLUESET = "_blueset"
global const string WEAPON_LOCKEDSET_MOD_BLUESET = "blueset"

global const string WEAPON_LOCKEDSET_SUFFIX_PURPLESET = "_purpleset"
global const string WEAPON_LOCKEDSET_MOD_PURPLESET = "purpleset"

global const string WEAPON_LOCKEDSET_SUFFIX_GOLDPAINTBALL = "_gold_paintball"
global const string WEAPON_LOCKEDSET_MOD_GOLDPAINTBALL = "gold_paintball"

global const string WEAPON_LOCKEDSET_SUFFIX_PURPLEPAINTBALL = "_purple_paintball"
global const string WEAPON_LOCKEDSET_MOD_PURPLEPAINTBALL = "purple_paintball"

global const string WEAPON_LOCKEDSET_SUFFIX_BLUEPAINTBALL = "_blue_paintball"
global const string WEAPON_LOCKEDSET_MOD_BLUEPAINTBALL = "blue_paintball"

                                
                                                                       
                                                                         
      

global const string WEAPON_LOCKEDSET_MOD_CRATE = "crate"

global const string WEAPON_SUFFIX_NONCOMBAT = "_noncombat"

global const bool REMOVE_KITTED_WEAPONS_FROM_SPAWNING = true

const string SFX_BACKPACK_FULL = "UI_Survival_BackPackFull"
const string SFX_CANNOT_USE = "UI_Survival_LootPickupDeny"

global const int MIN_LOOT_TIER = 0
global const int MAX_LOOT_TIER = 5
global const int NUM_LOOT_TIERS = MAX_LOOT_TIER - MIN_LOOT_TIER + 1

const float LOOKING_AT_LINE_CHECK_IGNORE_DIST = 100.0

global const float SURVIVAL_PICKUP_ALL_MAX_RANGE = 150.0
global const float SURVIVAL_GROUNDLIST_NEARBY_RADIUS = 1500.0

global const bool LOOT_GROUND_VERTICAL_LINES = true

global const AUTOPICKUP_DISTANCE = 64.0

                       
                                                     
                                                                
                                                                          
      

const int EVOLVING_ARMOR_DAMAGE_TIER1 = 100
const int EVOLVING_ARMOR_DAMAGE_TIER2 = 150
const int EVOLVING_ARMOR_DAMAGE_TIER3 = 300
const int EVOLVING_ARMOR_DAMAGE_TIER4 = 750

const FX_SHIELD_EVO_UPGRADE_FP = $"P_armor_evo_upgrade_FP"
global const FX_SHIELD_EVO_UPGRADE_3P = $"P_armor_evo_upgrade"

                  
                                                       
      

global const FX_AIRDROP_BEAM_CP = $"P_ar_loot_drop_point_far_cp"
global const FX_AIRDROP_GROUND_MARKER_DEFAULT_CP = $"P_ar_loot_drop_point_cp"
global const FX_AIRDROP_GROUND_MARKER_CRAFTING_CP = $"P_ar_loot_drop_point_cp"

#if LOOT_GROUND_VERTICAL_LINES
global const float VERTICAL_LINE_WIDTH = 48
global const float VERTICAL_LINE_HEIGHT = 56
global const float VERTICAL_LINE_COUNT = 8
global const float VERTICAL_LINE_DIST_MAX = SURVIVAL_PICKUP_ALL_MAX_RANGE
#if CLIENT || SERVER
global function SurvivalLoot_PlayerLookingAtLine
#endif
#endif

global enum ePropSurvivalFlag
                                                                          
{
	HIDE_LOOT_LINE = (1 << 0),
}

global enum eLootSortCategories
{
	WEAPONS,
	AMMO,
	SPECIAL,
	PVE,
	EQUIPMENT,
	CONSUMABLES,
	ATTACHMENTS,
	DEFAULT,
}

global enum eLootContext
{
	GROUND
	BACKPACK
	EQUIPMENT

	_count
}


global enum eHealthPickupType
{
	HEALTH_SMALL
	HEALTH_LARGE
	SHIELD_SMALL
	SHIELD_LARGE
	COMBO_FULL
                         
                       
                        
                       
       
	ULTIMATE

	_count

	INVALID = -1
}

global enum eHealthPickupCategory
{
	HEALTH
	SHIELD
	COMBO
	ULTIMATE
}



global const int SURVIVAL_MAX_AMMO_PICKUPS = 2000

global const bool DROP_BOX_ON_DEATH = true
global const asset DEATH_BOX = $"mdl/props/death_box/death_box_01.rmdl"
global const asset DEATH_BOX_FLAT_PLANE = $"mdl/props/death_box/death_box_02.rmdl"
global const float DEATH_BOX_MAX_DIST = 200.0


global struct LootActionStruct
{
	int       action
	LootData& additionalData
	string    displayString = "#REASON_GENERIC"
}

global struct LootRef
{
	entity lootEnt
	int    lootProperty
	int    lootExrtaProperty
	int    count

	LootData& lootData
}

global struct HealthPickup
{
	float               interactionTime
	string              animName1p = "ptpov_mp_healthkit_small"
	float               healAmount
	float               shieldAmount
	float               ultimateAmount
	float               healTime
	table< int, float > healBonus = {
		[ePassives.PAS_SYRINGE_BONUS] = 0.0,
		[ePassives.PAS_HEALTH_BONUS_MED] = 0.0,
		[ePassives.PAS_HEALTH_BONUS_ALL] = 0.0
	}
	float               healCap = 100
	LootData&           lootData
}


global enum eAttachmentTag
{
	PISTOL
	ASSAULT
	SHOTGUN
	LMG
	SNIPER
	SMG
	LAUNCHER
	MARKSMAN
	ALL
	BARREL
}

global const table<string, int> weaponClassToTag = {
	pistol = eAttachmentTag.PISTOL
	assault = eAttachmentTag.ASSAULT
	shotgun = eAttachmentTag.SHOTGUN
	lmg = eAttachmentTag.LMG
	sniper = eAttachmentTag.SNIPER
	smg = eAttachmentTag.SMG
	launcher = eAttachmentTag.LAUNCHER
	marksman = eAttachmentTag.MARKSMAN
}

global struct KitHealData
{
	HealthPickup & healthKit
	int            kitType
	int            count
	int            overHeal
	int            overShield

	int possibleHealthAdd
	int possibleShieldAdd

	float healthPerSecond

	int totalOverheal
	int totalAppliedHeal
}

array<int> healthKitUseOrder = []

global struct AttachmentTagData
{
	string        ammoRef
	array<int>    attachmentTags
	array<string> weaponRefs
	table<int,string> exceptionToTheRuleForThisWeaponClass
}

global struct AttachmentData
{
	string             ref
	array<string>      compatibleWeapons
	array<string>      attachPoints
	AttachmentTagData& tagData
}

struct CachedLootActionData
{
	LootActionStruct& actionStruct
	float             lastUpdateTime
}

struct
{
	table<string, AttachmentData > attachmentMatrix

	array<entity> allLoot

	bool initialized

	bool useAltInteractForArmorSwap

	int evoArmor_ReqDamage_Tier1
	int evoArmor_ReqDamage_Tier2
	int evoArmor_ReqDamage_Tier3
	int evoArmor_ReqDamage_Tier4

	bool evoArmor_SquadPetsEnabled
	bool evoArmor_AiPointsEnabled
	float evoMultiplier_SquadPets
	float evoMultiplier_Prowlers
	float evoMultiplier_Flyers
                    
                              
       
                   
                             
       
                          
		float evoMultiplier_JungleSpiders
       
                       
		float evoMultiplier_Spectres
       
	float evoMultiplier_Armorsmith
	float evoMultiplier_Shadows


	table<string, int> maxAmmoForType

	#if SERVER
		                                                                                     
		                                                                                          
		                                                                                            
		                                                                                                                                                                                                                                                                                                    
		                                                                                              
	#elseif CLIENT
		array<void functionref( entity, LootData, int )> localPlayerPickedupLootCallbacks

		float                                               lastCacheUpdateTime
		table<entity, table<entity, CachedLootActionData> > cachedActionForGroundItemData
		table<entity, table<entity, CachedLootActionData> > cachedActionForGroundItemDataAlt
		array<entity>                                       allDeathBoxes
	#endif          

	table<int, HealthPickup>                                     healthPickups
	table<string, string>                                        attachmentsWithToggleMods
	table< string, array<string> >                               toggleModsRequiredAttachments
	table<string, string>                                        weaponAutoToggledAttachments =
	{
		["mp_weapon_g2"] = "hopup_double_tap",
		["mp_weapon_shotgun"] = "hopup_double_tap",
		["mp_weapon_energy_shotgun"] = "hopup_energy_choke",
		["mp_weapon_doubletake"] = "hopup_energy_choke",
	}
	array<string>                                                altModsToRemoveOnDrop = [ "altfire" ]
	table<string, bool functionref( string, entity ) >           conditionalLootChecks

	table<entity, int> evolvingArmorKillCount
	int                evoShieldUpgradeFXFP
	int                evoShieldUpgradeFX3P
	#if SERVER
		                              
	#endif

	int functionref( entity player, LootData data, int originalMax ) 			shieldHealthMaxOverride = null
} file


int function GetCommsActionEnumForName( string name )
{
	if ( name == "" )
		return eCommsAction.BLANK
	return eCommsAction[name]
}


void function SURVIVAL_Loot_InitShared()
{
	PrecacheModel( DEATH_BOX )
	PrecacheModel( DEATH_BOX_FLAT_PLANE )
	PrecacheModel( $"mdl/props/health_injector/health_injector.rmdl" )

	PrecacheParticleSystem( $"P_survival_cylinder_CP" )
	PrecacheParticleSystem( $"P_ar_titan_droppoint_tall" )
	PrecacheParticleSystem( $"P_ar_loot_drop_point_far" )
	PrecacheParticleSystem( FX_AIRDROP_BEAM_CP )
	PrecacheParticleSystem( $"P_ar_loot_drop_point" )
	PrecacheParticleSystem( FX_AIRDROP_GROUND_MARKER_DEFAULT_CP )
	PrecacheParticleSystem( $"P_ar_hot_zone_far" )

	PrecacheParticleSystem( FX_SHIELD_EVO_UPGRADE_FP )
	PrecacheParticleSystem( FX_SHIELD_EVO_UPGRADE_3P )
	file.evoShieldUpgradeFXFP = GetParticleSystemIndex( FX_SHIELD_EVO_UPGRADE_FP )
	file.evoShieldUpgradeFX3P = GetParticleSystemIndex( FX_SHIELD_EVO_UPGRADE_3P )

	PrecacheModel( $"mdl/props/global_access_panel_button/global_access_panel_button_console_w_stand.rmdl" )

	RegisterSignal( "_SetPlayerInventory" )

	                   
	Remote_RegisterServerFunction( "ClientCallback_PickupAllSurvivalItem", "int", INT_MIN, INT_MAX, "bool" )
	Remote_RegisterServerFunction( "ClientCallback_PickupSurvivalItem", "entity", "int", INT_MIN, INT_MAX, "entity" )
	Remote_RegisterServerFunction( "ClientCallback_PickupSurvivalItem_UI", "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX )
	Remote_RegisterServerFunction( "ClientCallback_AutoPickupFromDeathbox", "entity" )
	Remote_RegisterServerFunction( "ClientCallback_SwapSurvivalItem", "int", INT_MIN, INT_MAX, "entity", "entity" )
	Remote_RegisterServerFunction( "ClientCallback_SwapSurvivalItem_UI", "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX )
	Remote_RegisterServerFunction( "ClientCallback_UseSurvivalItem", "entity" )
	Remote_RegisterServerFunction( "ClientCallback_Sur_SwapToNextOrdnance" )
	Remote_RegisterServerFunction( "ClientCallback_Sur_SwitchToOrdnance", "int", INT_MIN, INT_MAX, "bool" )
	Remote_RegisterServerFunction( "ClientCallback_DeathboxOpened" )
	Remote_RegisterServerFunction( "ClientCallback_BackpackOpened" )
	Remote_RegisterServerFunction( "ClientCallback_BackpackClosed" )
	Remote_RegisterServerFunction( "ClientCallback_Sur_SwapPrimaryPositions" )
	Remote_RegisterServerFunction( "ClientCallback_PickupSurvivalLootFromDeathbox", "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX, "entity", "entity", "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX )
	Remote_RegisterClientFunction( "ServerCallback_SetLockedSet", "entity", "bool", "bool", "bool", "bool" )

                  
                                                                               
                                                                      
                                                                                                      
       

	#if CLIENT
		AddCreateCallback( "prop_survival", OnPropSurvivalCreate )
		AddCreateCallback( "prop_death_box", OnDeathBoxCreated )
		AddDestroyCallback( "prop_death_box", OnDeathBoxDestroyed )
	#elseif SERVER
		                                                                 
		                                                         
		                                                       
	#endif

	#if SERVER
		                                                  
		                                                  
	#endif          

	AddCallback_PlayerClassChanged( OnPlayerClassChanged )

	                                                  
	{
		HealthPickup ultimateBattery
		{
			ultimateBattery.interactionTime = 7.0
			ultimateBattery.ultimateAmount = 20.0
			ultimateBattery.healAmount = 0
			ultimateBattery.healBonus[ ePassives.PAS_SYRINGE_BONUS] <- 0.0
			ultimateBattery.healBonus[ ePassives.PAS_HEALTH_BONUS_MED ] <- 0
			ultimateBattery.healBonus[ ePassives.PAS_HEALTH_BONUS_ALL ] <- 0.0
			ultimateBattery.healTime = 0.0
			ultimateBattery.lootData = SURVIVAL_Loot_GetLootDataByRef( "health_pickup_ultimate" )
		}
		file.healthPickups[ eHealthPickupType.ULTIMATE ] <- ultimateBattery
	}

	{
		HealthPickup healthPickup
		{
			healthPickup.lootData = SURVIVAL_Loot_GetLootDataByRef( "health_pickup_combo_full" )
			healthPickup.interactionTime = 10.0
			healthPickup.healAmount = 100.0
			healthPickup.shieldAmount = 100.0
		}
		file.healthPickups[ eHealthPickupType.COMBO_FULL ] <- healthPickup
	}

	{
		HealthPickup healthPickup
		{
			healthPickup.lootData = SURVIVAL_Loot_GetLootDataByRef( "health_pickup_combo_large" )
			healthPickup.interactionTime = 5.0
			healthPickup.healAmount = 0.0
			healthPickup.shieldAmount = 100.0
			healthPickup.healCap = 0.0
		}
		file.healthPickups[ eHealthPickupType.SHIELD_LARGE ] <- healthPickup
	}
                         
  
                           
   
                                                                                  
                                     
                                
                                    
                             
   
                                                                                
  

  
                           
   
                                                                                  
                                     
                                
                                   
                             
   
                                                                                 
  

  
                           
   
                                                                                  
                                     
                                
                                 
                             
   
                                                                                
  
       
	{
		HealthPickup healthPickup
		{
			healthPickup.lootData = SURVIVAL_Loot_GetLootDataByRef( "health_pickup_combo_small" )
			healthPickup.interactionTime = 3.0
			healthPickup.healAmount = 0.0
			healthPickup.shieldAmount = 25.0
			healthPickup.healCap = 0.0
		}
		file.healthPickups[ eHealthPickupType.SHIELD_SMALL ] <- healthPickup
	}

	{
		HealthPickup healthPickup
		{
			healthPickup.lootData = SURVIVAL_Loot_GetLootDataByRef( "health_pickup_health_large" )
			healthPickup.interactionTime = 8.0
			healthPickup.healAmount = 100.0
			healthPickup.shieldAmount = 0.0
			healthPickup.animName1p = "ptpov_health_injector_long"
		}
		file.healthPickups[ eHealthPickupType.HEALTH_LARGE ] <- healthPickup
	}

	{
		HealthPickup healthPickup
		{
			healthPickup.lootData = SURVIVAL_Loot_GetLootDataByRef( "health_pickup_health_small" )
			healthPickup.interactionTime = 5.0
			healthPickup.healAmount = 25.0
			healthPickup.shieldAmount = 0.0
			healthPickup.healTime = 0.0
			healthPickup.animName1p = "ptpov_health_injector_short"
		}
		file.healthPickups[ eHealthPickupType.HEALTH_SMALL ] <- healthPickup
	}

	healthKitUseOrder.append( eHealthPickupType.SHIELD_LARGE )
                         
                                                                     
                                                                      
                                                                     
       
	healthKitUseOrder.append( eHealthPickupType.SHIELD_SMALL )
	healthKitUseOrder.append( eHealthPickupType.COMBO_FULL )
	healthKitUseOrder.append( eHealthPickupType.HEALTH_LARGE )
	healthKitUseOrder.append( eHealthPickupType.HEALTH_SMALL )

	file.initialized = true

	var attachmentTable = GetDataTable( $"datatable/survival_weapon_mods.rpak" )
	int numRows         = GetDataTableRowCount( attachmentTable )

	for ( int i = 0; i < numRows; i++ )
	{
		string aRef = GetDataTableString( attachmentTable, i, GetDataTableColumnByName( attachmentTable, "mod" ) )

		string toggleMod = GetDataTableString( attachmentTable, i, GetDataTableColumnByName( attachmentTable, "toggleMod" ) )
		if ( toggleMod != "" )
		{
			file.attachmentsWithToggleMods[ aRef ] <- toggleMod
			if ( !(toggleMod in file.toggleModsRequiredAttachments) )
				file.toggleModsRequiredAttachments[ toggleMod ] <- []
			file.toggleModsRequiredAttachments[ toggleMod ].append( aRef )
		}
	}

	                             
	                  
	                             
	var attachmentMatrix = GetDataTable( $"datatable/weapon_attachment_matrix.rpak" )
	int amRowCount       = GetDataTableRowCount( attachmentMatrix )

	array<LootData> allWeapons = SURVIVAL_Loot_GetByType( eLootType.MAINWEAPON )

	table< string, array<string> > weaponsByClass
	foreach ( LootData wData in allWeapons )
	{
		if ( !(wData.lootTags[0] in weaponsByClass) )
			weaponsByClass[wData.lootTags[0]] <- []

		if ( WeaponLootRefIsLockedSet( wData.ref ) )
			continue

		if ( wData.supportedAttachments.len() == 0 )
			continue

		if ( SURVIVAL_Loot_IsRefDisabled( wData.ref ) )
			continue

		weaponsByClass[wData.lootTags[0]].append( wData.ref )
	}

	for ( int i = 0; i < amRowCount; i++ )
	{
		string attachmentName = GetDataTableString( attachmentMatrix, i, GetDataTableColumnByName( attachmentMatrix, "attachmentName" ) )

		AttachmentData aData
		aData.ref = attachmentName
		aData.attachPoints = split( GetDataTableString( attachmentMatrix, i, GetDataTableColumnByName( attachmentMatrix, "attachmentPoint" ) ), WHITESPACE_CHARACTERS )

		if ( SURVIVAL_Loot_IsRefValid( aData.ref ) && !SURVIVAL_Loot_IsRefDisabled( aData.ref ) )
		{
			foreach ( data in allWeapons )
			{
				if ( aData.compatibleWeapons.contains( data.baseWeapon ) )
					continue

				Assert( !IsAttachmentAmbiguousForWeapon( aData.ref, data.ref, aData.attachPoints ) )

				int col = GetDataTableColumnByName( attachmentMatrix, data.baseWeapon )

				if ( col != -1 )
				{
					bool attachmentIsEnabled = GetDataTableBool( attachmentMatrix, i, col )

					foreach ( string attachPoint in aData.attachPoints )
					{
						if ( attachmentIsEnabled && data.supportedAttachments.contains( attachPoint ) )
						{
							aData.compatibleWeapons.append( data.baseWeapon )
						}
					}
				}
			}
		}

		file.attachmentMatrix[ attachmentName ] <- aData
	}

	bool debugAttachments = false

	foreach ( aData in file.attachmentMatrix )
	{
		foreach ( string attachPoint in aData.attachPoints )
		{
			if ( attachPoint == "barrel" )                 
			{
				aData.tagData.attachmentTags.append( eAttachmentTag.BARREL )
			}
			else if ( attachPoint == "mag" )                  
			{
				foreach ( weaponClass, weaponList in weaponsByClass )
				{
					foreach ( weaponRef in weaponList )
					{
						if ( aData.compatibleWeapons.contains( weaponRef ) )
						{
							LootData weaponData = SURVIVAL_Loot_GetLootDataByRef( weaponRef )
							aData.tagData.ammoRef = weaponData.ammoType
						}
					}
				}
			}
			else
			{
				array<int> attachmentTags       = []
				array<string> attachmentUniques = []

				foreach ( weaponClass, weaponList in weaponsByClass )
				{
					array<string> attachableWeapons = []
					string incompatibleWeapon = ""
					foreach ( weaponRef in weaponList )
					{
						if ( !aData.compatibleWeapons.contains( weaponRef ) )
						{
							if ( debugAttachments )
								printt( format( "Attachment %s: NOT compatible with weaponRef %s", aData.ref, weaponRef ) )

							incompatibleWeapon = weaponRef
						}
						else
						{
							if ( debugAttachments )
								printt( format( "Attachment %s: appending weaponRef %s", aData.ref, weaponRef ) )

							attachableWeapons.append( weaponRef )
						}
					}

					if ( attachableWeapons.len() == weaponList.len() && weaponList.len() != 0 )
					{
						if ( debugAttachments )
							printt( format( "Attachment %s: appending weaponClass %s", aData.ref, string(weaponClassToTag[weaponClass] ) ) )

						attachmentTags.append( weaponClassToTag[weaponClass] )
					}
					else if ( attachableWeapons.len() == weaponList.len() - 1 && weaponList.len() != 0 )
					{
						if ( debugAttachments )
							printt( format( "Attachment %s: exception to the rule for weaponClass %s is weapon %s", aData.ref, string(weaponClassToTag[weaponClass] ), incompatibleWeapon ) )

						attachmentTags.append( weaponClassToTag[weaponClass] )
						array<string> baseMods = SURVIVAL_Weapon_GetBaseMods( incompatibleWeapon )
						if ( !baseMods.contains( "crate" ) )
							aData.tagData.exceptionToTheRuleForThisWeaponClass[ weaponClassToTag[weaponClass] ] <- incompatibleWeapon
					}
					else
					{
						if ( debugAttachments )
							printt( format( "Attachment %s: NOT appending weaponClass %s because it should have %d members to be considered complete", aData.ref, string(weaponClassToTag[weaponClass] ), weaponList.len() ) )

						attachmentUniques.extend( attachableWeapons )
					}
				}

				bool supportsAll = attachmentTags.len() == weaponsByClass.len()

				if ( supportsAll )
					attachmentTags = [eAttachmentTag.ALL]

				aData.tagData.attachmentTags = attachmentTags
				aData.tagData.weaponRefs = attachmentUniques
			}
		}
	}

	int attachRefCol = GetDataTableColumnByName( attachmentMatrix, "attachmentName" )
	Assert( attachRefCol != -1, "Attachment Ref column not found in weapon attachment matrix datatable" )
	foreach ( LootData wData in allWeapons )
	{
		if ( SURVIVAL_Loot_IsRefDisabled( wData.ref ) )
			continue

		int weaponCol = GetDataTableColumnByName( attachmentMatrix, wData.baseWeapon )
		if ( weaponCol == -1 )
			continue

		array< string > attachmentsToDisable
		foreach ( supportedAttachment in wData.supportedAttachments )
		{
			int matchingAttachments = 0
			for ( int i = 0; i < amRowCount; i++ )
			{
				string attachmentRef = GetDataTableString( attachmentMatrix, i, attachRefCol )

				if ( !SURVIVAL_Loot_IsRefValid( attachmentRef) || SURVIVAL_Loot_IsRefDisabled( attachmentRef ) )
					continue

				string attachPoint = GetAttachPointForAttachmentOnWeapon( wData.ref, attachmentRef)

				if ( attachPoint != supportedAttachment )
					continue

				bool attachmentIsEnabled = GetDataTableBool( attachmentMatrix, i, weaponCol )

				if ( attachmentIsEnabled )
					matchingAttachments += 1
			}

			if ( matchingAttachments == 0 )
			{
				attachmentsToDisable.append( supportedAttachment )
			}
		}

		foreach ( attachmentToDisable in attachmentsToDisable )
		{
			wData.supportedAttachments.removebyvalue( attachmentToDisable )
			wData.disabledAttachments.append( attachmentToDisable )
		}
	}

	RegisterNetworkedVariable( NV_EVOLVING_ARMOR_KILL_COUNT, SNDC_PLAYER_EXCLUSIVE, SNVT_UNSIGNED_INT, 0 )

	Remote_RegisterServerFunction( CMDNAME_PLAYER_SWITCHED_WEAPONS, "int", -1, 2 )

	file.useAltInteractForArmorSwap = GetCurrentPlaylistVarBool( "alt_interact_armor_swap", false )

	file.evoArmor_ReqDamage_Tier1  = GetCurrentPlaylistVarInt( "evolving_armor_damage_requirement_tier1", EVOLVING_ARMOR_DAMAGE_TIER1 )
	file.evoArmor_ReqDamage_Tier2  = GetCurrentPlaylistVarInt( "evolving_armor_damage_requirement_tier2", EVOLVING_ARMOR_DAMAGE_TIER2 )
	file.evoArmor_ReqDamage_Tier3  = GetCurrentPlaylistVarInt( "evolving_armor_damage_requirement_tier3", EVOLVING_ARMOR_DAMAGE_TIER3 )
	file.evoArmor_ReqDamage_Tier4  = GetCurrentPlaylistVarInt( "evolving_armor_damage_requirement_tier4", EVOLVING_ARMOR_DAMAGE_TIER4 )
	file.evoArmor_SquadPetsEnabled = GetCurrentPlaylistVarBool( "squad_pets_enabled", false )
	file.evoArmor_AiPointsEnabled  = GetCurrentPlaylistVarBool( "should_ai_reward_evo_pts", true )
	file.evoMultiplier_SquadPets   = GetCurrentPlaylistVarFloat( "squad_pets_evo_multiplier", 0.25 )
	file.evoMultiplier_Prowlers    = GetCurrentPlaylistVarFloat( "ai_prowler_evo_pt_percent", 0.25 )
	file.evoMultiplier_Flyers      = GetCurrentPlaylistVarFloat( "wildlife_ai_flyer_evo_pt_percent", 0.25 )
                    
                                                                                              
       
                   
                                                                                             
       
                          
		file.evoMultiplier_JungleSpiders = GetCurrentPlaylistVarFloat( "ai_spider_jungle_evo_pt_percent", 0.25 )
       
                       
		file.evoMultiplier_Spectres = GetCurrentPlaylistVarFloat( "ai_spectre_evo_pt_percent", 0.25 )
       
                   
                                                                                          
       
                               
		file.evoMultiplier_Shadows = GetCurrentPlaylistVarFloat( "shadow_evo_multiplier", 0.5 )
       
}

#if SERVER
                                                
 
	                               
	                                      
	                                                                  
	 
		                                              
	 

	                                                           
	                                                                  
 

                                                
 
	                                                                 
 
#endif          

void function OnPlayerClassChanged( entity player )
{
	                                                                                           
	ResetPlayerRequireLootTypes( player )
}

                                         
array<entity> function SURVIVAL_Loot_GetAllLoot()
{
	return file.allLoot
}

#if CLIENT
void function ServerCallback_SetLockedSet( entity weapon, bool whiteSet, bool blueSet, bool purpleSet, bool goldSet )
{
	if ( !IsValid( weapon ) )
		return

	if ( whiteSet )
		weapon.w.isWhiteset = true
	else if ( blueSet )
		weapon.w.isBlueset = true
	else if ( purpleSet )
		weapon.w.isPurpleset = true
	else if ( goldSet )
		weapon.w.isGoldset = true

	if ( IsArenaMode() )
		RunUIScript( "ClientToUI_Arenas_RefreshBuyMenu" )
}
#endif

string function GetWeaponClassNameWithLockedSet( entity weapon )
{
	string result = weapon.GetWeaponClassName()

                                 
                                                         
   
                                               
                
   
       

	bool whiteset = weapon.w.isWhiteset
	bool blueset = weapon.w.isBlueset
	bool purpleset = weapon.w.isPurpleset
	bool goldset = weapon.w.isGoldset

	if ( goldset == true )
	{
		result += WEAPON_LOCKEDSET_SUFFIX_GOLD
	}
	else if ( whiteset == true )
	{
		result += WEAPON_LOCKEDSET_SUFFIX_WHITESET
	}
	else if ( blueset == true )
	{
		result += WEAPON_LOCKEDSET_SUFFIX_BLUESET
	}
	else if ( purpleset == true )
	{
		result += WEAPON_LOCKEDSET_SUFFIX_PURPLESET
	}

	if ( weapon.HasMod( WEAPON_LOCKEDSET_MOD_PURPLEPAINTBALL ) )
		result += WEAPON_LOCKEDSET_SUFFIX_PURPLEPAINTBALL
	else if ( weapon.HasMod( WEAPON_LOCKEDSET_MOD_BLUEPAINTBALL ) )
		result += WEAPON_LOCKEDSET_SUFFIX_BLUEPAINTBALL
	else if ( weapon.HasMod( WEAPON_LOCKEDSET_MOD_GOLDPAINTBALL ) )
		result += WEAPON_LOCKEDSET_SUFFIX_GOLDPAINTBALL
	return result
}


bool function WeaponLootRefIsLockedSet( string ref )
{
	if ( ref.find( WEAPON_LOCKEDSET_SUFFIX_GOLD ) >= 0 )
		return true
	if ( ref.find( WEAPON_LOCKEDSET_SUFFIX_WHITESET ) >= 0 )
		return true
	if ( ref.find( WEAPON_LOCKEDSET_SUFFIX_BLUESET ) >= 0 )
		return true
	if ( ref.find( WEAPON_LOCKEDSET_SUFFIX_PURPLESET ) >= 0 )
		return true
	if ( ref.find( WEAPON_LOCKEDSET_SUFFIX_PURPLEPAINTBALL ) >= 0 )
		return true
	if ( ref.find( WEAPON_LOCKEDSET_SUFFIX_BLUEPAINTBALL ) >= 0 )
		return true

                                 
                                                            
              
       
	return false
}


bool function CodeCallback_WeaponModCommandCheckMods( entity player, entity weapon, string mod, bool isAdd )
{
	array<string> alwaysAllowedMods = [
		"akimbo",
		"vertical_firestar",
		"double_link_mod",
		"altfire_selectfire",
		"altfire",
                        
			"altfire_highcal",
        
                    
			"altfire_double_tap",
        
                          
                             
        
                   
			"hopup_paintball",
        
                          
                             
        
	]

	if ( mod == "choke" || mod == "kinetic_choke")
		return EnergyChoke_OnWeaponModCommandCheckMods( player, weapon, mod, isAdd )

	if ( alwaysAllowedMods.contains( mod ) )
		return true


	if ( Consumable_IsValidModCommand( player, weapon, mod, isAdd ) )
		return true

                           
                                                                      
             
      

	#if DEV
		if ( GetBugReproNum() == 762 )
			return true
	#endif

	return false
}

#if SERVER
                                                                               
 
	                                                   
		                                                 
	    
		                                                 

	                                    
 

                                                                              
 
	                                                                                                         
	                                                 

	                                                        
	 
		                                   
		                                                   
	 
 

                                                                                                            
 
	                               
	                                                                                 
	 
		                                            
			        

		                                    
			        

		                                              
			        

		                                              
			        

		                                              
			        

		                             
	 

	                 
 

                                                                                    
 
	                               
	                                                                                 
	 
		                                            
			        

		                                    
			        

		                                              
			        

		                                         
			        

		                             
	 

	                 
 
#endif

string function SURVIVAL_Loot_GetDetailType2String( LootData lootData )
{
	switch ( lootData.lootType )
	{
		case eLootType.MAINWEAPON:
			if ( lootData.baseMods.contains( "crate" ) )
				return "#WPN_CATEGORY_CRATE"
			else if ( SURVIVAL_Weapon_IsAttachmentLocked( lootData.ref ) )
				return "#WPN_CATEGORY_FULLY_KITTED"
			break
	}
	return ""
}


string function SURVIVAL_Loot_GetDetailTypeString( LootData lootData )
{
	switch ( lootData.lootType )
	{
		case eLootType.MAINWEAPON:
			return GetStringForTagId( weaponClassToTag[lootData.lootTags[0]] )

		case eLootType.AMMO:
			return ""

		case eLootType.HEALTH:
			int kitType = SURVIVAL_Loot_GetHealthPickupTypeFromRef( lootData.ref )
			HealthPickup pickupInfo = SURVIVAL_Loot_GetHealthKitDataFromStruct( kitType )
			if ( pickupInfo.healAmount > 0 && pickupInfo.shieldAmount > 0 )
				return "#HEAL_TYPE_COMBO"
			else if ( pickupInfo.healAmount > 0 && pickupInfo.healCap > 100 )
				return "#HEAL_TYPE_COMBO"
			else if ( pickupInfo.healAmount > 0 )
					return "#HEAL_TYPE_HEALTH"
				else if ( pickupInfo.shieldAmount > 0 )
						return "#HEAL_TYPE_SHIELD"
					else if ( pickupInfo.ultimateAmount > 0 )
							return "#HEAL_TYPE_ULTIMATE"
			return ""

		case eLootType.ARMOR:
			return "#ITEM_TYPE_DEFENSE"

		case eLootType.INCAPSHIELD:
			return ""

		case eLootType.JUMPKIT:
			return ""

		case eLootType.ORDNANCE:
			if ( lootData.ref == "mp_ability_mobile_respawn_beacon" )
				return "#ITEM_TYPE_SPECIAL"
			return "#ITEM_TYPE_THROWN"

		case eLootType.ATTACHMENT:
			array<string> attachPoints = GetAttachPointsForAttachment( lootData.ref )
			return GetAttachmentPointName( attachPoints[0] )	                                                                                                                                                                        

		case eLootType.BACKPACK:
			return ""

		case eLootType.CUSTOMPICKUP:
			return ""
                       

                            
            
      

		case eLootType.HELMET:
			return "#ITEM_TYPE_DEFENSE"

                      
		case eLootType.DATAKNIFE:
      
                  
		case eLootType.SHIPKEYCARD:
      
			return "#ITEM_TYPE_SPECIAL"

                   

		case eLootType.MARVIN_ARM:
			return ""
      

		case eLootType.RESOURCE:
			return "#ITEM_TYPE_SHIELDS"

		case eLootType.GADGET:
				return "#GADGET_SLOT"

		case eLootType.BLANK:
			return ""
	}

	return ""
}


string function SURVIVAL_Loot_GetGeneralTypeString( LootData data )
{
	switch ( data.lootType )
	{
		case eLootType.MAINWEAPON:
		case eLootType.ORDNANCE:
			if ( data.ref == "mp_ability_mobile_respawn_beacon" )
				return "#SURVIVAL_HEALTH"
			return "#SURVIVAL_WEAPON"

		case eLootType.AMMO:
			return "#SURVIVAL_AMMO"

		case eLootType.HEALTH:
			return "#SURVIVAL_HEALTH"

		case eLootType.ARMOR:
		case eLootType.INCAPSHIELD:
		case eLootType.JUMPKIT:
		case eLootType.BACKPACK:
		case eLootType.HELMET:
		case eLootType.GADGET:
			return "#SURVIVAL_GEAR"

		case eLootType.ATTACHMENT:
			return "#SURVIVAL_ATTACHMENT"

		case eLootType.CUSTOMPICKUP:
			return "#SURVIVAL_SPECIAL"
                       

                            
                
      
                      
		case eLootType.DATAKNIFE:
      
                  
		case eLootType.SHIPKEYCARD:
      
			return "#SURVIVAL_SPECIAL"

                   

		case eLootType.MARVIN_ARM:
			return "#SURVIVAL_SPECIAL"
      

		case eLootType.RESOURCE:
			return "#SURVIVAL_RECOVERY"

		case eLootType.BLANK:
			return ""
	}

	return ""
}


int function SURVIVAL_Loot_GetHealthPickupTypeFromRef( string ref )
{
	foreach ( kitType, healthPickup in file.healthPickups )
	{
		if ( healthPickup.lootData.ref != ref )
			continue

		return kitType
	}

	Assert( 0, "Unknown Health Kit Ref: " + ref )
	return eHealthPickupType.INVALID
}


string function SURVIVAL_Loot_GetHealthPickupRefFromType( int pickupType )
{
	if ( WeaponDrivenConsumablesEnabled() )
		return Consumable_GetConsumableInfo( pickupType ).lootData.ref
	else
		return file.healthPickups[pickupType].lootData.ref

	unreachable
}


HealthPickup function SURVIVAL_Loot_GetHealthKitDataFromStruct( int kitType )
{
	return file.healthPickups[ kitType ]
}


bool function IsModTypeSight( string modName, string weaponName )
{
	return CanAttachmentEquipToAttachPoint( modName, "sight" )
}


int function SURVIVAL_Loot_GetTotalHealthItems( entity player, int checkType = eHealthPickupCategory.COMBO )
{
	int totalItems = 0
	foreach ( kitType, healthPickup in file.healthPickups )
	{
		bool countItem = false
		switch ( checkType )
		{
			case eHealthPickupCategory.COMBO:
				if ( healthPickup.healAmount > 0 && healthPickup.shieldAmount > 0 )
					countItem = true
				else if ( healthPickup.healAmount > 0 && healthPickup.healCap > 100 )
					countItem = true
				break

			case eHealthPickupCategory.SHIELD:
				if ( healthPickup.shieldAmount > 0 )
					countItem = true
				break

			case eHealthPickupCategory.HEALTH:
				if ( healthPickup.healAmount > 0 )
					countItem = true
				break

			case eHealthPickupCategory.ULTIMATE:
				if ( healthPickup.ultimateAmount > 0 )
					countItem = true
				break
		}

		if ( !countItem )
			continue

		totalItems += SURVIVAL_CountItemsInInventory( player, healthPickup.lootData.ref )
	}

	return totalItems
}


int function SURVIVAL_Loot_GetHealthPickupCategoryFromData( HealthPickup pickup )
{
	if ( pickup.ultimateAmount > 0 )
		return eHealthPickupCategory.ULTIMATE

	if ( pickup.healAmount > 0 && pickup.shieldAmount > 0 )
		return eHealthPickupCategory.COMBO

	if ( pickup.healAmount == 0 && pickup.shieldAmount > 0 )
		return eHealthPickupCategory.SHIELD

	if ( pickup.healAmount > 0 && pickup.shieldAmount == 0 )
		return eHealthPickupCategory.HEALTH

	unreachable
}


void function SURVIVAL_Loot_RegisterConditionalCheck( string ref, bool functionref( string, entity ) conditionalCheck )
{
	Assert ( !(ref in file.conditionalLootChecks), "Loot ref already has registered conditional check!" )
	file.conditionalLootChecks[ ref ] <- conditionalCheck
}


bool function SURVIVAL_Loot_RunConditionalCheck( string ref, entity player )
{
	Assert( ref in file.conditionalLootChecks, "Loot ref does not have registered conditional function!" )
	return file.conditionalLootChecks[ ref ]( ref, player )
}


array<string> function GetAttachPointsForAttachment( string attachmentName )
{
	if ( !IsValidAttachment( attachmentName ) )
		Assert( 0, "Attachment " + attachmentName + " not defined in datatable/weapon_attachment_matrix.rpak" )

	AttachmentData aData = GetAttachmentData( attachmentName )
	return aData.attachPoints
}

string function GetAttachPointForAttachmentOnWeapon( string weaponRef, string attachmentName )
{
	Assert( SURVIVAL_Loot_IsRefValid( weaponRef ), "Invalid weapon loot ref: " + weaponRef )

	                                                                                       
	array<string> attachPoints = GetAttachPointsForAttachment( attachmentName )
	LootData weaponData = SURVIVAL_Loot_GetLootDataByRef( weaponRef )
	foreach ( string weaponAttachPoint in weaponData.supportedAttachments )
	{
		if ( attachPoints.contains( weaponAttachPoint ) )
			return weaponAttachPoint
	}

	foreach ( string weaponAttachPoint in weaponData.disabledAttachments )
	{
		if ( attachPoints.contains( weaponAttachPoint ) )
			return weaponAttachPoint
	}

	return ""
}

bool function CanAttachmentEquipToAttachPoint( string attachmentName, string attachPoint )
{
	array<string> attachPointsForAttachment = GetAttachPointsForAttachment( attachmentName )
	return attachPointsForAttachment.contains( attachPoint )
}

bool function CanAttachmentEquipToOneOfAttachPoints( string attachmentName, array<string> attachPoints )
{
	array<string> attachPointsForAttachment = GetAttachPointsForAttachment( attachmentName )

	foreach ( string ap in attachPoints )
	{
		if ( attachPointsForAttachment.contains( ap ) )
			return true
	}
	return false
}

bool function IsAttachmentAmbiguousForWeapon( string attachment, string weaponName, array< string > attachmentPoints )
{
	if ( weaponName == "" )
		return false

	if ( !SURVIVAL_Loot_IsRefValid( weaponName ) )
		return false

	if ( !SURVIVAL_Loot_IsRefValid( attachment ) )
		return false

	LootData weaponData = SURVIVAL_Loot_GetLootDataByRef( weaponName )

	array<string> allAttachPoints = weaponData.supportedAttachments
	array<string> attachPointsForAttachment = attachmentPoints
	bool alreadyFoundValidSlot    = false
	foreach ( string attachPoint in allAttachPoints )
	{
		if ( attachPointsForAttachment.contains( attachPoint ) )
		{
			if ( alreadyFoundValidSlot )
				return true
			alreadyFoundValidSlot = true
		}
	}

	return false
}

#if CLIENT || SERVER
string function GetInstalledWeaponAttachmentForPoint( entity weapon, string attachmentPoint )
{
	array<string> mods = GetWeaponMods( weapon )

	foreach ( attachmentName in mods )
	{
		if ( !SURVIVAL_Loot_IsRefValid( attachmentName ) )
			continue

		if ( CanAttachmentEquipToAttachPoint( attachmentName, attachmentPoint ) )
			return attachmentName
	}

	return ""
}
#endif


string function AmmoType_GetRefFromIndex( int ammoType )
{
	foreach ( ref, type in eAmmoPoolType )
	{
		if ( type == ammoType )
			return ref
	}

	return ""
}


string function WeaponType_GetRefFromIndex( int weaponType )
{
	foreach ( ref, type in eDamageSourceId )
	{
		if ( type == weaponType )
			return ref
	}

	return ""
}


int function AmmoType_GetTypeFromRef( string ammoRef )
{
	return eAmmoPoolType[ ammoRef ]
}


int function SURVIVAL_GetTitanWeaponStoreCount( entity weapon )
{
	if ( weapon.IsChargeWeapon() )
	{
		return int( (1.0 - weapon.GetWeaponChargeFraction()) * 100.0 )
	}

	return weapon.GetWeaponPrimaryClipCount()
}


string function GetWeaponAmmoType( string weaponName )
{
	if ( SURVIVAL_Loot_IsRefValid( weaponName ) )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByRef( weaponName )
		return data.ammoType
	}

	return ""
}


int function SURVIVAL_GetInventoryLimit( entity player )
{
	int limit  = 0
	int bpTier = EquipmentSlot_GetEquipmentTier( player, "backpack" )
	switch ( bpTier )
	{
		case 0:
			limit = SURVIVAL_BACKPACK_LIMIT
			break

		case 1:
			limit = SURVIVAL_BACKPACK_LIMIT_SMALL
			break

		case 2:
			limit = SURVIVAL_BACKPACK_LIMIT_MEDIUM
			break

		case 3:
		case 4:
			limit = SURVIVAL_BACKPACK_LIMIT_MAX
			break

		default:
			Assert( false, "invalid backpack tier " + bpTier )
			break
	}

              
                                                    
                                         
       

	return limit
}


int function SURVIVAL_GetMaxInventoryLimit( entity player )
{
	int limit = SURVIVAL_BACKPACK_LIMIT_MAX
              
                                                    
                                         
       
	return limit
}


int function SURVIVAL_GetInventoryCount( entity player )
{
	return SURVIVAL_GetPlayerInventory( player ).len()
}


int function SURVIVAL_CountSquaresInInventory( entity player, string ref )
{
	LootData data                                  = SURVIVAL_Loot_GetLootDataByRef( ref )
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )
	int count                                      = 0
	foreach ( invItem in playerInventory )
	{
		if ( invItem.type == data.index )
		{
			count += 1
		}
	}

	return count
}


int function SURVIVAL_CountItemsInInventory( entity player, string ref )
{
	LootData data                                  = SURVIVAL_Loot_GetLootDataByRef( ref )
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )
	int count                                      = 0
	foreach ( invItem in playerInventory )
	{
		if ( invItem.type == data.index )
		{
			count += invItem.count
		}
	}

	return count
}


entity function SURVIVAL_GetLastActiveWeapon( entity player )
{
	array<entity> weapons = SURVIVAL_GetPrimaryWeaponsSorted( player )

	entity weapon

	if ( weapons.len() > 0 )
		weapon = weapons[0]

	return weapon
}


string function SURVIVAL_GetActiveWeapon( entity player )
{
	if ( IsValid( player.GetActiveWeapon( eActiveInventorySlot.mainHand ) ) )
		return player.GetActiveWeapon( eActiveInventorySlot.mainHand ).GetWeaponClassName()

	return ""
}


string function SURVIVAL_GetStowedWeapon( entity player )
{
	int activeWeaponSlot = SURVIVAL_GetActiveWeaponSlot( player )
	int stowedWeaponSlot = EquipmentSlot_GetOtherWeaponSlotInt( activeWeaponSlot )

	if ( stowedWeaponSlot == -1 )
		return ""

	                                                  
	return EquipmentSlot_GetEquippedLootDataForSlot( player, "main_weapon" + stowedWeaponSlot ).ref
}


int function SURVIVAL_GetActiveWeaponSlot( entity player )
{
	entity activeWeapon = SURVIVAL_GetLastActiveWeapon( player )

	if ( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 ) == activeWeapon )
		return 0
	else if ( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 ) == activeWeapon )
		return 1

	return -1
}


int function SURVIVAL_GetStowedWeaponSlot( entity player )
{
	int activeWeaponSlot = SURVIVAL_GetActiveWeaponSlot( player )
	return EquipmentSlot_GetOtherWeaponSlotInt( activeWeaponSlot )
}


entity function GetOtherWeapon( entity weapon, entity player )
{
	if ( !IsValid( weapon ) )
		return null

	if ( !IsValid( player ) )
		return null

	int slot      = GetSlotForWeapon( player, weapon )
	int otherSlot = EquipmentSlot_GetOtherWeaponSlotInt( slot )
	if ( otherSlot < 0 )
		return null

	entity otherWeapon = player.GetNormalWeapon( otherSlot )
	if ( !IsValid( otherWeapon ) )
		return null

	return otherWeapon
}


int function SURVIVAL_CountItemsTypesInInventory( entity player, int lootType )
{
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )
	int count                                      = 0
	foreach ( invItem in playerInventory )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByIndex( invItem.type )
		if ( data.lootType == lootType )
		{
			count += 1
		}
	}

	return count
}


array<ConsumableInventoryItem> function ClonePlayerInventory( array<ConsumableInventoryItem> inventory )
{
	array<ConsumableInventoryItem> newInv

	foreach ( item in inventory )
	{
		newInv.append( clone item )
	}

	return newInv
}


array<ConsumableInventoryItem> function SURVIVAL_GetPlayerInventory( entity player )
{
	#if SERVER
		                                       
		 
			                                                                                                
		 
	#endif

	array<ConsumableInventoryItem> playerInventory = player.ConsumableInventory_Get()

	return playerInventory
}


int function SURVIVAL_GetCountToFillStack( entity player, string ref )
{
	LootData data = SURVIVAL_Loot_GetLootDataByRef( ref )
	int type      = data.index

	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )
	int slotCount                                  = SURVIVAL_GetInventorySlotCountForPlayer( player, data )

	foreach ( invItem in playerInventory )
	{
		if ( invItem.type != type )
			continue

		if ( invItem.count == slotCount )
			continue

		int diff = slotCount - invItem.count

		return diff
	}

	return slotCount
}


int function SURVIVAL_AddToInventory( array<ConsumableInventoryItem> inventory, int inventoryLimit, LootData itemLootFlav, int itemCount, int itemSlotCount, bool doSorting )
{
	int numToAdd = itemCount
	int numAdded = 0
	foreach ( invItem in inventory )
	{
		if ( invItem.type != itemLootFlav.index )
			continue

		if ( invItem.count >= itemSlotCount )
			continue

		int diff = itemSlotCount - invItem.count
		int add  = minint( numToAdd, diff )
		invItem.count += add
		numToAdd -= add
		numAdded += add
	}

	while ( numToAdd > 0 && inventory.len() < inventoryLimit )
	{
		ConsumableInventoryItem item
		item.slot = inventory.len()
		item.type = itemLootFlav.index

		int add = minint( numToAdd, itemSlotCount )
		item.count = add
		numToAdd -= add
		numAdded += add

		int insertPoint = inventory.len()
		if ( doSorting )
		{
			for ( int i = 0; i < inventory.len(); i++ )
			{
				int compare = SortByPriorityThenTier( item, inventory[i] )
				if ( compare <= 0 )
				{
					insertPoint = i
					break
				}
			}
		}

		inventory.insert( insertPoint, item )
	}

	return numAdded
}


int function SURVIVAL_AddToPlayerInventory( entity player, string ref, int count = 1, bool reallyAdd = true )
{
	if ( !SURVIVAL_Loot_IsRefValid (ref) )                             
	{
		Warning( "Trying to add non-valid loot to player inventory" )
		return 0                                                                                                                                                     
	}

	PerfStart( PerfIndexServer.AddToInventory )

	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )

	LootData data      = SURVIVAL_Loot_GetLootDataByRef( ref )
	int inventoryLimit = SURVIVAL_GetInventoryLimit( player )
	int itemSlotCount  = SURVIVAL_GetInventorySlotCountForPlayer( player, data )

	                                              
	bool doSorting = SERVER

	int numAdded = SURVIVAL_AddToInventory( playerInventory, inventoryLimit, data, count, itemSlotCount, doSorting )

	#if SERVER
		                
		 
			                                             

			                                        
			 
				                                                                  
				                                                  
				 
					                                                   
						                                                     
				 
			 
		 
	#endif

	PerfEnd( PerfIndexServer.AddToInventory )

	return numAdded
}


void function SURVIVAL_RemoveFromInventory( entity player, array<ConsumableInventoryItem> inventory, LootData itemLootFlav, int itemCount )
{
	int numToRemove = itemCount
	for ( int i = inventory.len() - 1; i >= 0; i-- )
	{
		ConsumableInventoryItem invItem = inventory[i]
		if ( invItem.type == itemLootFlav.index )
		{
			int numToRemoveHere = minint( invItem.count, numToRemove )
			numToRemove -= numToRemoveHere
			invItem.count -= numToRemoveHere

			if ( invItem.count == 0 )
			{
				inventory.remove( i )
			}

			if ( numToRemove == 0 )
				break
		}
	}
	SURVIVAL_ConsolidateInventoryItems( player, inventory )
}


void function SURVIVAL_RemoveFromPlayerInventory( entity player, string ref, int count = 1 )
{
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )

	LootData data = SURVIVAL_Loot_GetLootDataByRef( ref )
	SURVIVAL_RemoveFromInventory( player, playerInventory, data, count )

	#if SERVER
		                                             

		                                        
		 
			                                                                  
			                                                  
			 
				                                                   
					                                                     
			 
		 
	#endif
}


void function SURVIVAL_ConsolidateInventoryItems( entity player, array<ConsumableInventoryItem> inventory )
{
	int INVENTORY_EMPTY = SURVIVAL_Loot_GetLootDataTable().len()

	for ( int i = 0; i < inventory.len() - 1; i++ )
	{
		ConsumableInventoryItem invItem1 = inventory[i]

		if ( invItem1.type == INVENTORY_EMPTY )
			continue

		LootData data = SURVIVAL_Loot_GetLootDataByIndex( invItem1.type )
		int slotCount = SURVIVAL_GetInventorySlotCountForPlayer( player, data )

		if ( slotCount <= invItem1.count || invItem1.count == 0 )
			continue

		for ( int j = i + 1; j < inventory.len(); j++ )
		{
			ConsumableInventoryItem invItem2 = inventory[j]

			if ( invItem1.type == invItem2.type )
			{
				int numToFull = slotCount - invItem1.count
				int numToMove = minint( numToFull, invItem2.count )
				invItem2.count -= numToMove
				invItem1.count += numToMove

				if ( slotCount == invItem1.count )
					break
			}
		}
	}

	for ( int i = inventory.len() - 1; i >= 0; i-- )
	{
		ConsumableInventoryItem invItem = inventory[i]

		if ( invItem.count == 0 )
		{
			inventory.remove( i )
		}
	}
}

void function SURVIVAL_ClearExcessInventoryItems( entity player, array<ConsumableInventoryItem> inventory )
{
	int INVENTORY_EMPTY = SURVIVAL_Loot_GetLootDataTable().len()

	for ( int i = 0; i < inventory.len(); i++ )
	{
		ConsumableInventoryItem item = inventory[i]

		if ( item.type == INVENTORY_EMPTY )
			continue

		LootData data = SURVIVAL_Loot_GetLootDataByIndex( item.type )
		int slotCount = SURVIVAL_GetInventorySlotCountForPlayer( player, data )

		if( item.count > slotCount )
			item.count = slotCount
	}
}

#if CLIENT || SERVER

#if SERVER
                                                                                                 
 
	                                                                                  

	                                          
	 
		                 
	 

	                                                

	                                    
 

                                                  
 
	                                       
	                                          
	                                

	              

	                                          

	                                       
		      

	                                                                                                                  

	                                                 

	                               

	                                                 
		                               
 

                                                                                                                                
 
	                                                                                                                                                     
	                                                    
 

                                                                                                                                       
 
	                                                                                                                                                                       
	                                                      
 
#endif

bool function SURVIVAL_IsKnownLootItem( entity item )
{
	if ( file.allLoot.contains( item ) )
		return true
	return false
}

bool function CanUseStackablePropSurvival( entity player, entity prop )
{
	int index     = prop.GetSurvivalInt()
	LootData data = SURVIVAL_Loot_GetLootDataByIndex( index )
	int lootType  = data.lootType

                    
                                         
  
            
                                                                                                 
    
                                                                                                  
                
    
        
  
      

                       
                                             
  
            
                                                                                 
    
                                                                                                  
                
    
                  
  
                             

	return true
}


void function OnPropSurvivalCreate( entity prop )
{
	int index = prop.GetSurvivalInt()

	if ( index < 0 )
		return

	SURVIVAL_Loot_UpdateHighlightForLoot( prop )

	file.allLoot.append( prop )

                        
            
                                                            
                                                    
    
                             
    
        
                              

	AddCallback_OnUseEntity_ClientServer( prop, OnUseSurvivalPickup )
	SetCallback_CanUseEntityCallback( prop, SurvivalLoot_CanUseFunction )
}

void function SURVIVAL_Loot_UpdateHighlightForLoot( entity prop )
{
	int index = prop.GetSurvivalInt()

	LootData data = SURVIVAL_Loot_GetLootDataByIndex( index )
	string ref    = data.ref
	int lootType  = data.lootType
	#if CLIENT

		int lootTier = data.tier

		string highlight = SURVIVAL_GetHighlightForTier( lootTier )

		switch( lootType )
		{
			case eLootType.MAINWEAPON:
				if ( (lootTier - 1) <= eRarityTier.COMMON )
					highlight = "survival_item_weapon"
				break

			case eLootType.AMMO:
				switch ( ref )
				{
					case "special":
						highlight = "survival_item_ammo_energy"
						break

					case "highcal":
						highlight = "survival_item_ammo_b"
						break

					case "shotgun":
						highlight = "survival_item_ammo_shotgun"
						break

                     

                      
                                                
           
      

					case "sniper":
						highlight = "survival_item_ammo_sniper"
						break

					default:
						highlight = "survival_item_ammo_a"
						break
				}

			case eLootType.ARMOR:
			case eLootType.HELMET:
				break
		}

		if ( prop.e.eyeForQuality_isScanned && PlayerHasPassive( GetLocalViewPlayer(), ePassives.PAS_LOBA_EYE_FOR_QUALITY ) )
		{
			if ( data.tier - 1 == eRarityTier.HEIRLOOM )
				highlight = "survival_item_heirloom_loba"
			else if ( data.tier - 1 == eRarityTier.LEGENDARY )
				highlight = "survival_item_legendary_loba"
			else if ( data.tier - 1 == eRarityTier.EPIC )
				highlight = "survival_item_epic_loba"
		}

                   
                                                                                                                                                           
   
                                               
                                             
                                                     
                                              
                                                
                                         
                                                
                                            
                                                  
                                              
   
        

		SetSurvivalPropHighlight( prop, highlight, prop.e.isSelected )
		ManageHighlightEntity( prop )
	#endif          


                        
            
                                               
    
                                           
    
        
                              

}

KitHealData function SURVIVAL_CreateKitHealData( entity player, int kitType )
{
	KitHealData healData
	healData.kitType = kitType
	healData.count = SURVIVAL_CountItemsInInventory( player, SURVIVAL_Loot_GetHealthPickupRefFromType( kitType ) )

	int missingHealth  = player.GetMaxHealth() - player.GetHealth()
	int missingShields = player.GetShieldHealthMax() - player.GetShieldHealth()

	HealthPickup kit = SURVIVAL_Loot_GetHealthKitDataFromStruct( kitType )
	healData.healthKit = clone kit

	int appliedHeal = minint( missingHealth, int( kit.healAmount ) )
	healData.overHeal = maxint( int( kit.healAmount - missingHealth ), 0 )

	int appliedShields = minint( int( kit.shieldAmount ), missingShields )
	healData.overShield = maxint( int( kit.shieldAmount ) - missingShields, 0 )

	healData.totalAppliedHeal = appliedHeal + appliedShields
	healData.totalOverheal = (healData.overHeal + healData.overShield)

	healData.healthPerSecond = healData.totalAppliedHeal / kit.interactionTime

	healData.possibleHealthAdd = int( kit.healAmount )
	healData.possibleShieldAdd = minint( int( kit.shieldAmount ), player.GetShieldHealthMax() )

	return healData
}


int function CompareHealData( KitHealData a, KitHealData b )
{
	if ( a.totalAppliedHeal < 75 && a.totalOverheal > 75 && a.totalOverheal > b.totalOverheal )
		return 1
	else if ( b.totalAppliedHeal < 75 && b.totalOverheal > 75 && b.totalOverheal > a.totalOverheal )
		return -1

	                                                
	  	         
	                                                     
	  	        

	if ( a.totalAppliedHeal > 0 && b.totalAppliedHeal == 0 )
		return -1
	else if ( b.totalAppliedHeal > 0 && a.totalAppliedHeal == 0 )
		return 1

	if ( !a.possibleShieldAdd && !b.possibleShieldAdd )
	{
		if ( a.possibleHealthAdd > b.possibleHealthAdd )
			return -1
		else if ( b.possibleHealthAdd > a.possibleHealthAdd )
			return 1
	}

	if ( a.healthKit.interactionTime < b.healthKit.interactionTime )
		return -1
	else if ( a.healthKit.interactionTime > b.healthKit.interactionTime )
		return 1

	return 0
}


int function SURVIVAL_GetBestHealthPickupType( entity player, bool checkCount = true )
{
	array<KitHealData> healthDataArray
	foreach ( int kitType in healthKitUseOrder )
	{
		KitHealData healData = SURVIVAL_CreateKitHealData( player, kitType )
		healthDataArray.append( healData )
	}

	healthDataArray.sort( CompareHealData )

	foreach ( KitHealData healData in healthDataArray )
	{
		#if CLIENT
			printt( Localize( healData.healthKit.lootData.pickupString ), healData.totalAppliedHeal, healData.healthPerSecond )
		#endif
	}

	if ( checkCount )
	{
		foreach ( KitHealData healData in healthDataArray )
		{
			if ( healData.count > 0 )
				return healData.kitType
		}
	}

	return healthDataArray[0].kitType
}


int function SURVIVAL_GetPotentialAppliedHealing( entity player, int kitType )
{
	KitHealData healData = SURVIVAL_CreateKitHealData( player, kitType )
	return healData.totalAppliedHeal
}


string function SURVIVAL_GetHighlightForTier( int tier, bool longerHighlightDist = false )
{
	string result
	switch( tier )
	{
		case 1:
			result = "survival_item_common"
			break

		case 2:
			result = "survival_item_rare"
			break

		case 3:
			result = "survival_item_epic"
			break

		case 4:
			result = "survival_item_legendary"
			break

		case 5:
			result = "survival_item_heirloom"
			break

		default:
			result = "survival_item_common"
			break

	}

	if ( longerHighlightDist )
		result += "_longerHighlightDist"

	return result
}

array<entity> function GetPrimaryWeapons_( entity player, bool doSorted )
{
	array<entity> results

	entity latestMain = player.GetLatestPrimaryWeaponForIndexZeroOrOne( eActiveInventorySlot.mainHand )
	const int[2] PRIMARY_SLOTS_TO_CHECK = [WEAPON_INVENTORY_SLOT_PRIMARY_0, WEAPON_INVENTORY_SLOT_PRIMARY_1]
	foreach ( int slot in PRIMARY_SLOTS_TO_CHECK )
	{
		entity weapon = player.GetNormalWeapon( slot )
		if ( !IsValid( weapon ) )
			continue
		Assert( SURVIVAL_Loot_IsRefValid( weapon.GetWeaponClassName() ), format( "Weapon '%s' is in primary slot #%d, but is not a valid loot ref.", weapon.GetWeaponClassName(), slot ) )

		if ( doSorted && (weapon == latestMain) )
			results.insert( 0, weapon )
		else
			results.append( weapon )
	}

	return results
}
array<entity> function SURVIVAL_GetPrimaryWeapons( entity player )
{
	return GetPrimaryWeapons_( player, false )
}
array<entity> function SURVIVAL_GetPrimaryWeaponsSorted( entity player )
{
	return GetPrimaryWeapons_( player, true )
}

bool function SURVIVAL_CanReplaceWeapon( entity player, entity prop )
{
	int numWeapons = SURVIVAL_CountPrimaryWeapons( player )

	entity weapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
	if ( !IsValid( weapon ) )
		return false

	                                                                           

	                                                
	  	            

	return numWeapons > 0
}


bool function SURVIVAL_CanDismantleMods( entity player, entity prop )
{
	array<string> installedMods = GetValidLootModsInstalled( prop )
	                                                   
	                             
	  	                                      

	return installedMods.len() > 0
}


bool function SURVIVAL_CanQuickAttach( entity player, entity prop )
{
	array<entity> weapons = SURVIVAL_GetPrimaryWeaponsSorted( player )

	foreach ( weapon in weapons )
	{
		if ( SURVIVAL_CanQuickAttachWithMod( player, weapon, prop ) )
			return true
	}

	return false
}


bool function SURVIVAL_CanQuickAttachWithMod( entity player, entity weapon, entity prop, string modToRemove = "autodetect" )
{
	string item

	#if SERVER
		                     
	#elseif CLIENT
		item = SURVIVAL_Loot_GetLootDataByIndex( prop.GetSurvivalInt() ).ref
	#endif

	string mtr
	if ( modToRemove == "autodetect" )
		mtr = SURVIVAL_GetModToRemoveForAttachment( player, weapon, SURVIVAL_GetRefFromProp( prop ) )
	else
		mtr = modToRemove

	return SURVIVAL_CanAddModToWeapon( player, weapon, item, mtr )
}


string function SURVIVAL_GetRefFromProp( entity prop )
{
	string ref

	int idx = prop.GetSurvivalInt()

	if ( !SURVIVAL_Loot_IsLootIndexValid( idx ) )
		return ""

	ref = SURVIVAL_Loot_GetLootDataByIndex( idx ).ref

	return ref
}


string function SURVIVAL_GetModToRemoveForAttachment( entity player, entity weapon, string attachmentRef )
{
	if ( !SURVIVAL_Loot_IsRefValid( attachmentRef ) )
		return "invalid"

	if ( !IsValid( weapon ) )
		return "invalid"

	if ( weapon.IsWeaponOffhand() )
		return "invalid"

	LootData data      = SURVIVAL_GetLootDataFromWeapon( weapon )
	array<string> mods = weapon.GetMods()

	if ( !SURVIVAL_Loot_IsRefValid( data.ref ) )
		return "invalid"

	string attachmentPoint = GetAttachPointForAttachmentOnWeapon( data.ref, attachmentRef )

	if ( CanAttachToWeapon( attachmentRef, data.ref ) )
	{
		return GetInstalledWeaponAttachmentForPoint( weapon, attachmentPoint )
	}

	return "invalid"
}


bool function SURVIVAL_CanAddModToWeapon( entity player, entity weapon, string item, string modToRemove )
{
	if ( !SURVIVAL_Loot_IsRefValid( item ) )
		return false

	if ( modToRemove == item )
		return false

	if ( weapon.IsWeaponOffhand() )
		return false

	if ( !IsValid( weapon ) )
		return false

	LootData data     = SURVIVAL_GetLootDataFromWeapon( weapon )
	string weaponName = data.ref

	if ( SURVIVAL_IsAttachmentPointLocked( weaponName, GetAttachPointForAttachmentOnWeapon( weaponName, item ) ) )
		return false

	if ( weapon.IsDiscarding() )
		return false

	array<string> installedMods = GetValidLootModsInstalled( weapon )
	if ( installedMods.contains( item ) )
		return false

	array<string> mods = weapon.GetMods()

	if ( !SURVIVAL_Loot_IsRefValid( weaponName ) )
		return false

	bool allowedToAdd = false

	if ( CanAttachToWeapon( item, weaponName ) )
	{
		if ( modToRemove == "" )
		{
			return true
		}
		else
		{
			return mods.contains( modToRemove )
		}
	}

	return false
}


table<string, string> function GetAllWeaponAttachments( entity weapon )
{
	array<string> slots = GetAllAttachmentPoints()

	table<string, string> mods

	foreach ( s in slots )
		mods[ s ] <- GetInstalledWeaponAttachmentForPoint( weapon, s )

	return mods
}
#endif                    



int function SURVIVAL_CountPrimaryWeapons( entity player )
{
	array<entity> primaryWeapons = SURVIVAL_GetPrimaryWeapons( player )
	int weaponCount              = primaryWeapons.len()
	foreach ( weapon in primaryWeapons )
	{
		if ( !SURVIVAL_Loot_IsRefValid( weapon.GetWeaponClassName() ) )
			--weaponCount
	}
	return weaponCount
}


array<string> function SURVIVAL_GetPrimaryWeaponRefs( entity player )
{
	array<string> weaponRefs
	if ( IsValid( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 ) ) )
		weaponRefs.append( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 ).GetWeaponClassName() )
	else
		weaponRefs.append( "" )

	if ( IsValid( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 ) ) )
		weaponRefs.append( player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 ).GetWeaponClassName() )
	else
		weaponRefs.append( "" )

	return weaponRefs
}


string function SURVIVAL_GetWeaponBySlot( entity player, int slot )
{
	Assert( slot == WEAPON_INVENTORY_SLOT_PRIMARY_0 || slot == WEAPON_INVENTORY_SLOT_PRIMARY_1, "Invalid slot " + slot )

	if ( IsValid( player.GetNormalWeapon( slot ) ) )
		return player.GetNormalWeapon( slot ).GetWeaponClassName()

	return ""
}


string function SURVIVAL_GetWeaponAttachmentForPoint( entity player, int weaponSlot, string attachmentPoint )
{
	Assert( GetAllAttachmentPoints().contains( attachmentPoint ), "Invalid attachment point: " + attachmentPoint )
	if ( !IsValid( player.GetNormalWeapon( weaponSlot ) ) )
		return ""

	return GetInstalledWeaponAttachmentForPoint( player.GetNormalWeapon( weaponSlot ), attachmentPoint )
}


LootActionStruct function SURVIVAL_GetActionForEquipment( entity player, LootData lootData, bool isAltAction = false )
{
	if ( isAltAction )
		return SURVIVAL_GetAltActionForEquipment( player, lootData )

	LootTypeData lt = GetLootTypeData( lootData.lootType )

	LootActionStruct as
	as.action = lt.equipmentAction

	return as
}


LootActionStruct function SURVIVAL_GetAltActionForEquipment( entity player, LootData lootData )
{
	LootTypeData lt = GetLootTypeData( lootData.lootType )

	LootActionStruct as
	as.action = lt.equipmentAltAction

	return as
}


LootActionStruct function SURVIVAL_GetActionForBackpackItem( entity player, LootData lootData, bool isAltAction = false )
{
	if ( isAltAction )
		return SURVIVAL_GetAltActionForBackpackItem( player, lootData )

	LootTypeData lt = GetLootTypeData( lootData.lootType )

	int action = lt.backpackAction

	string reason

	                        
	LootActionStruct as
	if ( action == eLootAction.ATTACH_TO_ACTIVE )
	{
		as = SURVIVAL_GetActionForAttachment( player, lootData, false, true, false )
	}
	else
	{
		as.action = action
		as.displayString = reason
	}

	return as
}


LootActionStruct function SURVIVAL_GetActionForAttachment( entity player, LootData lootData, bool replaceEmptyOnly, bool tryStowedWeapon, bool upgradeOnly )
{
	int action    = eLootAction.NONE
	string reason = ""

	array<entity> weapons = SURVIVAL_GetPrimaryWeaponsSorted( player )

	string attachmentPointForMain = ""
	string attachmentPointForStowed = ""
	bool haveBetterAttachOnMain = false
	bool haveBetterAttachOnStowed = false

	bool wouldHaveEquipped = false

	if ( weapons.len() > 0 )
	{
		string activeWeapon = GetWeaponClassNameWithLockedSet( weapons[0] )
		bool canAttach      = CanAttachToWeapon( lootData.ref, activeWeapon )
		attachmentPointForMain = GetAttachPointForAttachmentOnWeapon( activeWeapon, lootData.ref )
		bool isEmpty        = canAttach && weapons.len() > 0 ? GetInstalledWeaponAttachmentForPoint( weapons[0], attachmentPointForMain ) == "" : false
		bool isSame         = canAttach && weapons.len() > 0 ? GetInstalledWeaponAttachmentForPoint( weapons[0], attachmentPointForMain ) == lootData.ref : false
		bool isUpgrade      = ["sight", "hopup", "hopupMulti_a", "hopupMulti_b"].contains( attachmentPointForMain ) || IsAttachmentAnUpgrade( player, lootData, eLootAction.ATTACH_TO_ACTIVE )

		bool canReallyEquip = !(activeWeapon == ""
				|| !canAttach
				|| isSame
				|| (replaceEmptyOnly && !isEmpty))

		wouldHaveEquipped = canReallyEquip || wouldHaveEquipped

		if ( !canReallyEquip || (upgradeOnly && !isUpgrade) )
		{
			if ( upgradeOnly && !isUpgrade )
				haveBetterAttachOnMain = true

			if ( tryStowedWeapon && weapons.len() > 1 )
				action = eLootAction.ATTACH_TO_STOWED
			else
				action = eLootAction.NONE
		}
		else
		{
			action = eLootAction.ATTACH_TO_ACTIVE
		}
	}

	if ( action == eLootAction.ATTACH_TO_STOWED )
	{
		string activeWeapon = SURVIVAL_GetStowedWeapon( player )
		bool canAttach      = CanAttachToWeapon( lootData.ref, activeWeapon )
		attachmentPointForStowed = GetAttachPointForAttachmentOnWeapon( activeWeapon, lootData.ref )
		bool isEmpty        = canAttach && weapons.len() > 1 ? GetInstalledWeaponAttachmentForPoint( weapons[1], attachmentPointForStowed ) == "" : false
		bool isSame         = canAttach && weapons.len() > 1 ? GetInstalledWeaponAttachmentForPoint( weapons[1], attachmentPointForStowed ) == lootData.ref : false
		bool isUpgrade      = ["sight", "hopup", "hopupMulti_a", "hopupMulti_b"].contains( attachmentPointForStowed ) || IsAttachmentAnUpgrade( player, lootData, eLootAction.ATTACH_TO_STOWED )

		bool canReallyEquip = !(activeWeapon == ""
				|| !canAttach
				|| isSame
				|| (replaceEmptyOnly && !isEmpty))

		wouldHaveEquipped = canReallyEquip || wouldHaveEquipped

		if ( !canReallyEquip || (upgradeOnly && !isUpgrade) )
		{
			if ( upgradeOnly && !isUpgrade )
				haveBetterAttachOnStowed = true

			action = eLootAction.NONE
		}
		else
		{
			reason = ""
		}
	}

	LootActionStruct as

	if ( action == eLootAction.NONE && wouldHaveEquipped )
	{
		action = eLootAction.IGNORE

		#if CLIENT
			string betterAttachPoint = ""
			if ( haveBetterAttachOnMain )
			{
				betterAttachPoint = attachmentPointForMain
			}
			else if ( haveBetterAttachOnStowed )
			{
				betterAttachPoint = attachmentPointForStowed
			}
			else
			{
				Assert( false, "Reached script that should be unreachable! If this happens in live we won't show a reason why you cannot attach." )
			}

			if ( betterAttachPoint != "" )
				reason = Localize( "#REASON_YOU_HAVE_A_BETTER", Localize( GetAttachmentPointName( betterAttachPoint ) ) )
		#endif
	}

	as.action = action
	as.displayString = reason

	return as
}


LootActionStruct function SURVIVAL_GetAltActionForBackpackItem( entity player, LootData lootData )
{
	LootTypeData lt = GetLootTypeData( lootData.lootType )

	LootActionStruct as
	as.action = lt.backpackAltAction

	return as
}

#if CLIENT || SERVER
array<string> function SURVIVAL_GetAllPlayerOrdnance( entity player )
{
	array<string> allOrdnance                      = []
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )

	foreach ( invItem in playerInventory )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByIndex( invItem.type )
		if ( data.lootType != eLootType.ORDNANCE )
			continue

		if ( data.conditional )
		{
			if ( !SURVIVAL_Loot_RunConditionalCheck( data.ref, player ) )
				continue
		}

		if ( !allOrdnance.contains( data.ref ) )
		{
			allOrdnance.append( data.ref )
		}
	}

	return allOrdnance
}

bool function SURVIVAL_PlayerCanUse_AnimatedInteraction( entity player, entity ent )
{
	if ( !IsValid( player ) )
		return false

	if ( Bleedout_IsBleedingOut( player ) )
		return false

	if ( player.ContextAction_IsActive() )
		return false

	if ( !SURVIVAL_PlayerAllowedToPickup( player ) )
		return false

	if ( IsValid( player.GetParent() ) )
		return false

	if ( ent.e.isBusy )
		return false

	return true
}

bool function SURVIVAL_CanPlayerPickup( entity player, entity pickup, int useInputFlags = 0 )
{
	#if SERVER
		                                        
			            
	#endif

	if ( !IsValid( pickup ) )
		return false

                 
		if ( Crafting_IsItemCurrentlyOwnedByAnyPlayer( pickup ) && ! Crafting_DoesPlayerOwnItem( player, pickup ) )
		{
			#if CLIENT
				string announcementMessage = "#CRAFTING_GRACE_DENIED"
                            
					if ( Control_IsModeEnabled() )
						announcementMessage = Localize( "#CONTROL_GUNRACKS_GRACE_DENIED", ControlGunRacks_GetPickupGracePeriodDuration() )
                                  

				AnnouncementMessageQuick( player, announcementMessage )
			#endif          
			return false
		}
       

	return SURVIVAL_PlayerAllowedToPickup( player, useInputFlags )
}

bool function SURVIVAL_PlayerAllowedToPickup( entity player, int useInputFlags = 0 )
{
	entity activeMainWeapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )

	if ( IsValid( activeMainWeapon ) && activeMainWeapon.IsWeaponOffhand() )
	{
		var offhandAllowsPickups = activeMainWeapon.GetWeaponInfoFileKeyField( "offhand_allow_player_interact" )
		if ( !offhandAllowsPickups || offhandAllowsPickups <= 0 )
			return false
	}

	return PlayerCommonItemPickupCheck( player, useInputFlags )
}

bool function PlayerCommonItemPickupCheck( entity player, int useInputFlags = 0 )
{
	bool isTouchUse = (useInputFlags & USE_INPUT_AUTO) != 0
	if ( player.GetWeaponDisableFlags() == WEAPON_DISABLE_FLAGS_ALL && !isTouchUse )
		return false
	if ( IsPlayingFirstPersonAnimation( player ) )
		return false
	if ( IsPlayingFirstAndThirdPersonAnimation( player ) )
		return false
	if ( !PlayerInValidState( player, false ) )
		return false

	return true
}

bool function SURVIVAL_PlayerCanSwitchOrdnance( entity player )
{
	if ( IsValid( player.GetActiveWeapon( eActiveInventorySlot.mainHand ) )
	&& player.GetActiveWeapon( eActiveInventorySlot.mainHand ).IsWeaponOffhand()
	&& player.GetActiveWeapon( eActiveInventorySlot.mainHand ).GetWeaponSettingEnum( eWeaponVar.fire_mode, eWeaponFireMode ) != eWeaponFireMode.offhandHybrid
	&& !player.GetActiveWeapon( eActiveInventorySlot.mainHand ).GetWeaponSettingBool( eWeaponVar.offhand_toss_activates_on_attack )
	)
		return false

	if ( !player.IsWeaponTypeEnabled( WPT_GRENADE ) )
		return false

#if SERVER
                       
                                      
              
                                 

	                                           
		            
#endif              

	if ( player.Player_IsSkywardLaunching() )
		return false

	return PlayerInValidState( player, true )
}

bool function PlayerInValidState( entity player, bool allowContextActionIfZipline )
{
	if ( !IsAlive( player ) )
		return false

	if ( player.ContextAction_IsActive() )
	{
		if ( !(allowContextActionIfZipline && player.ContextAction_IsZipline()) )
			return false
	}

	if ( Bleedout_IsBleedingOut( player ) )
		return false

	if ( SURVIVAL_IsPlayerCarryingLoot( player ) )
		return false

	if ( player.IsPhaseShifted() )
		return false

	return true
}

bool function SURVIVAL_IsPlayerCarryingLoot( entity player )
{
	#if SERVER
		                                      
	#else
		return (player.GetWeaponDisableFlags() == WEAPON_DISABLE_FLAGS_ALL)
	#endif
}
#endif                        

LootActionStruct function SURVIVAL_GetActionForGroundItem( entity player, LootRef lootRef, bool isAltAction = false, bool isUseLongAction = false )
{
	LootTypeData lt = GetLootTypeData( lootRef.lootData.lootType )
	CachedLootActionData cd

	#if CLIENT
		                                                                        

		if ( file.lastCacheUpdateTime < Time() )
		{
			file.lastCacheUpdateTime = Time()
			file.cachedActionForGroundItemDataAlt.clear()
			file.cachedActionForGroundItemData.clear()
		}

		if ( !(player in file.cachedActionForGroundItemDataAlt) )
		{
			file.cachedActionForGroundItemDataAlt[ player ] <- {}
		}

		if ( !(player in file.cachedActionForGroundItemData) )
		{
			file.cachedActionForGroundItemData[ player ] <- {}
		}

		table<entity, CachedLootActionData> tableToUse = isAltAction ? file.cachedActionForGroundItemDataAlt[ player ] : file.cachedActionForGroundItemData[ player ]

		if ( IsValid( lootRef.lootEnt ) )
		{
			if ( lootRef.lootEnt in tableToUse )
			{
				cd = tableToUse[ lootRef.lootEnt ]

				if ( cd.lastUpdateTime == Time() )
				{
					return cd.actionStruct
				}

				tableToUse[ lootRef.lootEnt ].lastUpdateTime = Time()
			}
			else
			{
				tableToUse[ lootRef.lootEnt ] <- cd
			}
		}
	#endif

	if ( isAltAction )
	{
		cd.actionStruct = lt.groundAltActionFunc( player, lootRef )
		return cd.actionStruct
	}

	if ( isUseLongAction )
	{
		if ( lt.groundUseLongActionFunc != null )
		{
			cd.actionStruct = lt.groundUseLongActionFunc( player, lootRef )
			return cd.actionStruct
		}
		else
		{
			LootActionStruct as
			as.action = eLootAction.NONE
			cd.actionStruct = as
			return cd.actionStruct
		}
	}

	cd.actionStruct = lt.groundActionFunc( player, lootRef )
	return cd.actionStruct
}


LootRef function SURVIVAL_CreateLootRef( LootData lootData, entity lootEnt )
{
	LootRef lootRef
	lootRef.lootData = lootData
	lootRef.lootEnt = lootEnt
	if ( IsValid( lootEnt ) )
	{
		lootRef.lootProperty = lootEnt.GetSurvivalProperty()
		lootRef.lootExrtaProperty = GetPropSurvivalExtraPropertyFromEnt( lootEnt )
	}

	return lootRef
}


LootRef function SURVIVAL_CreateLootRefFromLootEnt( entity lootEnt )
{
	Assert( IsValid( lootEnt ) && lootEnt.GetNetworkedClassName() == "prop_survival" )
	LootRef lootRef
	lootRef.lootData = SURVIVAL_Loot_GetLootDataByIndex( lootEnt.GetSurvivalInt() )
	lootRef.count = (lootRef.lootData.lootType == eLootType.MAINWEAPON ? 1 : lootEnt.GetClipCount())
	lootRef.lootEnt = lootEnt
	lootRef.lootProperty = lootEnt.GetSurvivalProperty()
	lootRef.lootExrtaProperty = GetPropSurvivalExtraPropertyFromEnt( lootEnt )

	return lootRef
}


bool function SURVIVAL_HasSpecificItemInInventory( entity player, string ref, int count )
{
	LootData data                                  = SURVIVAL_Loot_GetLootDataByRef( ref )
	int type                                       = data.index
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )
	foreach ( invItem in playerInventory )
	{
		if ( invItem.type == type && invItem.count == count )
		{
			return true
		}
	}

	return false
}


bool function SURVIVAL_IsLootIrrelevant( entity player, entity lootItem, LootData lootData, int lootContext )
{
	LootRef lootRef = SURVIVAL_CreateLootRef( lootData, lootItem )

	LootActionStruct asMain = SURVIVAL_GetActionForItem( player, lootContext, lootRef, false )
	LootActionStruct asAlt  = SURVIVAL_GetActionForItem( player, lootContext, lootRef, true )

	int lootAction    = asMain.action
	int altLootAction = asAlt.action

	if ( lootData.ref in player.p.requiredLootTypes )
	{
		                                                                                          
		return false
	}
	else if ( lootData.lootType == eLootType.ATTACHMENT )
	{
		return (lootAction == eLootAction.PICKUP || lootAction == eLootAction.NONE || lootAction == eLootAction.IGNORE)
	}
	else if ( lootData.lootType == eLootType.AMMO )
	{
		return (!IsAmmoInUse( player, lootData.ref ))
	}

	return (lootAction == eLootAction.NONE && altLootAction == eLootAction.NONE)
}


bool function SURVIVAL_IsLootAnUpgrade( entity player, entity lootItem, LootData lootData, int lootContext )
{
	bool irrelevant = SURVIVAL_IsLootIrrelevant( player, lootItem, lootData, lootContext )

	if ( irrelevant )
		return false

	int currentTier = 999

	LootRef lootRef = SURVIVAL_CreateLootRef( lootData, lootItem )

	LootTypeData ltData = GetLootTypeData( lootData.lootType )

	if ( ltData.equipmentSlot != "" )
	{
		LootData equippedData = EquipmentSlot_GetEquippedLootDataForSlot( player, ltData.equipmentSlot )
		currentTier = equippedData.tier
	}
	else
	{
		switch ( lootData.lootType )
		{
			case eLootType.ATTACHMENT:

				array<string> attachmentPoints = GetAttachPointsForAttachment( lootData.ref )

				if ( CanAttachmentEquipToOneOfAttachPoints( lootData.ref, ["sight", "hopup", "hopupMulti_a", "hopupMulti_b"] ) )
				{
					array<entity> weapons = SURVIVAL_GetPrimaryWeapons( player )
					foreach ( string attachmentPoint in attachmentPoints )
					{
						foreach ( w in weapons )
						{
							if ( GetInstalledWeaponAttachmentForPoint( w, attachmentPoint ) == "" && !WeaponLootRefIsLockedSet( GetWeaponClassNameWithLockedSet( w ) ) && CanAttachToWeapon( lootData.ref, GetWeaponClassName( w ) ) )
							{
								return true
							}
						}
					}

					return false
				}
				else
				{
					LootActionStruct asMain = SURVIVAL_GetActionForItem( player, lootContext, lootRef, false )
					if ( lootContext == eLootContext.GROUND )
						return asMain.action == eLootAction.ATTACH_TO_ACTIVE || asMain.action == eLootAction.ATTACH_TO_STOWED
					else
						return IsAttachmentAnUpgrade( player, lootData, asMain.action )
				}

				break

			case eLootType.MAINWEAPON:
				array<entity> weapons = SURVIVAL_GetPrimaryWeapons( player )
				return weapons.len() < 2

			case eLootType.AMMO:
				return IsAmmoInUse( player, lootData.ref ) && SURVIVAL_CountItemsInInventory( player, lootData.ref ) < lootData.inventorySlotCount
		}
	}

	return currentTier < lootData.tier
}


bool function IsAttachmentAnUpgrade( entity player, LootData lootData, int action )
{
	array<entity> weapons  = SURVIVAL_GetPrimaryWeaponsSorted( player )
	string installed

	LootData attachedData
	attachedData.tier = -1

	if ( action == eLootAction.ATTACH_TO_ACTIVE )
	{
		string attachPoint = GetAttachPointForAttachmentOnWeapon( GetWeaponClassNameWithLockedSet( weapons[0] ), lootData.ref )
		installed = GetInstalledWeaponAttachmentForPoint( weapons[0], attachPoint )
	}
	else if ( action == eLootAction.ATTACH_TO_STOWED )
	{
		string attachPoint = GetAttachPointForAttachmentOnWeapon( GetWeaponClassNameWithLockedSet( weapons[1] ), lootData.ref )
		installed = GetInstalledWeaponAttachmentForPoint( weapons[1], attachPoint )
	}

	if ( SURVIVAL_Loot_IsRefValid( installed ) )
	{
		attachedData = SURVIVAL_Loot_GetLootDataByRef( installed )
	}

	return attachedData.tier < lootData.tier
}


LootActionStruct function SURVIVAL_GetActionForItem( entity player, int context, LootRef lootRef, bool isAltAction )
{
	LootActionStruct as
	LootData actionLoot = lootRef.lootData

	if ( context == eLootContext.GROUND )
		as = SURVIVAL_GetActionForGroundItem( player, lootRef, isAltAction )
	else if ( context == eLootContext.BACKPACK )
		as = SURVIVAL_GetActionForBackpackItem( player, actionLoot, isAltAction )
	else if ( context == eLootContext.EQUIPMENT )
		as = SURVIVAL_GetActionForEquipment( player, actionLoot, isAltAction )

	return as
}

#if CLIENT
LootActionStruct function SURVIVAL_BuildStringForAction( entity player, int context, LootRef lootRef, bool isAltAction, bool isInMenu )
{
	int action
	LootData actionLoot = lootRef.lootData

	                                                                                
	string buttonString = isAltAction ? "%&use_alt%" : "%&use%"

	if ( isInMenu )
	{
		buttonString = isAltAction ? "%[X_BUTTON|MOUSE2]%" : "%[A_BUTTON|MOUSE1]%"
	}

	LootActionStruct as = SURVIVAL_GetActionForItem( player, context, lootRef, isAltAction )
	action = as.action

	if ( SURVIVAL_EquipmentPretendsToBeBlank( lootRef.lootData.ref ) )
		action = eLootAction.NONE

	string actionString = SURVIVAL_GetStringForLootAction( action )

	switch ( action )
	{
		case eLootAction.USE:
			if ( actionLoot.lootType == eLootType.HEALTH )
			{
				HealthPickup pickup = SURVIVAL_Loot_GetHealthKitDataFromStruct( SURVIVAL_Loot_GetHealthPickupTypeFromRef( lootRef.lootData.ref ) )
				int kitCat          = SURVIVAL_Loot_GetHealthPickupCategoryFromData( pickup )
				bool hasShield      = EquipmentSlot_GetLootRefForSlot( player, "armor" ) != ""

				if ( kitCat == eHealthPickupCategory.HEALTH )
				{
					if ( (player.GetHealth() >= player.GetMaxHealth()) )
						actionString = Localize( "#LOOT_ACTION_BLOCKED_HEALTH_FULL" )
				}

				if ( kitCat == eHealthPickupCategory.SHIELD )
				{
					if ( (player.GetShieldHealth() >= player.GetShieldHealthMax()) )
						actionString = Localize( "#LOOT_ACTION_BLOCKED_SHIELD_FULL" )

					if ( !hasShield )
						actionString = Localize( "#LOOT_ACTION_BLOCKED_SHIELD_NONE" )
				}

				if ( kitCat == eHealthPickupCategory.COMBO )
				{
					if ( player.GetHealth() >= player.GetMaxHealth() )
					{
						if ( hasShield && player.GetShieldHealth() >= player.GetShieldHealthMax() )
							actionString = Localize( "#LOOT_ACTION_BLOCKED_COMBO_FULL" )

						if ( !hasShield )
							actionString = Localize( "#LOOT_ACTION_BLOCKED_HEALTH_FULL" )
					}
				}

				if ( kitCat == eHealthPickupCategory.ULTIMATE )
				{
					entity ultAbility = player.GetOffhandWeapon( OFFHAND_INVENTORY )
					if ( !IsValid( ultAbility ) )                                            
						return as

					int ammo    = ultAbility.GetWeaponPrimaryClipCount()
					int maxAmmo = ultAbility.GetWeaponPrimaryClipCountMax()

					if ( ammo >= maxAmmo )
						actionString = Localize( "#LOOT_ACTION_BLOCKED_ULTIMATE_FULL" )

					if ( !ultAbility.IsReadyToFire() )
						actionString = Localize( "#LOOT_ACTION_BLOCKED_ULTIMATE_ACTIVE" )
				}

				as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
			}

                       
                                                     
    
                                                                                                                                                                    
                                                                                   

                                                
     
                                  
                                                     
     
                                                                                                                     
     
                         
                                                        
     

                                                                             
    
       
      
			{
				if ( actionLoot.lootType == eLootType.CUSTOMPICKUP )
				{
					as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
				}
                   
				else if ( actionLoot.lootType == eLootType.MARVIN_ARM )
				{
					as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
				}
      
			}

			break

		case eLootAction.EQUIP:
			if ( actionLoot.lootType == eLootType.MAINWEAPON )
			{
				string replaceWeapon = GetWeaponToReplace( player )
				if ( replaceWeapon == "" || context == eLootContext.EQUIPMENT )
				{
					as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
					break
				}

				LootData replaceWeaponData = SURVIVAL_Loot_GetLootDataByRef( replaceWeapon )
				string hintString          = GetLootPromptStyle() == eLootPromptStyle.COMPACT ? "#ACTION_REPLACE" : "#ACTION_EQUIP"
				as.displayString = Localize( "#LOOT_ACTION_ON_ITEM", buttonString, Localize( hintString ), Localize( replaceWeaponData.pickupString ) )
			}
			else
			{
				LootData lootData = lootRef.lootData
				LootTypeData lt   = GetLootTypeData( lootData.lootType )
				LootData equippedData

				if ( lt.equipmentSlot != "" )
					equippedData = EquipmentSlot_GetEquippedLootDataForSlot( player, lt.equipmentSlot )

				if ( equippedData.ref == "" )
				{
					as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
				}
				else
				{
					string hintString = GetLootPromptStyle() == eLootPromptStyle.COMPACT ? "#ACTION_REPLACE" : "#ACTION_EQUIP"
					as.displayString = Localize( "#LOOT_ACTION_ON_ITEM", buttonString, Localize( hintString ), Localize( equippedData.pickupString ) )
					as.additionalData = equippedData
				}
			}
			break

		case eLootAction.ATTACH_TO_ACTIVE:
		case eLootAction.ATTACH_TO_STOWED:
			if ( actionLoot.lootType == eLootType.ATTACHMENT )
			{
				int weaponSlot = action == eLootAction.ATTACH_TO_ACTIVE ? SURVIVAL_GetActiveWeaponSlot( player ) : SURVIVAL_GetStowedWeaponSlot( player )
				if ( weaponSlot == -1 )
					break

				string selectedWeapon = SURVIVAL_GetWeaponBySlot( player, weaponSlot )
				if ( selectedWeapon == "" )
					break

				LootData selectedWeaponData = SURVIVAL_Loot_GetLootDataByRef( selectedWeapon )
				if ( selectedWeaponData.lootType != eLootType.MAINWEAPON )
					break

				entity weapon = player.GetNormalWeapon( weaponSlot )
				string attachmentPoint = GetAttachPointForAttachmentOnWeapon( GetWeaponClassNameWithLockedSet( weapon ), actionLoot.ref )
				if ( attachmentPoint == "" )
					break

				string currentAttachmentForIntendedSlot = GetInstalledWeaponAttachmentForPoint( weapon, attachmentPoint )
				if ( currentAttachmentForIntendedSlot == "" )
				{
					as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
					LootData blankData

					                                     
					string equipSlot       = "main_weapon" + weaponSlot + "_" + attachmentPoint
					string attachmentStyle = GetAttachmentPointStyle( attachmentPoint, selectedWeapon )

					blankData.ref = attachmentPoint
					blankData.tier = 0
					blankData.hudIcon = emptyAttachmentSlotImages[attachmentStyle]
					blankData.pickupString = " "
					as.additionalData = blankData
				}
				else
				{
					LootData attachmentData = SURVIVAL_Loot_GetLootDataByRef( currentAttachmentForIntendedSlot )

					string baseString = "#LOOT_ACTION_ON_ITEM"
					if ( action == eLootAction.ATTACH_TO_STOWED )
						baseString = "#LOOT_ACTION_ON_STOWED_ITEM"

					string hintString = GetLootPromptStyle() == eLootPromptStyle.COMPACT ? "#ACTION_REPLACE" : "#ACTION_EQUIP"
					as.displayString = Localize( baseString, buttonString, Localize( hintString ), Localize( attachmentData.pickupString ) )
					as.additionalData = attachmentData
				}
			}
			break

		case eLootAction.DISMANTLE:
			as.displayString = ""
			as.displayString = Localize( "#LOOT_ACTION", buttonString, Localize( "#ACTION_REPLACE_WEAPON" ) )
			break

		case eLootAction.NONE:
		case eLootAction.IGNORE:
			if ( context == eLootContext.EQUIPMENT )
				as.displayString = ""
			else
				as.displayString = Localize( as.displayString, as.additionalData.ref )
			break

		case eLootAction.SWAP:
			if ( !isInMenu )
				buttonString = isAltAction ? "%use_alt%" : "%use_long%"
			as.displayString = Localize( "#LOOT_ACTION_HOLD", buttonString, actionString )

			LootData lootData = lootRef.lootData
			LootTypeData lt = GetLootTypeData( lootData.lootType )
			LootData equippedData

			if ( lt.equipmentSlot != "" )
				equippedData = EquipmentSlot_GetEquippedLootDataForSlot( player, lt.equipmentSlot )

			if ( equippedData.ref != "" )
				as.additionalData = equippedData

			break

		case eLootAction.DROP:
		case eLootAction.DROP_ALL:
			if ( !Survival_PlayerCanDrop( player ) )
				actionString = Localize( "#UNAVAILABLE" )

			as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
			break

		default:
			as.displayString = Localize( "#LOOT_ACTION", buttonString, actionString )
	}

	return as
}

void function SURVIVAL_UpdateStringForEquipmentAction( entity player, string equipmentSlot, LootActionStruct as, LootRef lootRef )
{
	LootData actionLoot = lootRef.lootData

	if ( actionLoot.lootType == eLootType.ATTACHMENT )
	{
		EquipmentSlot es = Survival_GetEquipmentSlotDataByRef( equipmentSlot )
		EquipmentSlot ws = Survival_GetEquipmentSlotDataByRef( es.attachmentWeaponSlot )

		entity fromWeapon = player.GetNormalWeapon( ws.weaponSlot )

		LootData weaponData = SURVIVAL_GetLootDataFromWeapon( fromWeapon )

		if ( SURVIVAL_IsAttachmentPointLocked( weaponData.ref, actionLoot.attachmentStyle ) )
		{
			as.action = eLootAction.NONE
			as.displayString = ""
			return
		}
	}

	switch ( as.action )
	{
		case eLootAction.WEAPON_TRANSFER:
			if ( actionLoot.lootType == eLootType.ATTACHMENT )
			{
				EquipmentSlot es = Survival_GetEquipmentSlotDataByRef( equipmentSlot )
				EquipmentSlot ws = Survival_GetEquipmentSlotDataByRef( es.attachmentWeaponSlot )
				EquipmentSlot ns = Survival_GetEquipmentSlotDataByRef( ws.nextWeaponSlot )

				entity attachWeapon       = player.GetNormalWeapon( ns.weaponSlot )
				LootData attachWeaponData = SURVIVAL_GetLootDataFromWeapon( attachWeapon )

				bool canAttach = (IsValid( attachWeapon ) &&
									SURVIVAL_Loot_IsRefValid( attachWeaponData.ref ) &&
									CanAttachToWeapon( actionLoot.ref, attachWeaponData.ref ) )

				if ( !canAttach )
				{
					if ( SURVIVAL_IsAttachmentPointLocked( attachWeaponData.ref, actionLoot.ref ) )
						as.displayString = Localize( "#REASON_CANNOT_TRANSFER_FULLY_KITTED" )
					else if ( attachWeaponData.pickupString != "" )
						as.displayString = Localize( "#REASON_CANNOT_TRANSFER", Localize( attachWeaponData.pickupString ) )
					else
						as.displayString = ""
				}
			}
			break
	}
}
#endif



string function GetWeaponToReplace( entity player )
{
	if ( SURVIVAL_GetWeaponBySlot( player, 0 ) == "" || SURVIVAL_GetWeaponBySlot( player, 1 ) == "" )
		return ""

	string replaceWeapon = SURVIVAL_GetActiveWeapon( player )
	if ( replaceWeapon == "" || !SURVIVAL_Loot_IsRefValid( replaceWeapon ) )
	{
		replaceWeapon = SURVIVAL_GetWeaponBySlot( player, 0 )
	}
	else
	{
		LootData lootData = SURVIVAL_Loot_GetLootDataByRef( replaceWeapon )
		if ( lootData.lootType != eLootType.MAINWEAPON )
			replaceWeapon = SURVIVAL_GetWeaponBySlot( player, 0 )
	}

	return SURVIVAL_Loot_IsRefValid( replaceWeapon ) ? replaceWeapon : ""
}


#if SERVER
                                                                                                             
 
	           
	                                                                          
	 
		                                        
			        

		                                              
			        

		              
		                                       
		 
			                                                                                          
			        
		 
                        
                                                   
   
                                                                                                       
           
   
       


		  
		                                           
		 
			                                                                                                      
			        
		 
		  
		                  
			        

		                                          
		 
			                                                          
				        

			                                                               
				        

			                                                             
				        

			                                                              
				        

			                                                                   
				        

			                                                                     
				        

			                                                                   
				        

                                   
                                                                    
             
         
		 

                   
                                                 
           
        

		                                
		                                
		                                                           
		                             

		     
	 
 
#endif          

#if SERVER && DEV
                           
                                          
 
	                          
	                                                                          
	 
		                                        
			        

		                                            
			                      
	 

	                               
		                                               
	                                               
		                      

	                                           

	                    

	             
 

                         
                                                                        
 
	                               

	                                                       

	                                                                                                           
	                                         
		                               

	                                

	                       
		                                   

	                 
	                    
	 
		       
			                                     
			     

		       
			                                     
			     

		       
			                                     
			     

		       
			                                                
			     

		        
			                                     
			     
	 

	                       

	                                                                         
	                            
	 
		                     
			        

		                                    
			        

		                                      
			        

		                                                      
		                             
		                           
		                                                                                                
		     
	 
 

                                                                 
 
	                                                                 
 

                                                                                                    
 
	                                                                  
	                                                     
	                                                      
 

                                                                                                            
 
	                                                                      
	                                                    
	                                                      
 
#endif


#if CLIENT || SERVER
void function Inventory_RegisterNetworking()
{
	Remote_RegisterClientFunction( "ServerToClient_PickedupItem", "entity", "int", 0, 512, "int", 0, 512 )
	Remote_RegisterClientFunction( "ServerCallback_DroppedItem", "entity", "int", 0, 512 )
	Remote_RegisterClientFunction( "ServerCallback_AttachedMod", "int", 0, 999, "int", 0, 999 )

	Remote_RegisterClientFunction( "ServerCallback_PlayFPEvoShieldUpgradeFX", "entity" )
	Remote_RegisterClientFunction( "ServerCallback_Play3PEvoShieldUpgradeFX", "entity" )
}
#endif                    

#if SERVER
                                                                              
 
	                                                                                 
		      

	                

	                                    
	                                

	                                                     
	                                                                         
		                                                                                                       

	                                            
	 
		                               
		                                                                

		                                                                            

		                                                   
		 
			                                                       
				                                
		 

		                            
		 
			                                  
			 
				                                                                                             
					                                
				    
					                                                                    
			 
			    
			 
				                                                    
			 
		 
		    
		 
			                                                                
			                                             
			 
				                                                                  
				                                                                  
			 
			    
			 
				                                                    
			 
		 
	 
 

                                                                            
 
	                                     

	                                                     
	                                                                         
		                                                                                          

	                                            
	 
		                                                                
		                                                                

		                              
		 
			                                                           
		 

		                                                    
	 
                         
		                              
			                                
                               
                  
		                                                      
			                                                  
       
 

                                                                                     
 
	                                                             

	                                                                            
	                 
	                     

	                                            
		      

	                        
	 
		                                                                      
	 

	                        
	 
		                                                                      
	 

	                            
	 
		                                                
		                                                 
		 
			                                                                          
			                                     
			 
				                                                                      
				                                                        
				      
			 
			    
			 
				      
			 
		 
	 

	                                                        
	                                                        

	                                                                                           
	 
		                                                                    
		                                                                    

		                                                                  
		                                                                  
	 
 
#elseif CLIENT	             

void function ServerToClient_PickedupItem( entity player, int idx, int lootAction )
{
	if ( !IsValid( player ) )
		return

	LootData data   = SURVIVAL_Loot_GetLootDataByIndex( idx )
	string itemName = Localize( data.pickupString )

	bool isLocalPlayer = (player == GetLocalViewPlayer())
	if ( data.printPickupToObituary || GetCurrentPlaylistVarBool( "log_pickup_to_obituary", false ) )
	{
		if ( isLocalPlayer )
			Obituary_Print_Localized( Localize( "#SURVIVAL_PICKED_UP_YOU", itemName, data.hudIcon ), GetChatTitleColorForPlayer( player ), BURN_COLOR )
		else
			Obituary_Print_Localized( Localize( "#SURVIVAL_PICKED_UP_OTHER", player.GetPlayerName(), itemName, data.hudIcon ), GetChatTitleColorForPlayer( player ), BURN_COLOR )
	}

	if ( isLocalPlayer )
	{
		foreach ( func in file.localPlayerPickedupLootCallbacks )
			func( player, data, lootAction )

		                                                                                                                                                               
		if ( data.lootType == eLootType.ARMOR )
			player.Signal( "ShieldChanged" )
	}

	                      
	  	                                                                                    

	ResetInventoryMenu( GetLocalViewPlayer() )
}

void function AddCallback_LocalPlayerPickedUpLoot( void functionref( entity, LootData, int ) func )
{
	file.localPlayerPickedupLootCallbacks.append( func )
}

void function ServerCallback_DroppedItem( entity player, int idx )
{
	if ( !IsValid( player ) )
		return

	LootData data      = SURVIVAL_Loot_GetLootDataByIndex( idx )
	string itemName    = Localize( data.pickupString )
	bool isLocalPlayer = (player == GetLocalViewPlayer())

	if ( GetCurrentPlaylistVarBool( "log_pickup_to_obituary", false ) )
	{
		if ( isLocalPlayer )
			Obituary_Print_Localized( Localize( "#SURVIVAL_DROPPED_YOU", itemName, data.hudIcon ), GetChatTitleColorForPlayer( player ), BURN_COLOR )
		else
			Obituary_Print_Localized( Localize( "#SURVIVAL_DROPPED_OTHER", player.GetPlayerName(), itemName, data.hudIcon ), GetChatTitleColorForPlayer( player ), BURN_COLOR )
	}

	                      
	  	                                                                                  

	ResetInventoryMenu( GetLocalViewPlayer() )
}

void function ServerCallback_AttachedMod( int wIdx, int mIdx )
{
	LootData wData = SURVIVAL_Loot_GetLootDataByIndex( wIdx )
	LootData mData = SURVIVAL_Loot_GetLootDataByIndex( mIdx )

	if ( GetCurrentPlaylistVarBool( "log_pickup_to_obituary", false ) )
		Obituary_Print_Localized( Localize( "#SURVIVAL_ATTACHED_TO_WEAPON", Localize( wData.pickupString ), Localize( mData.pickupString ) ), TEAM_COLOR_YOU )

	                                                                                                                                          
}

#endif                  	             


#if SERVER
                                                                                                                                                                 
 
	  
	 
		                                                                           
		                                               
		 
			                                                              
			                                        
				                                   
		 
	 

	                                                                      
	                     

	                               
	 
		                                             
		                                                                 
		                                                                               
	 

	                                          
	 
		                                                         
		                  

		                                        
		 
			                                   
		 

		                                                                   
		 
			                                                                      
			                                                                        

			                                                                            
			                                      

			                                                                                                                                                  
			                                         
		 
	 

	                              
	 
		                                                  
	 

	                                                             

	                                      
		                                                                  

	                                       
		                               
 
                                                                                                                                                
 
	                                                                                                       
 
                                                                                                                    
 
	                                                                                                  
 

                                                                                   
 
	                                                          
 

                                                                  
 
	                                                                                       
	 
		                                                             
		                    
			        

		                                                                                  

		                                                   
		                                                                    
	 
 

#endif          

#if CLIENT
void function SURVIVAL_UpdateIcons( string weaponName, string category )
{
	LootData data
	data = SURVIVAL_Loot_GetLootDataByRef( category )
	data.hudIcon = GetWeaponInfoFileKeyFieldAsset_Global( weaponName, "hud_icon" )
}
#endif

bool function SurvivalLoot_CanUseFunction( entity player, entity ent, int useFlags )
{
	if ( Bleedout_IsBleedingOut( player ) )
		return false

	bool autoUse = (useFlags & USE_FLAG_AUTO) != 0

	int lootIdx = ent.GetSurvivalInt()
	bool foundLootData = false
	LootData data
	if ( lootIdx >= 0 )
	{
		foundLootData = true
		data = SURVIVAL_Loot_GetLootDataByIndex( lootIdx )
	}

	#if LOOT_GROUND_VERTICAL_LINES
		if ( !autoUse && !SurvivalLoot_PlayerLookingAtLine( player, ent ) )
			return false
	#endif

	if ( !autoUse )
	{
		entity activeWeapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
		if ( IsValid( activeWeapon ) )
		{
			if ( activeWeapon.IsWeaponOffhand() )
			{
				var offhandAllowsPickups = activeWeapon.GetWeaponInfoFileKeyField( "offhand_allow_player_interact" )
				if ( !offhandAllowsPickups || offhandAllowsPickups <= 0 )
					return false
			}
		}
	}

                     
                                                                
                                                     
       

                        
                                                                    
                                                    
       

	if ( foundLootData && data.extraCanUseFunction != null )
		return data.extraCanUseFunction( player, ent, useFlags )

	return true
}


bool function SurvivalBasicUsable_CanUseFunction( entity player, entity ent, int useFlags )
{
	if ( Bleedout_IsBleedingOut( player ) )
		return false

	entity activeWeapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
	if ( IsValid( activeWeapon ) )
	{
		if ( activeWeapon.IsWeaponOffhand() )
			return false
	}

	return true
}


bool function ThirdPersonUseDistanceCheck( entity player, entity targetEnt )
{
	const float MAX_PC_USE_DISTANCE_SQR = (80.0 * 80.0)
	vector entPos    = targetEnt.GetOrigin()
	vector playerPos = player.GetOrigin()
	if ( Distance2DSqr( entPos, playerPos ) > MAX_PC_USE_DISTANCE_SQR )
		return false

	return true
}

#if LOOT_GROUND_VERTICAL_LINES
bool function SurvivalLoot_PlayerLookingAtLine( entity player, entity ent )
{
	                                                                                                    
	                 
	  	           

	if ( player.IsThirdPersonShoulderModeOn() )
		return ThirdPersonUseDistanceCheck( player, ent )

	vector viewVector = player.GetViewVector()
	vector viewAngles = player.CameraAngles()
	vector viewPos    = player.UseableEyePosition( ent )
	vector entPos     = ent.GetOrigin()
	vector mins       = ent.GetBoundingMins()
	vector maxs       = ent.GetBoundingMaxs()

	vector topPos = entPos + (player.IsCrouched() ? < 0, 0, max( maxs.z, 16.0 ) > : < 0, 0, VERTICAL_LINE_HEIGHT - 10.0 >)
	vector botPos = entPos + < 0, 0, -6.0 >

	vector planeAngles             = AnglesToForward( <0, viewAngles.y, 0> )
	vector ornull pointOnLinePlane = GetIntersectionOfLineAndPlane( viewPos, viewPos + viewVector * 1000, entPos, planeAngles )

	if ( pointOnLinePlane == null )
		return false

	expect vector( pointOnLinePlane )

	if ( pointOnLinePlane.z > topPos.z )
		return false

	bool isMainWeapon = SURVIVAL_Loot_GetLootDataByIndex( ent.GetSurvivalInt() ).lootType == eLootType.MAINWEAPON
	bool lookingBelow = pointOnLinePlane.z < botPos.z

	if ( lookingBelow || isMainWeapon )
	{
		vector ornull pointOnGroundPlane = GetIntersectionOfLineAndPlane( viewPos, viewPos + viewVector * 1000, entPos, <0, 0, 1> )

		if ( pointOnGroundPlane != null )
		{
			expect vector( pointOnGroundPlane )

			float minDist = 8.0

			if ( isMainWeapon )
				minDist = 32.0

			float dist = Distance( entPos, pointOnGroundPlane )

			if ( dist > minDist )
			{
				if ( lookingBelow )
					return false
			}
			else if ( isMainWeapon )
			{
				return true
			}
		}
	}

	vector pointOnLine = GetClosestPointOnLineSegment( topPos, botPos, pointOnLinePlane )

	float minDist = 14.0

	if ( Distance( pointOnLinePlane, pointOnLine ) > minDist )
		return false

	                                                           
	                                                                   
	return true


	                                      
	                                                                                                  
	                                                                        

	                        

	                                  
	  	            
	  
	                                  
	  	            
	  
	             

	  
	                                                    
	                                                                                                  

	                                                                            
	                                                         
	                                                                                   
	                                                                                 
	                                                                                   

	                                            
	 
		                     

		                      
			                                

		              
			                                

		              
			                                

		                                                   
		 
			           
		 
		                                      
		 
			            
		 
	 

	                                         
	                                           
	                                   
	                                         
	                                         

	                                                          
	                                           

	                                    

	                                       
		            

	                                                                                                               
	                                                                               

	                                
		            

	                                
		            

	           
	  
}
#endif


int function SortInventoryByLootTier( ConsumableInventoryItem item1, ConsumableInventoryItem item2 )
{
	int tier1 = 0
	if ( SURVIVAL_Loot_IsLootIndexValid( item1.type ) )
	{
		LootData data1 = SURVIVAL_Loot_GetLootDataByIndex( item1.type )
		tier1 = data1.tier
	}

	int tier2 = 0
	if ( SURVIVAL_Loot_IsLootIndexValid( item2.type ) )
	{
		LootData data2 = SURVIVAL_Loot_GetLootDataByIndex( item2.type )
		tier2 = data2.tier
	}

	                       
	if ( tier2 > tier1 )
		return 1
	else if ( tier2 < tier1 )
		return -1

	return 0
}


int function SortByLootTier( string ref1, string ref2 )
{
	int tier1 = 0
	if ( SURVIVAL_Loot_IsRefValid( ref1 ) )
	{
		LootData data1 = SURVIVAL_Loot_GetLootDataByRef( ref1 )
		tier1 = data1.tier
	}

	int tier2 = 0
	if ( SURVIVAL_Loot_IsRefValid( ref2 ) )
	{
		LootData data2 = SURVIVAL_Loot_GetLootDataByRef( ref2 )
		tier2 = data2.tier
	}

	                       
	if ( tier2 > tier1 )
		return 1
	else if ( tier2 < tier1 )
		return -1

	return 0
}


table<string, string> function GetAttachmentsWithToggleModsList()
{
	return file.attachmentsWithToggleMods
}


table< string, array<string> > function GetToggleModsRequiredAttachmentsList()
{
	return file.toggleModsRequiredAttachments
}


bool function ToggleModHasRequiredAttachments( string toggleMod, array<string> mods )
{
	if ( !(toggleMod in GetToggleModsRequiredAttachmentsList()) )                                                             
		return true

	array<string> attachmentMods = file.toggleModsRequiredAttachments[ toggleMod ]

	foreach ( string attachmentMod in attachmentMods )
	{
		if ( mods.contains( attachmentMod ) )
			return true
	}

	return false
}

                                                               
void function VerifyToggleMods( array<string> mods )
{
	array<string> attachmentMods
	bool foundAttachment
	array<string> modsCopy = clone mods
	foreach ( string mod in modsCopy )
	{
		if ( !ToggleModHasRequiredAttachments( mod, mods ) )
		{
			mods.fastremovebyvalue( mod )
		}
	}
}


array<string> function GetAltModsToRemoveOnCleanup()
{
	return file.altModsToRemoveOnDrop
}


void function CleanupAltMods( array<string> mods )
{
	array<string> modsCopy = clone mods
	foreach ( string mod in modsCopy )
	{
		if ( GetAltModsToRemoveOnCleanup().contains( mod ) )
			mods.fastremovebyvalue( mod )
	}
}

                                                               
void function ApplyDefaultToggledMods( string weaponClassName, string hopupMod, array<string> mods )
{
	if ( !(hopupMod in GetAttachmentsWithToggleModsList()) )
		return

	if ( !(weaponClassName in file.weaponAutoToggledAttachments) )
		return

	string hopupToToggle = file.weaponAutoToggledAttachments[weaponClassName]
	if ( hopupToToggle != hopupMod )
		return

	string toggleMod = file.attachmentsWithToggleMods[hopupMod]

	if ( !mods.contains( toggleMod ) )
		mods.append( toggleMod )
}

void function ReplaceOpticInMods( array<string> mods, string opticRef )
{
	bool replacedOptic = false
	for( int j = 0; j < mods.len(); ++j )
	{
		if( !SURVIVAL_Loot_IsRefValid( mods[j] ) )
			continue

		LootData attachData = SURVIVAL_Loot_GetLootDataByRef( mods[j] )
		if( attachData.attachmentStyle.find( "sight" ) >= 0 )
		{
			if( opticRef == "" )
				mods.remove( j )
			else
				mods[j] = opticRef

			replacedOptic = true
			break
		}
	}

	if( !replacedOptic && opticRef != "" )
		mods.append( opticRef )
}

int function SURVIVAL_GetPlayerShieldHealthFromArmor( entity player )
{
	                                                
	if ( player.GetShieldHealth() <= GetPlayerSettingBaseShield( player ) )
		return 0

	                                                        
	return player.GetShieldHealth() - GetPlayerSettingBaseShield( player )
}


int function SURVIVAL_GetArmorShieldCapacity( int tier )
{
	switch ( tier )
	{
		case 0:
			return 0

                             

         
            

         
            

         
         
            
     

		case 1:
			return 50

		case 2:
			return 75

		case 3:
		case 4:
			return 100
      
	}

	return 0
}

void function SURVIVAL_SetShieldHealthMaxOverrideCallback( int functionref( entity player, LootData data, int originalMax ) callback )
{
	file.shieldHealthMaxOverride = callback
}

int function SURVIVAL_GetCharacterShieldHealthMaxForArmor( entity player, LootData data )
{
	int shieldMaxHealth = 0
	if ( EvolvingArmor_IsEquipmentEvolvingArmor( data.ref ) )
	{
		shieldMaxHealth = EvolvingArmor_GetCharacterShieldHealthMaxForArmorTier( player, data.tier )
	}
	else
	{
		shieldMaxHealth = GetPlayerSettingBaseShield( player )
		int tier = data.tier

		switch ( tier )
		{
			case 0:
				shieldMaxHealth += 0
				break
                             

          
                         
         

          
                         
         

          
          
                         
         
     

			case 1:
				shieldMaxHealth += 50
				break

			case 2:
				shieldMaxHealth += 75
				break

			case 3:
			case 4:
				shieldMaxHealth += 100
				break
      

			default:
				Assert( 0, "Invalid armor tier: " + tier + ", data.ref: " + data.ref )
				shieldMaxHealth += 0
		}
	}

	if ( file.shieldHealthMaxOverride != null )
		shieldMaxHealth = file.shieldHealthMaxOverride( player, data, shieldMaxHealth )

	return shieldMaxHealth
}

const array<string> ALL_EVO_ARMOR_REFS = [
	"armor_pickup_lv0_evolving",
	"armor_pickup_lv1_evolving",
	"armor_pickup_lv2_evolving",
	"armor_pickup_lv3_evolving",
	"armor_pickup_lv5_evolving"
]

bool function EvolvingArmor_IsEquipmentEvolvingArmor( string itemRef )
{
	return ALL_EVO_ARMOR_REFS.contains( itemRef )
}

int function EvolvingArmor_GetCharacterShieldHealthMaxForArmorTier( entity player, int tier )
{
	int shieldMaxHealth = GetPlayerSettingBaseShield( player )

	switch ( tier )
	{
		case 0:
			shieldMaxHealth += 0
			break
                             

         
                        
        

         
                        
        

         
                        
        

         
         
                         
        
     

		case 1:
			shieldMaxHealth += 50
			break

		case 2:
			shieldMaxHealth += 75
			break

		case 3:
			shieldMaxHealth += 100
			break

		case 4:
		case 5:
			shieldMaxHealth += 125
			break
      

		default:
			Assert( 0, "Evolving Armor: Invalid armor tier" )
			shieldMaxHealth += 0
	}

	return shieldMaxHealth
}

int function EvolvingArmor_GetEvolvingArmorHealthForTier( int tier )
{
	switch ( tier )
	{
		case 0:
			return 0

                             

         
            

         
            

         
            

         
         
             
     

		case 1:
			return 50

		case 2:
			return 75

		case 3:
			return 100

		case 4:
		case 5:
			return 125
      
	}

	return 0
}

int function EvolvingArmor_GetRequirementForEvolution( int tier )
{
	switch ( tier )
	{
		case 0:
			return file.evoArmor_ReqDamage_Tier1

		case 1:
			return file.evoArmor_ReqDamage_Tier2

		case 2:
			return file.evoArmor_ReqDamage_Tier3

		case 3:
			return file.evoArmor_ReqDamage_Tier4

		default:
			return 0
	}

	return 0
}

bool function EvolvingArmor_ExceedsMaxIntLimit( LootData data )
{
	if ( EvolvingArmor_IsEquipmentEvolvingArmor( data.ref ) )
		return EvolvingArmor_GetRequirementForEvolution( data.tier ) > 512

	return false
}

int function EvolvingArmor_GetEvolutionProgress( entity player )
{
	Assert( IsValid( player ), "Attempted to get evo progress on invalid entity" )
	Assert( player.IsPlayer(), format( "Attempted to get player's Evo Progress, but entity %s is not a player!", string( player ) ) )

	#if SERVER
		                                 
	#endif

	if ( EvolvingArmor_ExceedsMaxIntLimit( EquipmentSlot_GetEquippedLootDataForSlot( player, "armor" ) ) )
		return player.GetPlayerNetInt( NV_EVOLVING_ARMOR_KILL_COUNT ) * 2

	return player.GetPlayerNetInt( NV_EVOLVING_ARMOR_KILL_COUNT )
}

#if SERVER
                                                                             
 
	                         
		      

	                                                                             

	                                    

	                                                                                                      
		                                                                                            
	    
		                                                              
 

                                                           
 
	                                                         
 


                                                                                                                                                                    
 
	                                                                  

	                                                                           
		      

	                       
		      

	                                        
		      

	                           
	                         
	 
		                                                       	                                                                                            
		 
			                                              
		 
		                                                                     
		 
			                     
			 
				                             
				 
					      
				 

				                                
				 
					                   
						                                             
						     
                        
                        
                                                   
           
           
                       
                       
                                                  
           
           
                              
					                         
						                                                  
						     
           
                           
					                   
						                                             
						     
           
					        
						                      
				 
			 
			                                                     
			 
				                                           
			 
		 
		                                                      
			      
	 

	                                                          
	                                              

	                             

                   
                                                          
                                                     
       

                               
		                                                                                  
			                                               
       

                    
                                                                          
                                                                 
       

	                                                            
	                                                       
 

                                                                       
 
	                                                                                
	                                                         
		      

	                                                               
		      

	                                            
	                                                                                   
	                                                              

	                                                                                                                                            

	                                                                     

	                                                     

	                                                                     

	                                        
	 
		                           
		                  
		                   
			                                         
		    
			                                                       

		                                                                  
		                                                                                                 
		                                                 
		                                                                                       
		                                                          
		                                            
	 
 

                                               
                                                                                              
 
	                                            
	                                             
	 
		                         
			        

		                           
		  	        

		                              
			        

		                                     
		                                                                     
			                                                                                              
	 

	                                             
	 
		                                                                             
	 


	                      
	 
		       
			                                                                                           
			                                                                                             
			     

		       
			                                                                                           
			                                                                                             
			     

		       
			                                                                                           
			                                                                                             
			     
	 
 
#endif         

#if CLIENT
void function ServerCallback_PlayFPEvoShieldUpgradeFX( entity player )
{
	if ( !IsValid( player ) )
		return

	EvolvingArmor_SetEvolutionRuiAnimTime()

	int armorTier      = maxint( 1, EquipmentSlot_GetEquipmentTier( GetLocalViewPlayer(), "armor" ) )
	vector shieldColor = GetFXRarityColorForTier( armorTier )

	entity cockpit = player.GetCockpit()
	if ( !cockpit )
		return

	int fxHandle = StartParticleEffectOnEntity( cockpit, file.evoShieldUpgradeFXFP, FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID )

	EffectSetIsWithCockpit( fxHandle, true )
	EffectSetControlPointVector( fxHandle, 1, shieldColor )
}

void function ServerCallback_Play3PEvoShieldUpgradeFX( entity player )
{
	if ( !IsValid( player ) )
		return

	if ( player == GetLocalClientPlayer() )
		return

	if ( !player.DoesShareRealms( GetLocalClientPlayer() ) )
		return

	int armorTier = EquipmentSlot_GetEquipmentTier( player, "armor" )

	if ( armorTier == 0 )
		return

	vector shieldColor = GetFXRarityColorForTier( armorTier )

	int attachID         = player.LookupAttachment( "CHESTFOCUS" )
	int shield3pFXHandle = StartParticleEffectOnEntity( player, file.evoShieldUpgradeFX3P, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shield3pFXHandle, 1, shieldColor )
}
#endif         

int function SortByPriorityThenTier( ConsumableInventoryItem a, ConsumableInventoryItem b )
{
	LootData lootData_a = SURVIVAL_Loot_GetLootDataByIndex( a.type )
	LootData lootData_b = SURVIVAL_Loot_GetLootDataByIndex( b.type )

	int aPriority = GetPriorityForLootType( lootData_a )
	int bPriority = GetPriorityForLootType( lootData_b )

	if ( aPriority < bPriority )
		return -1
	else if ( aPriority > bPriority )
		return 1

	if ( lootData_a.lootType < lootData_b.lootType )
		return -1
	if ( lootData_a.lootType > lootData_b.lootType )
		return 1

	if ( lootData_a.tier > lootData_b.tier )
		return -1
	if ( lootData_a.tier < lootData_b.tier )
		return 1

	if ( lootData_a.index > lootData_b.index )
		return -1
	if ( lootData_a.index < lootData_b.index )
		return 1

	if ( a.count > b.count )
		return -1
	if ( a.count < b.count )
		return 1

	return 0
}


int function GetPriorityForLootType( LootData lootData )
{
	switch ( lootData.lootType )
	{
		case eLootType.ATTACHMENT:
			return eLootSortCategories.ATTACHMENTS

		case eLootType.ORDNANCE:
		case eLootType.HEALTH:
                       

                            
      
                       

                                 
                             
			return eLootSortCategories.CONSUMABLES

		case eLootType.CUSTOMPICKUP:
                      
		case eLootType.DATAKNIFE:
      
                  
		case eLootType.SHIPKEYCARD:
      
                   

		case eLootType.MARVIN_ARM:
      
			return eLootSortCategories.SPECIAL

		case eLootType.HELMET:
		case eLootType.ARMOR:
		case eLootType.JUMPKIT:
		case eLootType.INCAPSHIELD:
		case eLootType.BACKPACK:
			return eLootSortCategories.EQUIPMENT

		case eLootType.MAINWEAPON:
			return eLootSortCategories.WEAPONS

		case eLootType.AMMO:
			return eLootSortCategories.AMMO

		case eLootType.LOCKBOX:
			return eLootSortCategories.PVE

                    

                             
                          

		case eLootType.RESOURCE:
			return eLootSortCategories.DEFAULT

		default:
			return eLootSortCategories.DEFAULT
			break
	}

	unreachable
}


string function GetCategoryTitleFromPriority( int cat )
{
	table<int, string> catToTitle = {}
	catToTitle[ eLootSortCategories.SPECIAL ] <- "#LOOT_CAT_SPECIAL"
	catToTitle[ eLootSortCategories.CONSUMABLES ] <- "#LOOT_CAT_CONSUMABLE"
	catToTitle[ eLootSortCategories.ATTACHMENTS ] <- "#LOOT_CAT_ATTACHMENTS"
	catToTitle[ eLootSortCategories.EQUIPMENT ] <- "#LOOT_CAT_EQUIPMENT"
	catToTitle[ eLootSortCategories.AMMO ] <- "#LOOT_CAT_AMMO"
	catToTitle[ eLootSortCategories.WEAPONS ] <- "#LOOT_CAT_MAINWEAPON"
	catToTitle[ eLootSortCategories.PVE ] <- "#LOOT_CAT_PVE"
	catToTitle[ eLootSortCategories.DEFAULT ] <- ""

	return catToTitle[ cat ]
}


string function GetStringForTagId( int tagId )
{
	switch ( tagId )
	{
		case eAttachmentTag.BARREL:
			return "#TAG_BARREL"

		case eAttachmentTag.SNIPER:
			return "#TAG_SNIPER"

		case eAttachmentTag.ASSAULT:
			return "#TAG_ASSAULT"

		case eAttachmentTag.PISTOL:
			return "#TAG_PISTOL"

		case eAttachmentTag.ALL:
			return "#TAG_ALL"

		case eAttachmentTag.LMG:
			return "#TAG_LMG"

		case eAttachmentTag.SHOTGUN:
			return "#TAG_SHOTGUN"

		case eAttachmentTag.SMG:
			return "#TAG_SMG"

		case eAttachmentTag.LAUNCHER:
			return "#TAG_LAUNCHER"

		case eAttachmentTag.MARKSMAN:
			return "#TAG_MARKSMAN"

		default:
			Assert( false )
	}

	unreachable
}


#if CLIENT || SERVER
table<string, string> function GetCompatibleAttachmentsFromWeapon( entity player, entity fromWeapon, string toWeapon )
{
	array<string> modsOnWeapon            = GetValidLootModsInstalled( fromWeapon )
	array<string> filledInAttachmentSlots = []

	modsOnWeapon.sort( SortByLootTier )

	table<string, string> compatibleAttachmentMap

	foreach ( item in modsOnWeapon )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByRef( item )
		Assert( data.lootType == eLootType.ATTACHMENT, data.lootType )

		string attachPoint = GetAttachPointForAttachmentOnWeapon( toWeapon, item )
		if ( CanAttachToWeapon( item, toWeapon ) && !filledInAttachmentSlots.contains( attachPoint ) )
		{
			filledInAttachmentSlots.append( attachPoint )
			compatibleAttachmentMap[attachPoint] <- item
		}
	}

	return compatibleAttachmentMap
}


table<string, string> function GetCompatibleAttachmentsFromInventory( entity player, string toWeapon )
{
	array<ConsumableInventoryItem> playerInventory = SURVIVAL_GetPlayerInventory( player )
	array<string> filledInAttachmentSlots          = []

	playerInventory.sort( SortInventoryByLootTier )
	table<string, string> compatibleAttachmentMap

	foreach ( item in playerInventory )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByIndex( item.type )
		if ( data.lootType != eLootType.ATTACHMENT )
			continue

		string attachPoint = GetAttachPointForAttachmentOnWeapon( toWeapon, data.ref )
		if ( CanAttachToWeapon( data.ref, toWeapon ) && !filledInAttachmentSlots.contains( attachPoint ) )
		{
			filledInAttachmentSlots.append( attachPoint )
			compatibleAttachmentMap[attachPoint] <- data.ref
		}
	}

	return compatibleAttachmentMap
}

table<string, string> function GetCompatibleAttachmentMap( entity player, entity fromWeapon, string toWeapon, bool includeInventory = false )
{
	table<string, string> weaponAttachments = GetCompatibleAttachmentsFromWeapon( player, fromWeapon, toWeapon )
	table<string, string> inventoryAttachments
	if ( includeInventory )
		inventoryAttachments = GetCompatibleAttachmentsFromInventory( player, toWeapon )

	LootData toWeaponData = SURVIVAL_Loot_GetLootDataByRef( toWeapon )
	table<string, string> attachmentMap
	foreach ( attachPoint in toWeaponData.supportedAttachments )
	{
		attachmentMap[attachPoint] <- ""
		if ( attachPoint in weaponAttachments )
			attachmentMap[attachPoint] = weaponAttachments[attachPoint]
		else if ( attachPoint in inventoryAttachments )
			attachmentMap[attachPoint] = inventoryAttachments[attachPoint]
	}

	return attachmentMap
}
#endif
bool function IsAmmoInUse( entity player, string ref )
{
	LootData ammoData = SURVIVAL_Loot_GetLootDataByRef( ref )
	if ( ammoData.lootType != eLootType.AMMO )
		return false

	foreach ( weapon in SURVIVAL_GetPrimaryWeapons( player ) )
	{
		string className = weapon.GetWeaponClassName()
		if ( SURVIVAL_Loot_IsRefValid( className ) )
		{
			LootData data = SURVIVAL_Loot_GetLootDataByRef( className )
			if ( data.ammoType == ref || data.secondaryAmmoType == ref)
				return true
		}
	}

                  
                                                                             
                                             
   
                                                                                     
                                                              
               
   
       

	return false
}

                                                                                
                                                                                                              
void function SetPlayerRequireLootType( entity player, string ref )
{
	if ( ref in player.p.requiredLootTypes )
		player.p.requiredLootTypes[ ref ] += 1
	else
		player.p.requiredLootTypes[ ref ] <- 1
}


void function ResetPlayerRequireLootTypes( entity player )
{
	player.p.requiredLootTypes = {}
}


void function DeathBoxThink( entity ent, entity playerUser )
{
	#if SERVER
		                            
	#else
		ExtendedUseSettings settings = DeathBoxGetExtendedUseSettings( ent, playerUser )
	#endif

	settings.duration = 0.3
	settings.requireMatchingUseEnt = true

	ent.EndSignal( "OnDestroy" )

	waitthread ExtendedUse( ent, playerUser, settings )
}


bool function ShouldPickupDNAFromDeathBox( entity ent, entity player )
{
	if ( ent.GetTeam() != TEAM_UNASSIGNED )
	{
		if ( ent.GetTeam() == player.GetTeam() && IsValid( ent.GetOwner() ) )
			return true
	}

                   
                                                  
             
      
	return false
}


void function OnDeathBoxUse( entity box, entity player, int useInputFlags )
{
                 
                                                                           
        
       

	if ( ShouldUseAltInteractForArmorSwap() && useInputFlags & USE_INPUT_ALT )
	{
		entity ornull armorEnt = GetDeathboxArmorSwap( player, box )
		if ( armorEnt != null )
		{
			expect entity( armorEnt )
			Survival_PickupItem( armorEnt, player, 0, box )
		}
		return
	}

	if ( useInputFlags & USE_INPUT_LONG )
	{
		if ( ShouldPickupDNAFromDeathBox( box, player ) )
			return

		if ( box.GetLinkEntArray().len() == 0 )
			return

		thread DeathBoxThink( box, player )
	}
}


array<entity> function GetAllDeathBoxes()
{
	#if SERVER
		                                                                    
	#elseif CLIENT
		return file.allDeathBoxes
	#endif
}

void function DestroyAllDeathBoxes()
{
	foreach ( entity deathBox in GetAllDeathBoxes() )
		deathBox.Destroy()
}


#if SERVER
                                    
 
	                                        
 
#endif


void function OnDeathBoxCreated( entity ent )
{
	if ( ent.GetTargetName() != DEATH_BOX_TARGETNAME )
		return

	#if SERVER
		                                                                    
	#elseif CLIENT
		file.allDeathBoxes.append( ent )
	#endif

	SetCallback_CanUseEntityCallback( ent, DeathBox_CanUseFunction )
	SetCallback_ShouldUseBlockReloadCallback( ent, DeathBox_ShouldUseBlockReload )


	AddCallback_OnUseEntity_ClientServer( ent, OnDeathBoxUse )
}


void function OnDeathBoxDestroyed( entity ent )
{
	#if CLIENT
		file.allDeathBoxes.fastremovebyvalue( ent )
	#endif
}


bool function DeathBox_CanUseFunction( entity player, entity ent, int useFlags )
{
	if ( IsPVEMode() && (GetRespawnStyle() == eRespawnStyle.NONE) )
	{
		if ( IsValid( ent.GetOwner() ) && (player != ent.GetOwner()) )
			return false
	}

	if ( GetGameState() > eGameState.Playing )
		return false

	if ( !SURVIVAL_PlayerAllowedToPickup( player ) )
		return false

	if ( ent.GetTeam() != TEAM_UNASSIGNED )
	{
		if ( ent.GetTeam() == player.GetTeam() )
			return true
	}

	return ent.GetLinkEntArray().len() > 0
}

bool function DeathBox_ShouldUseBlockReload( entity player, entity ent )
{
	                                             
	if ( IsPlayingFirstPersonAnimation( player ) )
	{
		return true
	}
	return false
}


void function OnUseSurvivalPickup( entity pickup, entity player, int useInputFlags )
{
	if ( !SURVIVAL_CanPlayerPickup( player, pickup, useInputFlags ) )
		return

	if ( !SURVIVAL_Loot_IsLootIndexValid( pickup.GetSurvivalInt() ) )
		return

	LootData data = SURVIVAL_Loot_GetLootDataByIndex( pickup.GetSurvivalInt() )
	int lootType  = data.lootType

	bool pickedUp = false

	if ( useInputFlags & USE_INPUT_ALT )
		pickedUp = Survival_PickupItem( pickup, player, PICKUP_FLAG_ALT )
	else if ( useInputFlags & USE_INPUT_DEFAULT )
		pickedUp = Survival_PickupItem( pickup, player )

	if ( pickedUp )
		return

	if ( useInputFlags & USE_INPUT_LONG )
		pickedUp = Survival_PickupItem( pickup, player, PICKUP_FLAG_LONG )
}


bool function Survival_PickupItem( entity pickup, entity player, int pickupFlags = 0, entity deathBox = null, int ornull desiredCount = null, LootActionStruct ornull forcedAction = null )
{
	if ( !IsValid( pickup ) )
		return false

	if ( !SURVIVAL_Loot_IsLootIndexValid( pickup.GetSurvivalInt() ) )
		return false

	LootData data   = SURVIVAL_Loot_GetLootDataByIndex( pickup.GetSurvivalInt() )
	LootTypeData lt = GetLootTypeData( data.lootType )
	LootActionStruct as
	LootRef lootRef = SURVIVAL_CreateLootRef( data, pickup )
	bool useAlt     = (pickupFlags & PICKUP_FLAG_ALT) > 0
	bool useLong    = (pickupFlags & PICKUP_FLAG_LONG) > 0

	if ( forcedAction == null )
		as = SURVIVAL_GetActionForGroundItem( player, lootRef, useAlt, useLong )
	else
		as = expect LootActionStruct( forcedAction )

	int pickupCount    = pickup.GetClipCount()
	bool shouldDestroy = SURVIVAL_ApplyLootAction( as.action, pickup, player, pickupFlags, deathBox, desiredCount )
	int newPickupCount = pickup.GetClipCount()

	int unitsPickedUp = pickupCount - newPickupCount
	if ( lootRef.lootData.lootType == eLootType.MAINWEAPON )
		unitsPickedUp = (shouldDestroy ? 1 : 0)
	bool pickedUpAnything = unitsPickedUp > 0

	#if CLIENT
		if ( (Time() - pickup.e.lastUseTime) > 0.5 )
		{
			SURVIVAL_Loot_UpdateRuiLastUseTime( pickup )

			if ( shouldDestroy )
			{
				PlayLootPickupFeedbackFX( pickup )
				pickup.e.predictedUseSuccess = true
			}
			else
			{
				switch ( as.action )
				{
					case eLootAction.PICKUP:
						if( GetGameState() != eGameState.Prematch || !GetCurrentPlaylistVarBool( "hide_inventory_counter_in_prematch", false ) )
							UpdateInventoryCounter( player, data.ref, true )

					case eLootAction.SWAP:
						EmitSoundOnEntity( player, SFX_BACKPACK_FULL )
						break

					default:
						EmitSoundOnEntity( player, SFX_CANNOT_USE )
				}

				pickup.e.predictedUseSuccess = false
			}

			pickup.e.lastUseTime = Time()
		}
	#elseif SERVER
		                                        
		 
			       
				                                              
				 
					                                                              
				 
			      
			                                                                                                              
		 
	#endif

	return pickedUpAnything
}


LootData function SURVIVAL_GetLootDataFromWeapon( entity weapon )
{
	string ref = IsValid( weapon ) ? GetWeaponClassNameWithLockedSet( weapon ) : ""
	if ( SURVIVAL_Loot_IsRefValid( ref ) )
		return SURVIVAL_Loot_GetLootDataByRef( ref )

	LootData blank
	return blank
}


bool function SURVIVAL_Weapon_IsAttachmentLocked( string weaponName )
{
                        
		if( IsArenaMode() )
			return true
       

	if ( !SURVIVAL_Loot_IsRefValid( weaponName ) )
		return false
	array<string> baseMods = SURVIVAL_Loot_GetLootDataByRef( weaponName ).baseMods
	array<string> lootTags = SURVIVAL_Loot_GetLootDataByRef( weaponName ).lootTags
	if ( baseMods.contains( WEAPON_LOCKEDSET_MOD_CRATE ) )
		return true
                                 
                                                             
              
       
	if ( lootTags.contains( WEAPON_LOCKEDSET_MOD_GOLD ) )
		return true
	if ( lootTags.contains( WEAPON_LOCKEDSET_MOD_WHITESET ) )
		return true
	if ( lootTags.contains( WEAPON_LOCKEDSET_MOD_BLUESET ) )
		return true
	if ( lootTags.contains( WEAPON_LOCKEDSET_MOD_PURPLESET ) )
		return true
	if ( baseMods.contains( WEAPON_LOCKEDSET_MOD_PURPLEPAINTBALL ) )
		return true
	if ( baseMods.contains( WEAPON_LOCKEDSET_MOD_BLUEPAINTBALL ) )
		return true
	if ( baseMods.contains( WEAPON_LOCKEDSET_MOD_GOLDPAINTBALL ) )
		return true


	return false
}


bool function SURVIVAL_IsAttachmentPointLocked( string weaponName, string attachmentPoint )
{
                        
		if( IsArenaMode() )
			return true
       

	if ( SURVIVAL_Weapon_IsAttachmentLocked( weaponName ) && attachmentPoint != "sight" )
		return true

	return false
}


bool function SURVIVAL_Weapon_IsFullyKitted( string weaponName )
{
	if ( !SURVIVAL_Loot_IsRefValid( weaponName ) )
		return false
	return SURVIVAL_Loot_GetLootDataByRef( weaponName ).lootTags.contains( WEAPON_LOCKEDSET_MOD_GOLD )
}


array<string> function SURVIVAL_Weapon_GetBaseMods( string weaponName )
{
	return clone(SURVIVAL_Loot_GetLootDataByRef( weaponName ).baseMods)
}


bool function IsValidAttachment( string attachment )
{
	return (attachment in file.attachmentMatrix)
}


AttachmentData function GetAttachmentData( string attachment )
{
	return file.attachmentMatrix[ attachment ]
}


int function SURVIVAL_GetInventorySlotCountForPlayer( entity player, LootData data )
{
	int result = data.inventorySlotCount
                   
                                                                                  
                                                                  
                                        
       

	                                                
	if ( data.lootType == eLootType.ORDNANCE )
	{
		result += GetCurrentPlaylistVarInt( "boost_ordnance_stack_size", 0 )
		if ( PlayerHasPassive( player, ePassives.PAS_FUSE ) )
			result++
	}
	else if ( data.lootType == eLootType.AMMO )
	{
                     
                                                                        
    
                                       
    
        
	}
	else if ( data.lootType == eLootType.HEALTH )
	{
		if ( PlayerHasPassive( player, ePassives.PAS_BATTERY_POWERED ) && data.ref == "health_pickup_ultimate" )
		{
			result += Pas_GetWattsonUltAccelExtraCount()
		}
                      
		if ( PlayerHasPassive( player, ePassives.PAS_EXTRA_MED_INV ) )
		{
			if ( data.ref == "health_pickup_health_large" || data.ref == "health_pickup_combo_large" || data.ref == "health_pickup_combo_full" )
				result++
		}
      
	}

	return result
}


#if SERVER
                                                                                      
 
	                                                                                                                                                                                      
 
#endif


#if SERVER
                                                                       
 
	                                                                                                        
 
#endif


#if SERVER
                                                                         
 
	                                                                                                         
 
#endif


#if SERVER || CLIENT
bool function PropSurvivalFlagsHas( entity ent, int propSurvivalFlags )
{
	return ((GetPropSurvivalFlagsPropertyFromEnt( ent ) & propSurvivalFlags) != 0)
}
#endif


#if SERVER || CLIENT
const int PROP_SURVIVAL_SURVIVAL_PROPERTY_MAIN_PROPERTY_BITS = 14                                                                                                          
const int PROP_SURVIVAL_SURVIVAL_PROPERTY_EXTRA_PROPERTY_BITS = 9
const int PROP_SURVIVAL_SURVIVAL_PROPERTY_FLAGS_PROPERTY_BITS = 1
Assert( PROP_SURVIVAL_SURVIVAL_PROPERTY_MAIN_PROPERTY_BITS + PROP_SURVIVAL_SURVIVAL_PROPERTY_EXTRA_PROPERTY_BITS + PROP_SURVIVAL_SURVIVAL_PROPERTY_FLAGS_PROPERTY_BITS <= 31 )
#endif


#if SERVER || CLIENT
int function GetPropSurvivalMainProperty( int prop )
{
	int offset     = 0
	int enoughBits = (1 << PROP_SURVIVAL_SURVIVAL_PROPERTY_MAIN_PROPERTY_BITS) - 1
	return (prop >> offset) & enoughBits
}
#endif


#if SERVER || CLIENT
int function GetPropSurvivalExtraProperty( int prop )
{
	int offset     = PROP_SURVIVAL_SURVIVAL_PROPERTY_MAIN_PROPERTY_BITS
	int enoughBits = (1 << PROP_SURVIVAL_SURVIVAL_PROPERTY_EXTRA_PROPERTY_BITS) - 1
	return (prop >> offset) & enoughBits
}
#endif


#if SERVER || CLIENT
int function GetPropSurvivalFlagsProperty( int prop )
{
	int offset     = PROP_SURVIVAL_SURVIVAL_PROPERTY_MAIN_PROPERTY_BITS + PROP_SURVIVAL_SURVIVAL_PROPERTY_EXTRA_PROPERTY_BITS
	int enoughBits = (1 << PROP_SURVIVAL_SURVIVAL_PROPERTY_FLAGS_PROPERTY_BITS) - 1
	return (prop >> offset) & enoughBits
}
#endif


#if SERVER || CLIENT
int function GetPropSurvivalMainPropertyFromEnt( entity ent )
{
	return GetPropSurvivalMainProperty( ent.GetSurvivalProperty() )
}
#endif


#if SERVER || CLIENT
int function GetPropSurvivalExtraPropertyFromEnt( entity ent )
{
	int val = GetPropSurvivalExtraProperty( ent.GetSurvivalProperty() )

	LootData data = SURVIVAL_Loot_GetLootDataByIndex( ent.GetSurvivalInt() )
	if ( data.lootType == eLootType.ARMOR )
	{
		if ( EvolvingArmor_IsEquipmentEvolvingArmor( data.ref ) )
		{
			if ( EvolvingArmor_ExceedsMaxIntLimit( data ) )
			{
				val *= 2
			}
		}
	}

	return val
}
#endif


#if SERVER || CLIENT
int function GetPropSurvivalFlagsPropertyFromEnt( entity ent )
{
	return GetPropSurvivalFlagsProperty( ent.GetSurvivalProperty() )
}
#endif


#if SERVER
                                                             
 
	                                                                                     
	                  
	                                                                              
	                                     
	                                       
 
#endif


#if SERVER
                                                                
 
	               
	                                                                                      
	                                                                   
	                                                                               
	                                     
	                                       
 
#endif


#if SERVER
                                                              
 
	                                                                                      
	                                                                                                                         
	                                                                               
	                                     
	                                       
 
#endif


#if SERVER
                                                                     
 
	                                                                                        
 
#endif


#if SERVER
                                                                        
 
	               

	                                                                        
	                                       
	 
		                                                         
		 
			                                               
			 
				               
			 
		 
	 

	                                                                                         
 
#endif


#if SERVER
                                                                      
 
	                                                                                         
 
#endif


#if SERVER || CLIENT
bool function IsValidAndStandardGrabbableLootEnt( entity lootEnt )
{
	if ( !IsValid( lootEnt ) )
		return false

	if ( lootEnt.GetNetworkedClassName() != "prop_survival" )
		return false

	return true
}
#endif


#if SERVER || CLIENT
bool function IsValidAndUsableDeathBoxEnt( entity deathBox )
{
	if ( !IsValid( deathBox ) )
		return false

	if ( deathBox.GetNetworkedClassName() == "prop_death_box" )
		return true
	else if ( deathBox.GetNetworkedClassName() == "prop_loot_grabber" )
		return true                                    

	return false
}
#endif

#if SERVER || CLIENT
bool function IsPlayerCloseEnoughToDeathBoxToLoot( entity player, entity deathBox )
{
	if ( !IsValidAndUsableDeathBoxEnt( deathBox ) )
		return false

	return DistanceSqr( player.GetOrigin(), deathBox.GetOrigin() ) <= ( DEATH_BOX_MAX_DIST * DEATH_BOX_MAX_DIST )
}
#endif


#if SERVER || CLIENT
array<entity> function GetDeathBoxLootEnts( entity deathBox )
{
	if ( deathBox.GetNetworkedClassName() == "prop_death_box" )
	{
		return deathBox.GetLinkEntArray()
	}
	else if ( deathBox.GetNetworkedClassName() == "prop_loot_grabber" )
	{
		vector deathBoxOrigin = deathBox.GetOrigin()
		float radius          = GetBlackMarketNearbyLootRadius()

		array<entity> lootEnts = GetSurvivalLootNearbyPos( deathBoxOrigin, radius, false, false, false, deathBox )

		#if SERVER
			                                                                                                                                 
		#elseif CLIENT
			array<entity> nearbyDeathBoxes = ArrayWithin( GetAllDeathBoxes(), deathBoxOrigin, radius )
		#endif
		foreach ( entity nearbyDeathBox in nearbyDeathBoxes )
			lootEnts.extend( GetDeathBoxLootEnts( nearbyDeathBox ) )
		return lootEnts
	}

	Assert( false, "Unhandled death box class: " + string(deathBox.GetNetworkedClassName()) )
	return []
}
#endif

#if SERVER
                                                                            
 
	                               
	                                   
	                                   

	                                                                                                                         
		                          

	                                                                          
	                                             
	 
		                             
	 
	                                              
	 
		                          
		                                                 
	 

	                           
	                             
	 
		                                                                  
		                                                           
		                                                                                                                             
		                                                                                                                                               
		                                                     
			                                                        
	 
	                               
	 
		                                                                     
	 

	                         
	 
		                                      
		 
			                                                                                
			                                                                                

			                                                                             
				                                             
		 
	 
	    
	 
		                                            
	 

	                          
 
#endif


#if SERVER || CLIENT
bool function IsLootEntAccessibleViaDeathBox( entity lootEnt, entity deathBox )
{
	Assert( lootEnt.GetNetworkedClassName() == "prop_survival" )

	if ( deathBox.GetNetworkedClassName() == "prop_death_box" )
	{
		#if SERVER
			                                        
		#elseif CLIENT
			return deathBox.GetLinkEntArray().contains( lootEnt )
		#endif
	}
	else if ( deathBox.GetNetworkedClassName() == "prop_loot_grabber" )
	{
		vector deathBoxOrigin = deathBox.GetOrigin()
		float radius          = GetBlackMarketNearbyLootRadius()

		if ( DistanceSqr( lootEnt.GetOrigin(), deathBoxOrigin ) <= radius * radius && lootEnt.DoesShareRealms( deathBox ) )
			return true

		#if SERVER
			                                                                                                                                 
		#elseif CLIENT
			array<entity> nearbyDeathBoxes = ArrayWithin( GetAllDeathBoxes(), deathBoxOrigin, radius )
		#endif
		foreach ( entity nearbyDeathBox in nearbyDeathBoxes )
		{
			if ( IsLootEntAccessibleViaDeathBox( lootEnt, nearbyDeathBox ) )
				return true
		}

		return false
	}

	Assert( false, "Unhandled death box class: " + string(deathBox.GetNetworkedClassName()) )
	return false
}
#endif


#if SERVER || CLIENT
bool function IsLootEntInsideDeathBox( entity lootEnt )
{
	Assert( lootEnt.GetNetworkedClassName() == "prop_survival" )

	if ( !IsValid( lootEnt ) )
		return false

	entity lootEntParent = lootEnt.GetParent()

	if ( !IsValid( lootEntParent ) )
		return false

	if ( lootEntParent.GetNetworkedClassName() != "prop_death_box" )
	{
		return false
	}

	array<entity> boxLinkedEnts = lootEntParent.GetLinkEntArray()	                                                                                                                             
	if ( boxLinkedEnts.contains( lootEnt ) )
		return true
	else
		return false

	unreachable
}
#endif


#if SERVER || CLIENT
bool function DoesDeathBoxSupportAddingLoot( entity deathBox )
{
	return (deathBox.GetNetworkedClassName() == "prop_death_box")                         
}
#endif


#if SERVER || CLIENT
float function GetFadeDistForLoot( LootData lootData )
{
	switch ( lootData.lootType )
	{
		case eLootType.MAINWEAPON:
			return 15000.0

		case eLootType.BACKPACK:
		case eLootType.HELMET:
		case eLootType.ARMOR:
			if ( lootData.tier > 1 )
				return 5000.0
			else
				return 2000.0

		case eLootType.HEALTH:
			if ( lootData.tier > 1 )
				return 5000.0
			else
				return 2000.0
	}

	return 2000.0
}

bool function SURVIVAL_EquipmentPretendsToBeBlank( string ref )
{
	if ( !SURVIVAL_Loot_IsRefValid( ref ) )
		return false

	LootData data = SURVIVAL_Loot_GetLootDataByRef( ref )
	return data.pretendsToBeBlank
}

bool function ShouldUseAltInteractForArmorSwap()
{
	return file.useAltInteractForArmorSwap
}

entity ornull function GetDeathboxArmorSwap( entity player, entity box )
{
	array<entity> items = GetDeathBoxLootEnts( box )
	foreach ( int idx, entity item in items )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByIndex( item.GetSurvivalInt() )
		  
		if ( data.lootType == eLootType.ARMOR )
		{
			int currentShields  = SURVIVAL_GetPlayerShieldHealthFromArmor( player )
			int lootShields     = GetPropSurvivalMainPropertyFromEnt( item )

			bool isEvoProgressUpgrade = false
			  
			                                                        
			                                                                       

			                                                                     
			                                                                 
			                                                                                        
			                                                           
			  

			if( lootShields > currentShields || lootShields == currentShields && isEvoProgressUpgrade )
				return item
			else
				return null
		}
	}

	return null
}
#endif

#if DEV && CLIENT
void function DEV_PrintAllLootRefsWithNames()
{
	array<string> pickupString   = []
	array<string> tier           = []
	array<string> ref            = []
	array<string> type			 = []

	int pickupStringLen   = 0
	int tierLen           = 0
	int refLen            = 0
	int typeLen           = 0

	printt( "-------------- ALL LOOT --------------" )
	foreach ( string name, LootData data in SURVIVAL_Loot_GetLootDataTable() )
	{
		if ( name == "blank" )
			continue

		string _pickupString = Localize( data.pickupString )
		string _type         = GetEnumString( "eLootType", data.lootType )                                                                  
		string _tier = ""
		switch ( data.tier )
		{
			case 1:
				_tier = "WHITE"
				break
			case 2:
				_tier = "BLUE"
				break
			case 3:
				_tier = "PURPLE"
				break
			case 4:
				_tier = "GOLD"
				break
			case 5:
				_tier = "RED"
				break
			default:
				_tier = "NONE"
		}
		string _ref			 = name

		ref.append( _ref )
		pickupString.append( _pickupString )
		tier.append( _tier )
		type.append( _type )

		if ( _ref.len() > refLen )
			refLen = _ref.len()
		if ( _pickupString.len() > pickupStringLen )
			pickupStringLen = _pickupString.len()
		if ( _tier.len() > tierLen )
			tierLen = _tier.len()
		if ( _type.len() > typeLen )
			typeLen = _type.len()
	}

	Assert( type.len() == ref.len() && pickupString.len() == ref.len() && type.len() == ref.len() )

	ref.insert( 0, "LOOT REF" )
	pickupString.insert( 0, "GAME NAME" )
	type.insert( 0, "TYPE" )
	tier.insert( 0, "TIER" )

	for ( int i = 0 ; i < ref.len() ; i++ )
	{
		string _ref            = ref[i]
		string _pickupString   = pickupString[i]
		string _tier           = tier[i]
		string _type           = type[i]

		while( _ref.len() < refLen )
			_ref += " "
		while( _pickupString.len() < pickupStringLen )
			_pickupString += " "
		while( _tier.len() < tierLen )
			_tier += " "
		while( _type.len() < typeLen )
			_type += " "

		printl( format( "%s  %s  %s  %s", _pickupString, _ref, _tier, _type ) )
	}

	printt( "-------------- END LOOT --------------" )
}
#endif
