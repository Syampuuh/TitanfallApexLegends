//

#if(false)

#endif

globalize_all_functions

global const ANALYSIS_PREVIEW_TIME = 5.0

#if(false)



#endif //

struct AirdropBadPlace
{
	int    id
	vector origin
	int    radius
	entity ownerEnt
}

struct
{
	array<AirdropBadPlace> airdropBadPlaceArray
	int                    airdropBadPlaceCount
} file

vector function GetOriginFromAttachPoint( AttachPoint point, vector origin, vector forward, vector right )
{
	origin += forward * point.origin.x
	origin += right * -point.origin.y
	origin += <0, 0, point.origin.z>
	return origin
}


vector function GetOriginFromPoint( Point point, vector origin, vector forward, vector right )
{
	origin += forward * point.origin.x
	origin += right * -point.origin.y
	origin += <0, 0, point.origin.z>
	return origin
}


vector function GetAnglesFromAttachPoint( AttachPoint point, vector angles )
{
	return AnglesCompose( angles, point.angles )
}


vector function GetAnglesFromPoint( Point point, vector angles )
{
	return AnglesCompose( angles, point.angles )
}


array<vector> function GetFlightPathPoints( FlightPath flightPath, vector origin, vector forward, vector right )
{
	array<vector> orgs = []
	for ( int i = 0; i < flightPath.points.len(); i++ )
	{
		AttachPoint point  = flightPath.points[i]
		vector foundOrigin = GetOriginFromAttachPoint( point, origin, forward, right )

		orgs.append( foundOrigin )
	}

	return orgs
}

#if(false)
















#endif //

bool function IsLegalFlightPath( FlightPath flightPath, vector origin, vector forward, vector right, bool draw = false )
{
	array<vector> orgs = GetFlightPathPoints( flightPath, origin, forward, right )

	vector endPos = orgs[ orgs.len() - 1 ]

	DoTraceCoordCheck( false )

	for ( int i = 1; i < orgs.len(); i++ )
	{
		TraceResults result = TraceHull( orgs[i - 1], orgs[i], flightPath.mins, flightPath.maxs, null, flightPath.traceMask, TRACE_COLLISION_GROUP_NONE )
		if ( result.fraction < 1 )
		{
			if ( result.hitSky )
			{
				//
				continue
			}

			if ( Distance( result.endPos, endPos ) > 16 )
			{
				//
				//

				DoTraceCoordCheck( true )
				return false
			}
		}

		//
		//
	}

	//
	DoTraceCoordCheck( true )
	return true
}


bool function IsLegalFlightPath_OverTime( FlightPath flightPath, vector origin, vector forward, vector right, bool draw = false )
{
	array<vector> orgs = GetFlightPathPoints( flightPath, origin, forward, right )

	vector endPos = orgs[ orgs.len() - 1 ]

	DoTraceCoordCheck( false )

	for ( int i = 1; i < orgs.len(); i++ )
	{
		TraceResults result = TraceHull( orgs[i - 1], orgs[i], flightPath.mins, flightPath.maxs, null, flightPath.traceMask, TRACE_COLLISION_GROUP_NONE )
		if ( result.fraction < 1 )
		{
			if ( result.hitSky )
			{
				if ( draw )
					DebugDrawLine( orgs[i - 1], orgs[i], 0, 255, 0, true, ANALYSIS_PREVIEW_TIME )
				continue
			}

			if ( Distance( result.endPos, endPos ) > 16 )
			{
				if ( draw )
					DebugDrawLine( orgs[i - 1], orgs[i], 255, 0, 0, true, ANALYSIS_PREVIEW_TIME )

				DoTraceCoordCheck( true )
				return false
			}
		}

		if ( draw )
			DebugDrawLine( orgs[i - 1], orgs[i], 0, 255, 0, true, ANALYSIS_PREVIEW_TIME )

		WaitFrame()
	}

	//
	DoTraceCoordCheck( true )
	return true
}

#if(false)

















//





//





























//















//



//





//




//













/*

















*/




















#endif //

float function FixYaw( float yaw )
{
	yaw %= 360
	if ( yaw < 0 )
		yaw += 360
	return yaw
}

#if(false)









































//


//







//




//



































//








//





//
//

//



/*


















































































*/

















//






//
//
//
//
//
//
//




























//

//












//

































//








//




//




//




//































































//










//
//
//
//











//
//
//

//







//
//
//





//
//
//








































//










//
//
//
//


















































































//









#endif //

const bool DEBUG_DROP_POINTS = false
const bool DEBUG_DROP_POINTS_LINES = false
const DEBUG_DRAW_TIME = 0.02
const vector AIRDROP_MAXS = <80, 80, 256>
const vector AIRDROP_MINS = <-80, -80, 0>

bool function VerifyAirdropPoint( vector baseOrigin, float yaw, bool isCarePackage = false, entity realmEnt = null )
{
	const MAX_DIST_TO_GROUND_SQR = 16 * 16
	const DOOR_UP_OFFSET = 64
	const LEDGE_DOWN_OFFSET = 96
	const EDGE_TRACE_HEIGHT = 48
	const vector UP_VECTOR = <0, 0, 1>

	int door_space_distance = isCarePackage ? 64 : 128
	int edge_trace_dist     = isCarePackage ? 64 : 96
	int maxSurfaceAngle     = isCarePackage ? 55 : 20

	int failCode = 0

	entity edgeGroundEnt
	float edgeDistDiff

	vector startOrigin = baseOrigin + <0, 0, 10000>
	vector endOrigin   = baseOrigin + <0, 0, -128>
	vector forward     = AnglesToForward( < 0, yaw, 0 > )
	vector up          = <0, 0, 1>

	//
	vector maxs = !isCarePackage ? AIRDROP_MAXS : AIRDROP_MAXS * 0.65
	vector mins = !isCarePackage ? AIRDROP_MINS : AIRDROP_MINS * 0.65

	if ( IsNearAirdropBadPlace( baseOrigin, realmEnt ) )
		failCode = failCode | 0x0040

	TraceResults trace = TraceHull( startOrigin, endOrigin, mins, maxs, null, (TRACE_MASK_PLAYERSOLID | TRACE_MASK_TITANSOLID | CONTENTS_NOAIRDROP), TRACE_COLLISION_GROUP_NONE, UP_VECTOR, realmEnt )
	float dot          = DotProduct( up, trace.surfaceNormal )
	//
	if ( dot != 0 && DotToAngle( dot ) > maxSurfaceAngle )
	{
		failCode = failCode | 0x0001
		#if(false)




#endif
	}

	//
	entity groundEnt = trace.hitEnt
	if ( IsValid( groundEnt ) && !groundEnt.IsWorld() )
		failCode = failCode | 0x0002

	if ( trace.startSolid )
		failCode = failCode | 0x0200

	//
	float distToNodeSqr = DistanceSqr( trace.endPos, baseOrigin )
	float distToNode    = Distance( trace.endPos, baseOrigin )
	if ( distToNodeSqr > MAX_DIST_TO_GROUND_SQR )
		failCode = failCode | 0x0004


	//
	vector traceOrigin                  = trace.endPos
	array<vector> ridgeTraceVectorArray = [ <1, 0, 0>, <-0.5, 0.86, 0>, <-0.5, -0.86, 0> ]
	foreach ( traceVector in ridgeTraceVectorArray )
	{
		vector ridgeOrigin      = traceOrigin + <0, 0, 16> + traceVector * 18
		vector ridgeTraceOrigin = baseOrigin + <0, 0, -12> + traceVector * 18

		TraceResults ridgeTrace = TraceLine( ridgeOrigin, ridgeTraceOrigin, null, (TRACE_MASK_PLAYERSOLID | TRACE_MASK_TITANSOLID | CONTENTS_NOAIRDROP), TRACE_COLLISION_GROUP_NONE, realmEnt )
		float fraction          = ridgeTrace.fraction
		if ( fraction == 1 )
		{
			failCode = failCode | 0x0080
			#if(false)

#endif
			break
		}
	}


	//
	array<vector> edgeTraceVectorArray = [ <1, 0, 0>, <0.5, 0.86, 0>, <-0.5, 0.86, 0>, <-1, 0, 0>, <-0.5, -0.86, 0>, <0.5, -0.86, 0> ]
	foreach ( traceVector in edgeTraceVectorArray )
	{
		vector edgeOrigin      = baseOrigin + <0, 0, EDGE_TRACE_HEIGHT> + traceVector * edge_trace_dist
		vector edgeTraceOrigin = baseOrigin + <0, 0, -EDGE_TRACE_HEIGHT> + traceVector * edge_trace_dist

		TraceResults sightTrace = TraceLine( baseOrigin + <0, 0, EDGE_TRACE_HEIGHT>, edgeOrigin, null, (TRACE_MASK_PLAYERSOLID | TRACE_MASK_TITANSOLID | CONTENTS_NOAIRDROP), TRACE_COLLISION_GROUP_NONE, realmEnt )
		if ( sightTrace.fraction < 1 )
		{
			#if(false)

#endif
			continue    //
		}

		TraceResults edgeTrace = TraceLine( edgeOrigin, edgeTraceOrigin, null, (TRACE_MASK_PLAYERSOLID | TRACE_MASK_TITANSOLID | CONTENTS_NOAIRDROP), TRACE_COLLISION_GROUP_NONE, realmEnt )
		float fraction         = edgeTrace.fraction
		if ( fraction == 1 )
		{
			failCode = failCode | 0x0020
			#if(false)

#endif
			break
		}
	}


	//
	vector playerMins = <-16, -16, 0>//
	vector playerMaxs = <16, 16, 72>//
	vector doorOrigin = baseOrigin + <0, 0, DOOR_UP_OFFSET>

	vector base     = <0, yaw, 0>
	float yawOffset = 360.0 / 3.0

	array<vector> anglesToTest = [ base, AnglesCompose( base, <0, yawOffset, 0> ), AnglesCompose( base, <0, -yawOffset, 0> ) ]
	if ( isCarePackage )
		anglesToTest = []

	foreach ( angles in anglesToTest )
	{
		forward = AnglesToForward( angles )
		array<vector> openingTraceVectorArray = [ forward, VectorRotate( forward, <0, 30, 0> ), VectorRotate( forward, <0, -30, 0> ) ]
		bool failed                           = false
		foreach ( traceVector in openingTraceVectorArray )
		{
			vector doorEndOrigin = doorOrigin + traceVector * door_space_distance
			vector ledgeOrigin   = doorEndOrigin + <0, 0, -LEDGE_DOWN_OFFSET>

			//
			float fraction = TraceHullSimple( doorOrigin, doorEndOrigin, playerMins, playerMaxs, null )
			if ( fraction != 1 )
			{
				failCode = failCode | 0x0008
				failed = true

				#if(false)

#endif
				break
			}

			//
			fraction = TraceHullSimple( doorEndOrigin, ledgeOrigin, playerMins, playerMaxs, null )
			if ( fraction == 1 )
			{
				failCode = failCode | 0x0010
				failed = true

				#if(false)


#endif
				break
			}
		}

		if ( failed )
			break
	}


	#if(false)




























#endif //

	if ( failCode )
		return false

	//
	return true
}


#if(false)


//
//



















//







#endif //

#if(false)












//
//





//












//








//


//








//


//






//







//











//









//














//




//


#endif //

#if(false)








#endif //

#if(false)









#endif //

#if(false)
























































//













































//






























//


















//


















//



































//

























//







#endif //

#if(CLIENT)
bool function IsNearAirdropBadPlace( vector origin, entity realmEnt = null )
{
	//
	//
	foreach( airdropBadPlace in file.airdropBadPlaceArray  )
	{
		if ( IsValid( airdropBadPlace.ownerEnt ) && IsValid( realmEnt ) )
		{
			if ( !airdropBadPlace.ownerEnt.DoesShareRealms( realmEnt ) )
				continue
		}

		float distSrq = DistanceSqr( origin, airdropBadPlace.origin )
		int radiusSqr = airdropBadPlace.radius * airdropBadPlace.radius
		if ( distSrq < radiusSqr )
			return true
	}
	return false
}

void function DestroyAirdropBadPlace( int id )
{
	foreach( index, airdropBadPlace in file.airdropBadPlaceArray )
	{
		if ( airdropBadPlace.id == id )
		{
			file.airdropBadPlaceArray.fastremove( index )
			return
		}
	}
}
#endif //

#if(CLIENT)
void function ServerCallback_CreateAirdropBadPlace( int id, vector origin, int radius, entity ownerEnt )
{
	foreach( badPlace in file.airdropBadPlaceArray )
	{
		if ( badPlace.id == id )
			return //
	}

	printt( "Adding airdrop badplace this client", GetLocalClientPlayer() )

	AirdropBadPlace airdropBadPlace
	airdropBadPlace.id = id
	airdropBadPlace.origin = origin
	airdropBadPlace.radius = radius
	airdropBadPlace.ownerEnt = ownerEnt

	file.airdropBadPlaceArray.append( airdropBadPlace )
}

void function ServerCallback_DestroyAirdropBadPlace( int id )
{
	DestroyAirdropBadPlace( id )
}
#endif //

#if(false)











#endif
