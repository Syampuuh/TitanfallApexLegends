untyped

global function ClPlayer_Init

global function PlayIt
global function JumpRandomlyForever

global function ClientCodeCallback_PlayerDidDamage
global function ClientCodeCallback_PlayerSpawned
                                                      
global function ClientCodeCallback_HUDThink
global function Player_AddPlayer
global function Player_AddClient
global function ServerCallback_GameModeAnnouncement

global function ServerCallback_ResetReconnectParametersAsync
global function ClientCodeCallback_PlayerDisconnected
global function ClientCodeCallback_OnModelChanged
global function ServerCallback_PlayScreenFXWarpJump
global function PlayShieldBreakEffect
global function PlayShieldActivateEffect

global function OnClientPlayerAlive
global function OnClientPlayerDying
global function PlayLocal1PDeathSound
global function StopLocal1PDeathSound

global function ServerCallback_HideNextSpawnMessage

global function ClientCodeCallback_OnHealthChanged
global function ClientCodeCallback_OnCrosshairCurrentTargetChanged
                                       
global function ClientCodeCallback_OnGib
global function AddCallback_OnPlayerDisconnected
global function RemoveCallback_OnPlayerDisconnected

global function IsPlayerEliminated

global function ServerCallback_GiveMatchLossProtection
global function ServerCallback_OnEntityKilled
global function ServerCallback_OnEnemyDowned

global function ServerCallback_SetAssistInformation

global function GetShieldEffectCurrentColor
global function ClientPlayerClassChanged

global function GetHideCrosshairHitIndicatorOverride
global function SetHideCrosshairHitIndicatorOverride

#if DEV
global function BloodSprayDecals_Toggle
#endif

const float DEFAULT_GAMEMODE_ANNOUNCEMENT_DURATION = 5.0

struct {
	entity lastEarnedReward                                                                                    
	bool   hideCrosshairHitIndicatorOverride = false
	entity crosshairTarget

	float lastBloodDecalTime = 0

} file

struct BloodDecalParams
{
	float traceDist
	float secondaryTraceDist
	asset fxType
	asset secondaryFxType
}

void function ClPlayer_Init()
{
	ClDamageIndicator_Init()

	ClPlayer_Common_Precache()

	RegisterSignal( "OnAnimationDone" )
	RegisterSignal( "OnAnimationInterrupted" )
	RegisterSignal( "OnBleedingOut" )
	RegisterSignal( "PanelAlphaOverTime" )
	RegisterSignal( "LocalClientPlayerRespawned" )
	RegisterSignal( "OnClientPlayerAlive" )
	RegisterSignal( "OnClientPlayerDying" )
	RegisterSignal( "StopAlertCore" )
	RegisterSignal( "OnSpectatorMode" )
	RegisterSignal( "HealthChanged" )
	RegisterSignal( "ShieldChanged" )
	RegisterSignal( "TargetChanged" )

	FlagInit( "DamageDistancePrint" )
	FlagInit( "EnableTitanModeChange", true )
	FlagInit( "EnableBloodSprayDecals", true )

	level.canSpawnAsTitan <- false
	level.grenadeIndicatorEnabled <- true
	level.clientsLastKiller <- null

	AddCreateCallback( "player", SetupPlayerAnimEvents )

	AddCreateCallback( "first_person_proxy", SetupFirstPersonProxyEvents )
	AddCreateCallback( "predicted_first_person_proxy", SetupFirstPersonProxyEvents )

	AddCreateCallback( "player", EnableDoDeathCallback )
	AddCreateCallback( "npc_titan", EnableDoDeathCallback )
	AddCallback_ClientOnPlayerConnectionStateChanged( Player_OnPlayerConnectionStateChanged )

	level.menuHideGroups <- {}

	level.spawnAsTitanSelected <- false

	AddLocalPlayerFunc( Player_AddPlayer )

	if ( GetConVarBool( "cl_liveapi_enabled" ) )
		ClLiveAPI_Init()
}

entity function FindEnemyRodeoParent( entity player )
{
	entity ent = player.GetParent()
	if ( ent == null )
		return null

	if ( !ent.IsTitan() )
		return null

	if ( ent == player.GetPetTitan() )
		return null

	if ( ent.GetTeam() == player.GetTeam() )
		return null

	return ent
}


void function ClientCodeCallback_PlayerSpawned( entity player )
{
	if ( !IsValid( player ) )
		return

	if ( IsMenuLevel() )
		return

	ClearCrosshairPriority( crosshairPriorityLevel.ROUND_WINNING_KILL_REPLAY )

	if ( !level.clientScriptInitialized )
		return

	                                                          
	ClearRecentDamageHistory( player )
	DamageHistoryStruct blankDamageHistory
	clGlobal.lastDamageHistory = blankDamageHistory

	if ( player == GetLocalViewPlayer() )
	{
		foreach ( callbackFunc in clGlobal.onLocalViewPlayerSpawnedCallbacks )
		{
			callbackFunc( player )
		}
	}

	if ( player == GetLocalClientPlayer() )
	{
		player.cv.lastSpawnTime = Time()
		player.cv.roundSpawnCount++

		foreach ( callbackFunc in clGlobal.onLocalClientPlayerSpawnedCallbacks )
		{
			thread callbackFunc( player )
		}
	}
}


bool function ConditionPlayerIsTitan()
{
	entity player = GetLocalClientPlayer()
	if ( !IsAlive( player ) )
		return false

	return player.IsTitan()
}


bool function ConditionPlayerIsNotTitan()
{
	entity player = GetLocalClientPlayer()
	if ( !IsAlive( player ) )
		return false

	return !player.IsTitan()
}


bool function LastEarnedRewardStillValid()
{
	entity player = GetLocalClientPlayer()
	if ( !IsAlive( player ) )
		return false

	entity weapon = player.GetOffhandWeapon( OFFHAND_INVENTORY )
	if ( !IsValid( weapon ) )
		return false

	return weapon == file.lastEarnedReward
}


bool function ConditionNoTitan()
{
	entity player = GetLocalClientPlayer()
	if ( !IsAlive( player ) )
		return false

	if ( IsValid( player.GetPetTitan() ) )
		return false

	return !player.IsTitan()
}


void function Player_AddClient( entity player )
{
	                                                                   
	  	                                                                         
	                                                                              
	                                                                              

	                             

	if ( !IsLobby() )
	{
		player.EnableHealthChangedCallback()

		player.cv.deathTime <- 0.0
		player.cv.lastSpawnTime <- 0.0
		player.cv.deathOrigin <- <0, 0, 0>
		player.cv.roundSpawnCount <- 0

		                                
	}
}


void function Player_AddPlayer( entity player )
{
	player.s.weaponUpdateData <- {}

	player.s.trackedAttackers <- {}              
	player.classChanged = true
	player.p.classActuallyChanged = true
}


function Pressed_RequestTitanfall( entity player )
{
	if ( !IsTitanAvailable( player ) )
		return

	#if DEV
		printt( player.GetEntIndex(), "Requested replacement Titan from eye pos " + player.EyePosition() + " view angles " + player.EyeAngles() + " player origin " + player.GetOrigin() + " map " + GetMapName() )
	#endif

	player.ClientCommand( "ClientCommand_RequestTitan" )                                                                                            
	Rumble_Play( "rumble_titanfall_request", {} )
}


void function ClientCodeCallback_HUDThink()
{
	PerfStart( PerfIndexClient.HUDThink )

	entity player = GetLocalViewPlayer()

	if ( !player.p.playerScriptsInitialized )
	{
		PerfEnd( PerfIndexClient.HUDThink )
		return
	}

	if ( !IsMenuLevel() )
	{
		PerfStart( PerfIndexClient.HUDThink_4 )

		ClGameState_Think()
		PerfEnd( PerfIndexClient.HUDThink_4 )

		PerfStart( PerfIndexClient.HUDThink_5 )
		UpdateChatHUDVisibility()
		PerfEnd( PerfIndexClient.HUDThink_5 )

		UpdateScreenFade()

		entity clientPlayer = GetLocalClientPlayer()
		if ( !IsWatchingKillReplay() && clientPlayer.classChanged )
			ClientPlayerClassChanged( clientPlayer, clientPlayer.GetPlayerClass() )

		PerfStart( PerfIndexClient.HUDThink_6 )
		SmartAmmo_LockedOntoWarningHUD_Update()
		PerfEnd( PerfIndexClient.HUDThink_6 )
	}

	PerfEnd( PerfIndexClient.HUDThink )
}


void function ClientPlayerClassChanged( entity player, newClass )
{
	bool actuallyChanged = player.p.classActuallyChanged
	                                                                    
	player.classChanged = false
	player.p.classActuallyChanged = false

	Assert( !IsServer() )
	Assert( newClass, "No class" )

	switch ( newClass )
	{
		case "titan":
			SetStandardAbilityBindingsForTitan( player )

			LinkButtonPair( -1, -1, -1 )
			break

		case "pilot":
			if ( actuallyChanged )
				SetStandardAbilityBindingsForPilot( player )

			                                                                                                        
			                                                                                                          
			                                                            
			LinkButtonPair( IN_OFFHAND1, IN_PING, IN_OFFHAND4 )

			break

		case "spectator":
			LinkButtonPair( -1, -1, -1 )
			break

		case "default":
			if ( player.GetTeam() == TEAM_SPECTATOR )
				SetStandardAbilityBindingsForSpectator( player )                                                
			break

		default:
			Assert( 0, "Unknown class \"" + newClass + "\"" )
	}
}


void function Player_OnConnected( entity player )
{
	PlayerConnectedOrDisconnected( player, 1 )

	if ( !IsLobby() || !IsConnected() )
		UpdatePlayerStatusCounts()

	TrackingVisionUpdatePlayerConnected( player )
}

void function Player_OnPlayerConnectionStateChanged( entity player )
{
	if ( player.IsConnectionActive() )
		Player_OnConnected( player )
}

void function ServerCallback_ResetReconnectParametersAsync()
{
	ResetReconnectParametersAsync()
}

void function AddCallback_OnPlayerDisconnected( void functionref( entity ) callbackFunc )
{
	Assert( !clGlobal.onPlayerDisconnectedFuncs.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with AddCallback_OnPlayerDisconnected" )

	clGlobal.onPlayerDisconnectedFuncs.append( callbackFunc )
}


void function RemoveCallback_OnPlayerDisconnected( void functionref( entity ) callbackFunc )
{
	clGlobal.onPlayerDisconnectedFuncs.removebyvalue( callbackFunc )
}


void function ClientCodeCallback_PlayerDisconnected( entity player )
{
	PlayerConnectedOrDisconnected( player, 0 )

	if ( !IsLocalClientPlayer( player ) && ShouldUpdatePlayerStatusCounts() )
		UpdatePlayerStatusCounts()

	ShEHI_OnPlayerDisconnected( player )

	                                             
	foreach ( callbackFunc in clGlobal.onPlayerDisconnectedFuncs )
	{
		callbackFunc( player )
	}
}


bool function ShouldUpdatePlayerStatusCounts()
{
	if ( !IsConnected() )
		return false

	if ( IsLobby() )
		return false

	if ( GetGameState() < eGameState.WaitingForPlayers )
		return false

	return true
}


void function PlayerConnectedOrDisconnected( entity player, int state )
{
	if ( IsLobby() || GetMapName() == "" )
		                                                                          
		return
	if ( !GetLocalViewPlayer() )
		return
	if ( !ShouldShowObituaryLineForPlayer( player ) )
		return

	Assert( state == 0 || state == 1 )
	if ( state == 0 )
		return

	if ( player.GetTeam() == GetLocalViewPlayer().GetTeam() )
	{
		string playerName = GetPlayerNameFromEHI( ToEHI( player ) )
		vector playerNameColor = <255, 255, 255>

		int teamMemberIndex = player.GetTeamMemberIndex()
		if ( teamMemberIndex < 0 )
			Warning( "%s() - Invalid team member index (%d) for player: %s", FUNC_NAME(), teamMemberIndex, string( player ) )
		else
			playerNameColor = GetPlayerInfoColor( player )

		                                                                              
		vector altColor2 = <255,255,255>
		vector altColor3 = <255,255,255>
		vector backgroundColor = <255,255,255>
		float backgroundAlpha = 0.0
		bool bCheckForDuplicateEntry = true
		Obituary_Print_Localized( Localize( "#MP_PLAYER_CONNECTED", playerName ), playerNameColor, altColor2, altColor3, backgroundColor, backgroundAlpha, bCheckForDuplicateEntry )
	}
}


void function ClientCodeCallback_PlayerDidDamage( PlayerDidDamageParams params )
{
	if ( IsWatchingThirdPersonKillReplay() )
		return

	entity attacker = GetLocalViewPlayer()
	if ( !IsValid( attacker ) )
		return

	entity victim = params.victim
	if ( !IsValid( victim ) )
		return

	vector damagePosition          = params.damagePosition
	int hitBox                     = params.hitBox
	int damageType                 = params.damageType
	float damageAmount             = params.damageAmount
	int damageFlags                = params.damageFlags
	int hitGroup                   = params.hitGroup
	entity weapon                  = params.weapon
	float distanceFromAttackOrigin = params.distanceFromAttackOrigin

	bool playHitSound              = true
	bool showCrosshairHitIndicator = true
	bool hitIneffective            = false
	bool victimIsHeavyArmor        = victim.GetArmorType() == ARMOR_TYPE_HEAVY
	bool victimHasShieldRemaining  = victim.GetShieldHealth() - damageAmount > 0
	bool isShieldShot              = (damageType & DF_SHIELD_DAMAGE) && victimHasShieldRemaining ? true : false
	bool isCritShot                = (damageType & DF_CRITICAL) ? true : false
	bool isHeadShot                = (damageType & DF_HEADSHOT) ? true : false
	bool isKillShot                = (damageType & DF_KILLSHOT) ? true : false
	bool isMelee                   = (damageType & DF_MELEE) ? true : false
	bool isExplosion               = (damageType & DF_EXPLOSION) ? true : false
	bool isBullet                  = (damageType & DF_BULLET) ? true : false
	bool isShotgun                 = (damageType & DF_SHOTGUN) ? true : false
	bool isArmorShot               = (damageFlags & DAMAGEFLAG_VICTIM_ARMORED) && victimHasShieldRemaining ? true : false
	bool isVortexHit               = (damageFlags & DAMAGEFLAG_VICTIM_HAS_VORTEX) ? true : false
	bool isKnockdownShot           = (damageType & DF_KNOCKDOWN) ? true : false
	bool isShieldBreak             = (damageType & DF_SHIELD_BREAK) ? true : false
	bool isShadowShot              = (damageType & DF_SHADOW_DAMAGE) ? true : false
	bool isOvershieldShot          = (damageType & DF_OVERSHIELD) ? true : false

	bool playKillSound = isKillShot

	if ( !attacker.IsTitan() )
	{
		if ( victimIsHeavyArmor )
		{
			showCrosshairHitIndicator = true
			if ( victim.IsTitan() )
				hitIneffective = false                                               
			else
				hitIneffective = isCritShot || isHeadShot || !IsHitEffectiveVsNonTitan( victim, damageType )
		}
		else
		{
			switch ( victim.GetNetworkedClassName() )
			{
				case "npc_super_spectre":
					                                      
					  	                     

				default:
					if ( (damageType & DF_BULLET && damageType & DF_MAX_RANGE) )
						hitIneffective = true
					break
			}
		}
	}

	if ( damageType & DF_MAX_RANGE && damageType & DF_BULLET )
	{
		                                                          
		playHitSound = false
		hitIneffective = true
	}

	if ( damageType & DF_MELEE )
		                                                          
	{
		playHitSound = false
		playKillSound = false
	}

	if ( damageType & DF_NO_HITBEEP )
	{
		playHitSound = false
		playKillSound = false
	}

	if ( isShadowShot )
	{
		playHitSound = true
		playKillSound = false
		showCrosshairHitIndicator = true
	}
	else if ( isOvershieldShot )
	{
		PlayShieldHitEffect( params, OVERSHIELD_COLOR )
		showCrosshairHitIndicator = true
	}
	else if ( isArmorShot || isShieldShot )
	{
		int armorTier = 0
		if ( damageFlags & DAMAGEFLAG_ARMOR1 )
			armorTier = 1
		else if ( damageFlags & DAMAGEFLAG_ARMOR2 )
			armorTier = 2
		else if ( damageFlags & DAMAGEFLAG_ARMOR3 )
			armorTier = 3
		else if ( damageFlags & DAMAGEFLAG_ARMOR4 )
			armorTier = 4

		vector armorColor = GetFXRarityColorForTier( armorTier )

		PlayShieldHitEffect( params, armorColor )
		if ( isShieldShot )
			showCrosshairHitIndicator = true
	}
	else if ( damageAmount <= 0 )
	{
		playHitSound = false
		playKillSound = false
		showCrosshairHitIndicator = false
	}

	                                     
	   
	  	                    
	  	                     
	  	                                 
	   

	if ( GetHideCrosshairHitIndicatorOverride() )
		showCrosshairHitIndicator = false

	if ( isKillShot || isKnockdownShot )
		KillShotBloodSpray( attacker, victim, damagePosition, isExplosion, isBullet, isShotgun, isShadowShot )

	if ( victim.IsTitan() && isKillShot )
		ClientScreenShake( 8, 10, 1, <0, 0, 0> )

	BloodSprayDecals( attacker, victim, damagePosition, damageAmount, isHeadShot, isKillShot, isMelee, isExplosion, isBullet, isShotgun )

	if ( isShieldBreak )
		PlayShieldBreakEffect( victim )

	int hitType = eHitType.NORMAL
	if ( showCrosshairHitIndicator )
	{
		if ( isShadowShot )
			hitType = eHitType.SHADOW
		else if ( isOvershieldShot )
			hitType = eHitType.OVERSHIELD
		else if ( isShieldShot )
			hitType = eHitType.SHIELD
		else if ( isHeadShot || isCritShot )
			hitType = eHitType.CRIT
		else if ( hitIneffective )
			hitType = eHitType.INEFFECTIVE
		else if ( isArmorShot )
			hitType = eHitType.ARMOR
		else if ( isVortexHit )
			hitType = eHitType.VORTEX

		DamageFlyout( damageAmount, damagePosition, victim, hitType, damageFlags, damageType, weapon )
	}

	bool playedHitSound = false
	if ( playHitSound )
	{
		if ( isHeadShot )
			playedHitSound = PlayHeadshotConfirmSound( attacker, victim, weapon, isKillShot )
		else if ( playKillSound )
			playedHitSound = PlayKillshotConfirmSound( attacker, victim, damageType )
	}

	if ( IsSpectre( victim ) )
	{
		if ( isHeadShot )
			victim.Signal( "SpectreGlowEYEGLOW" )
	}

	                                                                                            
	if ( playHitSound && IsAlive( victim ) && !playedHitSound )
	{
		PlayHitSound( victim, attacker, damageFlags, isCritShot, isShieldShot, victimIsHeavyArmor, isKillShot, hitType )
	}

	foreach ( callback in clGlobal.onLocalPlayerDidDamageCallback )
	{
		callback( attacker, victim, damagePosition, damageType, damageAmount )
	}
}


void function PlayHitSound( entity victim, entity attacker, int damageFlags, bool isCritShot, bool isShieldShot, bool victimIsHeavyArmor, bool isKillShot, int hitType )
{
	if ( damageFlags & DAMAGEFLAG_VICTIM_INVINCIBLE )
	{
		EmitSoundOnEntity( attacker, "Player.HitbeepInvincible" )
	}
	else if ( damageFlags & DAMAGEFLAG_VICTIM_HAS_VORTEX )
	{
		EmitSoundOnEntity( attacker, "Player.HitbeepVortex" )
	}
	else if ( isCritShot && isShieldShot )
	{
		EmitSoundOnEntity( attacker, "titan_damage_crit" )               
	}
	else if ( isCritShot )
	{
		EmitSoundOnEntity( attacker, "Player.Hitbeep_crit" )
	}
	else if ( hitType == eHitType.OVERSHIELD )
	{
		EmitSoundOnEntity( attacker, HITBEEP_HEADSHOT_ANDROID )
	}
	else
	{
		EmitSoundOnEntity( attacker, "Player.Hitbeep" )
	}
}


void function KillShotBloodSpray( entity player, entity victim, vector damagePosition, bool isExplosion, bool isBullet, bool isShotgun, bool isShadowShot )
{
	if ( isShadowShot )
	{
		int chestFocusAttachment = victim.LookupAttachment( "CHESTFOCUS" )
		if ( chestFocusAttachment == 0  )
			return

		int fxId = GetParticleSystemIndex( FX_KILLSHOT_SHADOWFORM )

		vector victimVelocity = victim.GetVelocity()
		damagePosition += (Length( victimVelocity ) * 0.15) * Normalize( victimVelocity )
		StartParticleEffectOnEntity( victim, fxId, FX_PATTACH_POINT, chestFocusAttachment )
		return
	}

	if ( victim.IsMechanical() )
	{
		int chestFocusAttachment = victim.LookupAttachment( "CHESTFOCUS" )

		if ( chestFocusAttachment == 0  )
			return

		int fxId = GetParticleSystemIndex( FX_KILLSHOT_MECHANICAL )

		vector victimVelocity = victim.GetVelocity()
		damagePosition += (Length( victimVelocity ) * 0.15) * Normalize( victimVelocity )
		StartParticleEffectOnEntity( victim, fxId, FX_PATTACH_POINT, chestFocusAttachment )
		return
	}

	if ( IsSoftenedLocale() )
	{
		int chestFocusAttachment = victim.LookupAttachment( "CHESTFOCUS" )
		if ( chestFocusAttachment == 0  )
			return

		int fxId = GetParticleSystemIndex( FX_KILLSHOT_AR )

		vector victimVelocity = victim.GetVelocity()
		damagePosition += (Length( victimVelocity ) * 0.15) * Normalize( victimVelocity )
		StartParticleEffectOnEntity( victim, fxId, FX_PATTACH_POINT, chestFocusAttachment )
		return
	}

	if ( IsProwler( victim ) )
	{
		int chestFocusAttachment = victim.LookupAttachment( "CHESTFOCUS" )

		if ( chestFocusAttachment == 0  )
			return

		int fxId = GetParticleSystemIndex( FX_KILLSHOT_ALIENFLESH )

		vector victimVelocity = victim.GetVelocity()
		damagePosition += (Length( victimVelocity ) * 0.15) * Normalize( victimVelocity )
		StartParticleEffectOnEntityWithPos( victim, fxId, FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID, damagePosition - victim.GetOrigin(), <0, 0, 0> )

		return
	}

	if ( !victim.IsHuman() )
		return

	if ( victim.IsHologram() )
		return

	if ( !isExplosion && !isBullet && !isShotgun )
		return

	int fxId = GetParticleSystemIndex( FX_KILLSHOT_BLOODSPRAY )

	vector victimVelocity = victim.GetVelocity()
	damagePosition += (Length( victimVelocity ) * 0.15) * Normalize( victimVelocity )
	StartParticleEffectOnEntityWithPos( victim, fxId, FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID, damagePosition - victim.GetOrigin(), <0, 0, 0> )
}


void function BloodSprayDecals( entity player, entity victim, vector damagePosition, float damageAmount, bool isHeadShot, bool isKillShot, bool isMelee, bool isExplosion, bool isBullet, bool isShotgun )
{
	if ( IsSoftenedLocale() || !Flag( "EnableBloodSprayDecals" ) )
		return

	if ( !victim.IsHuman() && !IsProwler( victim ) )
		return

	if ( victim.IsMechanical() )
		return

	if ( victim.IsHologram() )
		return

	if ( !isMelee && !isExplosion && !isBullet && !isShotgun )
		return

	                                           
	if ( !isKillShot && Time() - file.lastBloodDecalTime < 0.2 )
		return

	file.lastBloodDecalTime = Time()

	thread BloodSprayDecals_Think( player, victim, damagePosition, damageAmount, isHeadShot, isKillShot, isMelee, isExplosion, isBullet, isShotgun )
}


void function BloodSprayDecals_Think( entity player, entity victim, vector damagePosition, float damageAmount, bool isHeadShot, bool isKillShot, bool isMelee, bool isExplosion, bool isBullet, bool isShotgun )
{
	player.EndSignal( "OnDestroy" )
	victim.EndSignal( "OnDestroy" )

	BloodDecalParams params  = BloodDecal_GetParams( damageAmount, isHeadShot, isKillShot, isMelee, isExplosion, isBullet, isShotgun )
	float traceDist          = params.traceDist
	float secondaryTraceDist = params.secondaryTraceDist
	asset fxType             = params.fxType
	asset secondaryFxType    = params.secondaryFxType

	int fxId = GetParticleSystemIndex( fxType )

	                 
	vector traceStart = damagePosition
	vector traceFwd   = player.GetViewVector()

	if ( isExplosion || isMelee )
	{
		                                                                          
		int attachID = victim.LookupAttachment( "CHESTFOCUS" )
		traceStart = victim.GetAttachmentOrigin( attachID )

		if ( isExplosion )
			traceFwd = AnglesToForward( victim.GetAngles() ) * -1
	}

	vector traceEnd = damagePosition + (traceFwd * traceDist)
	                                                                                                                   

	var deferredTrace_primary = DeferredTraceLineHighDetail( traceStart, traceEnd, victim, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )

	while ( !IsDeferredTraceFinished( deferredTrace_primary ) )
		WaitFrame()

	vector primaryTraceNormal
	{
		TraceResults traceResult = GetDeferredTraceResult( deferredTrace_primary )

		vector primaryTraceEndPos = traceResult.endPos
		primaryTraceNormal = traceResult.surfaceNormal
		                                                               
		                                                                

		bool doGravitySplat = isMelee ? false : true

		if ( traceResult.fraction < 1.0 )
		{
			vector normAng = VectorToAngles( traceResult.surfaceNormal )
			vector fxAng   = AnglesCompose( normAng, <90, 0, 0> )

			StartParticleEffectInWorld( fxId, primaryTraceEndPos, fxAng )
			                                     
		}
		else if ( doGravitySplat )
		{
			                                                           
			float gravitySplatBackTraceDist = 58.0                                                    
			float gravitySplatDownTraceDist = 100.0                                                                
			vector groundTraceStartPos      = damagePosition + (traceFwd * gravitySplatBackTraceDist)
			vector groundTraceEndPos        = groundTraceStartPos - <0, 0, 100>

			var deferredTrace_gravitySplat = DeferredTraceLineHighDetail( groundTraceStartPos, groundTraceEndPos, victim, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )

			while ( !IsDeferredTraceFinished( deferredTrace_gravitySplat ) )
				WaitFrame()

			TraceResults downTraceResult = GetDeferredTraceResult( deferredTrace_gravitySplat )

			if ( downTraceResult.fraction < 1.0 )
			{
				                                                                                      
				                                                                    

				vector normAng = VectorToAngles( downTraceResult.surfaceNormal )
				vector fxAng   = AnglesCompose( normAng, <90, 0, 0> )

				                                                     

				StartParticleEffectInWorld( fxId, downTraceResult.endPos, fxAng )
			}
		}
	}

	                                             

	                     
	                             
	                                             
	  
	                    
	   
	  	                                                                 
	  	                                           
	  	                                                
	  	                                
	  	                                        
	  	                                             
	   
	      
	   
	  	                                               
	  	                                            
	  	                                  
	  	                                              
	  	                                                
	  	                            
	  	                           
	  
	  	                                                
	  	                            
	  		                                             
	   
	  
	                        
	  	      
	  
	                                         
	                                 
	   
	  	                                                                      
	  	                                                                                                                                              
	  	                                                        
	   
	  
	                                                               
	  
	                          
	                                  
	                                                                  
	   
	  	           
	  
	  	                                                    
	  	 
	  		                                                 
	  			        
	  
	  		                                                
	  			        
	  
	  		                                        
	  
	  		                                                                  
	  
	  		                                  
	  			        
	  
	  		                                                        
	  		                                                       
	  		                                                 
	  			        
	  
	  		                                                       
	  		                                                 
	  
	  		                                  
	  		                                                    
	  		                                                          
	  	 
	  
	  	                                     
	  	                                
	  		      
	   
}


BloodDecalParams function BloodDecal_GetParams( float damageAmount, bool isHeadShot, bool isKillShot, bool isMelee, bool isExplosion, bool isBullet, bool isShotgun )
{
	                         
	float traceDist          = 175
	float secondaryTraceDist = 100
	asset fxType             = FX_BLOODSPRAY_DECAL_SML
	asset secondaryFxType    = FX_BLOODSPRAY_DECAL_SML

	if ( isBullet )
	{
		                                      
		if ( isShotgun )
		{
			                   
			  	                                
			      
			fxType = FX_BLOODSPRAY_DECAL_MED
		}
		else
		{
			if ( isKillShot )
				fxType = FX_BLOODSPRAY_DECAL_MED
			else
				fxType = FX_BLOODSPRAY_DECAL_SML

			if ( damageAmount >= 200 )
			{
				traceDist = 216
				fxType = FX_BLOODSPRAY_DECAL_LRG
				secondaryFxType = FX_BLOODSPRAY_DECAL_MED
			}
		}
	}
	else if ( isExplosion )
	{
		secondaryTraceDist = traceDist

		float maxDmg = 100
		float medDmg = 75

		if ( damageAmount >= maxDmg )
		{
			fxType = FX_BLOODSPRAY_DECAL_LRG
			secondaryFxType = FX_BLOODSPRAY_DECAL_LRG
		}
		else if ( damageAmount >= medDmg )
		{
			fxType = FX_BLOODSPRAY_DECAL_LRG
			secondaryFxType = FX_BLOODSPRAY_DECAL_MED
		}
		else if ( isKillShot )
		{
			fxType = FX_BLOODSPRAY_DECAL_MED
			secondaryFxType = FX_BLOODSPRAY_DECAL_MED
		}
	}
	else if ( isMelee )
	{
		traceDist = 96

		if ( isKillShot )
			fxType = FX_BLOODSPRAY_DECAL_MED
	}

	                                           
	if ( isKillShot )
	{
		traceDist = traceDist + (traceDist * 0.1)
		secondaryTraceDist = secondaryTraceDist + (secondaryTraceDist * 0.1)
	}

	BloodDecalParams params
	params.traceDist = traceDist
	params.secondaryTraceDist = secondaryTraceDist
	params.fxType = fxType
	params.secondaryFxType = secondaryFxType
	return params
}

#if DEV
string function BloodSprayDecals_Toggle()
{
	string returnStr = ""

	if ( Flag( "EnableBloodSprayDecals" ) )
	{
		FlagClear( "EnableBloodSprayDecals" )
		returnStr = "Blood spray decals DISABLED"
	}
	else
	{
		FlagSet( "EnableBloodSprayDecals" )
		returnStr = "Blood spray decals ENABLED"
	}

	return returnStr
}
#endif

void function ServerCallback_OnEntityKilled( entity attacker, entity victim, int scriptDamageType, int damageSourceId )
{
	bool isHeadShot = (scriptDamageType & DF_HEADSHOT) > 0

	entity localClientPlayer = GetLocalClientPlayer()

	if ( !IsValid( victim ) )
		return

	Signal( victim, "OnDeath" )

	if ( victim == localClientPlayer )
	{
		victim.cv.deathOrigin = victim.GetOrigin()
		level.clientsLastKiller = attacker
	}

	if ( damageSourceId == eDamageSourceId.indoor_inferno )
	{
		if ( victim == localClientPlayer )
			thread PlayerFieryDeath( victim )
	}

	UpdatePlayerStatusCounts()

	if ( IsValid( attacker ) && attacker.IsPlayer() )
	{
	}
	else if ( IsValid( attacker ) && attacker.IsNPC() )
	{
		entity boss = attacker.GetBossPlayer()
		if ( IsValid( boss ) )
			attacker = boss
	}
	else if ( victim.IsPlayer() )
	{
		if ( ("latestAssistTime" in victim.s) && victim.s.latestAssistTime >= Time() - MAX_NPC_KILL_STEAL_PREVENTION_TIME )
		{
			attacker = expect entity( victim.s.latestAssistPlayer )
			damageSourceId = expect int( victim.s.latestAssistDamageSource )
		}
	}

	if ( victim.IsPlayer() && victim != attacker && damageSourceId != eDamageSourceId.human_execution )
	{
		if ( attacker == localClientPlayer )
		{
			thread PlayKillConfirmedSound( "Pilot_Killed_Indicator" )
		}
		else if ( IsValid( attacker ) && attacker.IsTitan() )
		{
			entity bossPlayer = attacker.GetBossPlayer()
			if ( bossPlayer && bossPlayer == localClientPlayer )
				thread PlayKillConfirmedSound( "Pilot_Killed_Indicator" )
		}
	}
	else if ( (IsGrunt( victim ) || IsSpectre( victim )) && attacker == localClientPlayer )
	{
		thread PlayKillConfirmedSound( "HUD_Grunt_Killed_Indicator" )
	}

	                                                                 
	if ( (victim.IsTitan()) && (!victim.IsPlayer()) )
		return

	int obitFlags
	if ( isHeadShot )
		obitFlags = obitFlags | OBIT_FLAG_HEADSHOT

	Obituary( attacker, "", victim, scriptDamageType, damageSourceId, obitFlags )

	ServerCallback_PrivateMatch_OnEntityKilled( attacker, victim )
}

void function ServerCallback_OnEnemyDowned( entity attacker, entity victim, int scriptDamageType, int damageSourceId, int weaponSkinItemFlavorGUID )
{
	entity localClientPlayer = GetLocalClientPlayer()

	if ( !IsValid( victim ) )
		return

	if ( !IsValid( attacker ) )
		return

	if ( !attacker.IsPlayer() )
		return

	if ( !victim.IsPlayer() )
		return

	if ( attacker == localClientPlayer )
	{
		string impactSound = ""
		if ( IsValidItemFlavorGUID( weaponSkinItemFlavorGUID ) )
		{
			ItemFlavor weaponSkinItemFlavor = GetItemFlavorByGUID( weaponSkinItemFlavorGUID )
			switch ( ItemFlavor_GetType( weaponSkinItemFlavor ) )
			{
				case eItemType.melee_skin:
					impactSound = MeleeSkin_GetKOSound( weaponSkinItemFlavor )
			}
		}

		if ( impactSound == "" )
			impactSound = "flesh_bulletimpact_downedshot_1p_vs_3p"

		EmitSoundOnEntity( localClientPlayer, impactSound )
	}

	Obituary( attacker, "", victim, scriptDamageType, damageSourceId, OBIT_FLAG_DOWNED )

	LiveAPI_OnPlayerDowned( attacker, victim, damageSourceId )
}


const float KILL_CONFIRM_DEBOUNCE = 0.025
void function PlayKillConfirmedSound( string sound )
{
	while ( true )
	{
		if ( Time() - clGlobal.lastKillConfirmTime > KILL_CONFIRM_DEBOUNCE )
		{
			clGlobal.lastKillConfirmTime = Time()
			EmitSoundOnEntity( GetLocalClientPlayer(), sound )
			return
		}

		WaitFrame()
	}
}


void function ServerCallback_SetAssistInformation( int damageSourceId, int attackerEHandle, int entityEHandle, float assistTime )
{
	entity ent = GetHeavyWeightEntityFromEncodedEHandle( entityEHandle )
	if ( !ent )
		return

	entity latestAssistPlayer = GetEntityFromEncodedEHandle( attackerEHandle )
	if ( !("latestAssistPlayer" in ent.s) )
	{
		ent.s.latestAssistPlayer <- latestAssistPlayer
		ent.s.latestAssistDamageSource <- damageSourceId
		ent.s.latestAssistTime <- assistTime
	}
	else
	{
		ent.s.latestAssistPlayer = latestAssistPlayer
		ent.s.latestAssistDamageSource = damageSourceId
		ent.s.latestAssistTime = assistTime
	}
}


void function ClientCodeCallback_OnModelChanged( entity ent )
{
	  
		                                                                                                             

		                      
			      

		                                  
			      

		                                        
	  
}


void function ClientCodeCallback_OnHealthChanged( entity ent, int oldHealth, int newHealth )
{
	if ( IsLobby() )
		return

	entity player = GetLocalViewPlayer()
	if ( !IsValid( player ) )
		return

	if ( !IsValid( ent ) )
		return

	ent.Signal( "HealthChanged", { oldHealth = oldHealth, newHealth = newHealth } )
	Chroma_HealthChanged()
}


void function ClientCodeCallback_OnCrosshairCurrentTargetChanged( entity player, entity newTarget )
{
	if ( IsLobby() )
		return

	if ( !IsValid( player ) )
		return

	                                   

	if ( file.crosshairTarget == newTarget )
		return
	else if ( player == newTarget )
	{
		file.crosshairTarget = newTarget
		player.Signal( "TargetChanged" )
		                                                                         
	}
	else if ( newTarget == null )
	{
		file.crosshairTarget = newTarget
		player.Signal( "TargetChanged" )
		                                                                         
	}
	else
	{
		file.crosshairTarget = newTarget
		player.Signal( "TargetChanged" )

		                             
			                                                                                                   
	}
}


void function SetupPlayerAnimEvents( entity player )
{
	SkydiveTrail_SetupAnimEvents( player )
}


void function JumpRandomlyForever()
{
	for ( ; ; )
	{
		if ( IsWatchingReplay() )
		{
			wait 1
			continue
		}

		entity player = GetLocalClientPlayer()
		if ( !IsAlive( player ) || player != GetLocalViewPlayer() )
		{
			wait 1
			continue
		}

		printt( "jump!" )
		player.ClientCommand( "+jump" )
		wait 0
		player.ClientCommand( "-jump" )

		wait RandomFloatRange( 0.2, 1.1 )
	}
}


void function RemoteTurretFadeoutAnimEvent( entity ent )
{
	entity player = GetLocalViewPlayer()
	ScreenFade( player, 0, 0, 0, 255, 0.1, 0.25, FFADE_OUT )
}


void function SetupFirstPersonProxyEvents( entity firstPersonProxy )
{
	                                         

	AddAnimEvent( firstPersonProxy, "mantle_smallmantle", OnSmallMantle )
	AddAnimEvent( firstPersonProxy, "mantle_mediummantle", OnMediumMantle )
	AddAnimEvent( firstPersonProxy, "mantle_lowmantle", OnLowMantle )
	AddAnimEvent( firstPersonProxy, "mantle_extralowmantle", OnExtraLowMantle )
	AddAnimEvent( firstPersonProxy, "remoteturret_fadeout", RemoteTurretFadeoutAnimEvent )
}


void function OnSmallMantle( entity firstPersonProxy )
                                                                                                                                                     
{
	entity player = GetLocalViewPlayer()
	EmitSoundOnEntity( firstPersonProxy, "mantle_smallmantle" )
}


void function OnMediumMantle( entity firstPersonProxy )
                                                                                                                                                     
{
	entity player = GetLocalViewPlayer()
	EmitSoundOnEntity( firstPersonProxy, "mantle_mediummantle" )
}


void function OnLowMantle( entity firstPersonProxy )
                                                                                                                                                     
{
	entity player = GetLocalViewPlayer()
	EmitSoundOnEntity( firstPersonProxy, "mantle_lowmantle" )
}


void function OnExtraLowMantle( entity firstPersonProxy )
                                                                                                                                                     
{
	entity player = GetLocalViewPlayer()
	EmitSoundOnEntity( firstPersonProxy, "mantle_extralow" )
}


bool function ShouldHideRespawnSelectionText( entity player )
{
	if ( player != GetLocalClientPlayer() )
		return false
	if ( player.GetPlayerClass() != "spectator" )
		return false
	if ( IsWatchingReplay() )
		return false

	return true
}

bool function ClientCodeCallback_OnGib( entity victim, vector attackDir )
{
	if ( !victim.IsMechanical() )
		return SpawnFleshGibs( victim, attackDir )

	return false
}


bool function SpawnFleshGibs( entity victim, vector attackDir )
{
	asset modelName = $"mdl/gibs/human_gibs.rmdl"
	attackDir = Normalize( attackDir )

	float cullDist = 2048.0
	if ( "gibDist" in victim.s )
		cullDist = expect float( victim.s.gibDist )

	vector startOrigin = victim.GetWorldSpaceCenter() + (attackDir * -30)

	vector origin   = victim.GetOrigin() + <RandomIntRange( 10, 20 ), RandomIntRange( 10, 20 ), RandomIntRange( 32, 64 )>
	vector angles   = <0, 0, 0>
	vector flingDir = attackDir * RandomIntRange( 80, 200 )

	int fxID
	bool isSoftenedLocale = IsSoftenedLocale()

	if ( isSoftenedLocale )
	{
		if ( victim.GetModelName() == FLYER_MODEL )
		{
			fxID = StartParticleEffectOnEntity( victim, GetParticleSystemIndex( $"death_pinkmist_LG_nochunk" ), FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID )
		}
		else
		{
			fxID = StartParticleEffectOnEntity( victim, GetParticleSystemIndex( $"death_pinkmist_nochunk" ), FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID )
		}
	}
	else
	{
		if ( victim.GetModelName() == FLYER_MODEL )
		{
			fxID = StartParticleEffectOnEntity( victim, GetParticleSystemIndex( $"death_pinkmist_LG" ), FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID )
		}
		else
		{
			fxID = StartParticleEffectOnEntity( victim, GetParticleSystemIndex( $"death_pinkmist" ), FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID )
		}
	}

	EffectSetControlPointVector( fxID, 1, flingDir )

	if ( isSoftenedLocale )
		return true

	vector angularVel = <0, 0, 0>
	float lifeTime    = 10.0
	CreateClientsideGibWithBodyGroupGibs( modelName, victim.GetOrigin(), angles, attackDir, angularVel, lifeTime, cullDist, 1024 )

	return true
}


void function ServerCallback_PlayScreenFXWarpJump()
{
	if ( IsWatchingReplay() )
		return

	thread PlayScreenFXWarpJump( GetLocalClientPlayer() )
}


void function PlayScreenFXWarpJump( entity clientPlayer )
{
	clientPlayer.EndSignal( "OnDeath" )
	clientPlayer.EndSignal( "OnDestroy" )

	entity player = GetLocalViewPlayer()
	int index     = GetParticleSystemIndex( SCREENFX_WARPJUMP )
	int indexD    = GetParticleSystemIndex( SCREENFX_WARPJUMPDLIGHT )
	int fxID      = StartParticleEffectInWorldWithHandle( index, <0, 0, 0>, <0, 0, 0> )
	int fxID2     = -1
	if ( IsValid( player.GetCockpit() ) )
	{
		fxID2 = StartParticleEffectOnEntity( player, indexD, FX_PATTACH_POINT_FOLLOW, player.GetCockpit().LookupAttachment( "CAMERA" ) )
		EffectSetIsWithCockpit( fxID2, true )
	}

	OnThreadEnd(
		function() : ( clientPlayer, fxID, fxID2 )
		{
			if ( IsValid( clientPlayer ) && !IsAlive( clientPlayer ) )
			{
				EffectStop( fxID, true, false )
				if ( fxID2 > -1 )
					EffectStop( fxID2, true, false )
			}
		}
	)

	wait 3.2
	if ( IsValid( player.GetCockpit() ) )
		thread TonemappingUpdateAfterWarpJump()
}

const EXPOSURE_RAMPDOWN_DURATION = 2.0
const EXPOSURE_RAMPDOWN_MAX = 20.0
const EXPOSURE_RAMPDOWN_MIN = 0.0
const MAX_RAMPDOWN_DURATION = 5.0
const MAX_RAMPDOWN_MAX = 3.0
const MAX_RAMPDOWN_MIN = 1.0

void function TonemappingUpdateAfterWarpJump()
{
	                                                                                                                                                             
	SetConVarFloat( "mat_envmap_scale", 0 )

	AutoExposureSetMaxExposureMultiplier( 500.0 )                                                                            

	                                                                                           
	float startTime = Time()
	while ( 1 )
	{
		float time         = Time() - startTime
		float factor       = GraphCapped( time, 0.0, EXPOSURE_RAMPDOWN_DURATION, 1.0, 0.0 )
		float toneMapScale = EXPOSURE_RAMPDOWN_MIN + (EXPOSURE_RAMPDOWN_MAX - EXPOSURE_RAMPDOWN_MIN) * factor * factor * factor * factor
		AutoExposureSetExposureCompensationBias( toneMapScale )
		AutoExposureSnap()
		wait  0
		if ( factor == 0 )
			break
	}

	                                                         
	startTime = Time()
	while ( 1 )
	{
		float time   = Time() - startTime
		float factor = GraphCapped( time, 0.0, MAX_RAMPDOWN_DURATION, 1.0, 0.0 )
		float scale  = MAX_RAMPDOWN_MIN + (MAX_RAMPDOWN_MAX - MAX_RAMPDOWN_MIN) * factor * factor
		AutoExposureSetMaxExposureMultiplier( scale )
		wait  0
		if ( factor == 0 )
			break
	}
}


void function SetPanelAlphaOverTime( var panel, int alpha, float duration )
{
	                                              
	Signal( panel, "PanelAlphaOverTime" )
	EndSignal( panel, "PanelAlphaOverTime" )
	EndSignal( panel, "OnDestroy" )

	float startTime = Time()
	float endTime   = startTime + duration
	int startAlpha  = Hud_GetPanelAlpha( panel )

	while ( Time() <= endTime )
	{
		float a = GraphCapped( Time(), startTime, endTime, startAlpha, alpha )
		Hud_SetPanelAlpha( panel, a )
		WaitFrame()
	}

	Hud_SetPanelAlpha( panel, alpha )
}


void function PlayShieldBreakEffect( entity ent )
{
	entity shieldEnt       = ent
	float shieldHealthFrac = GetShieldHealthFrac( shieldEnt )
	vector shieldColor     = GetShieldEffectCurrentColor( 1 - shieldHealthFrac )

	if ( ent.IsPlayer() )
	{
		int armorTier = EquipmentSlot_GetEquipmentTier( ent, "armor" )
		shieldColor = GetFXRarityColorForTier( armorTier )
	}
	else if ( ent.IsNPC() )
	{
		shieldColor = GetFXRarityColorForTier( eLootTier.COMMON )
	}

	int shieldBreakFX = GetParticleSystemIndex( SHIELD_BREAK_FX )

	int attachID
	if ( shieldEnt.IsTitan() )
		attachID = shieldEnt.LookupAttachment( "exp_torso_main" )
	else
		attachID = shieldEnt.LookupAttachment( "CHESTFOCUS" )        

	int shieldFXHandle = StartParticleEffectOnEntity( shieldEnt, shieldBreakFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, shieldColor )
}


void function PlayShieldActivateEffect( entity ent )
{
	entity shieldEnt       = ent
	float shieldHealthFrac = GetShieldHealthFrac( shieldEnt )
	vector shieldColor     = GetShieldEffectCurrentColor( 1 - shieldHealthFrac )

	if ( ent.IsPlayer() )
	{
		int armorTier = EquipmentSlot_GetEquipmentTier( ent, "armor" )
		shieldColor = GetFXRarityColorForTier( armorTier )
	}

	int shieldBreakFX = GetParticleSystemIndex( SHIELD_MAX_FX )

	bool isEvoShield = EvolvingArmor_IsEquipmentEvolvingArmor( EquipmentSlot_GetLootRefForSlot( ent, "armor" ) )
	if ( isEvoShield )
		shieldBreakFX = GetParticleSystemIndex( FX_SHIELD_EVO_UPGRADE_3P )

	int attachID
	if ( shieldEnt.IsTitan() )
		attachID = shieldEnt.LookupAttachment( "exp_torso_main" )
	else
		attachID = shieldEnt.LookupAttachment( "CHESTFOCUS" )

	int shieldFXHandle = StartParticleEffectOnEntity( shieldEnt, shieldBreakFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, shieldColor )
}


void function PlayIt( entity victim )
{
	float shieldHealthFrac = GetShieldHealthFrac( victim )

	int shieldbodyFX = GetParticleSystemIndex( SHIELD_BODY_FX )
	int attachID
	if ( victim.IsTitan() )
		attachID = victim.LookupAttachment( "exp_torso_main" )
	else
		attachID = victim.LookupAttachment( "CHESTFOCUS" )

	int shieldFXHandle = StartParticleEffectOnEntity( victim, shieldbodyFX, FX_PATTACH_POINT_FOLLOW, attachID )

	EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
}


void function PlayShieldHitEffect( PlayerDidDamageParams params, vector shieldColorOverride = < -1, -1, -1 > )
{
	entity player = GetLocalViewPlayer()
	entity victim = params.victim
	                                               
	                            
	                                    
	                                          
	                                      
	                                
	                               
	                                                                  

	                                                 
	                                                                                     

	float shieldHealthFrac = GetShieldHealthFrac( victim )

	int shieldbodyFX = GetParticleSystemIndex( SHIELD_BODY_FX )
	int attachID
	if ( victim.IsTitan() )
		attachID = victim.LookupAttachment( "exp_torso_main" )
	else
		attachID = victim.LookupAttachment( "CHESTFOCUS" )        

	int shieldFXHandle = StartParticleEffectOnEntity( victim, shieldbodyFX, FX_PATTACH_POINT_FOLLOW, attachID )

	vector color

	if ( shieldColorOverride == < -1, -1, -1 > )
		color = GetShieldEffectCurrentColor( 1 - shieldHealthFrac )
	else
		color = shieldColorOverride

	EffectSetControlPointVector( shieldFXHandle, 1, color )
}

const vector SHIELD_COLOR_CHARGE_FULL = <115, 247, 255>        
const vector SHIELD_COLOR_CHARGE_MED = <200, 128, 80>          
const vector SHIELD_COLOR_CHARGE_EMPTY = <200, 80, 80>       

const SHIELD_COLOR_CROSSOVERFRAC_FULL2MED = 0.75                                                                           
const SHIELD_COLOR_CROSSOVERFRAC_MED2EMPTY = 0.95                                                                                  

vector function GetShieldEffectCurrentColor( float shieldHealthFrac )
{
	vector color1 = SHIELD_COLOR_CHARGE_FULL
	vector color2 = SHIELD_COLOR_CHARGE_MED
	vector color3 = SHIELD_COLOR_CHARGE_EMPTY

	float crossover1 = SHIELD_COLOR_CROSSOVERFRAC_FULL2MED                                                               
	float crossover2 = SHIELD_COLOR_CROSSOVERFRAC_MED2EMPTY                                                                     

	vector colorVec = <0, 0, 0>
	                                           
	if ( shieldHealthFrac < crossover1 )
	{
		colorVec.x = Graph( shieldHealthFrac, 0, crossover1, color1.x, color2.x )
		colorVec.y = Graph( shieldHealthFrac, 0, crossover1, color1.y, color2.y )
		colorVec.z = Graph( shieldHealthFrac, 0, crossover1, color1.z, color2.z )
	}
	else if ( shieldHealthFrac < crossover2 )
	{
		colorVec.x = Graph( shieldHealthFrac, crossover1, crossover2, color2.x, color3.x )
		colorVec.y = Graph( shieldHealthFrac, crossover1, crossover2, color2.y, color3.y )
		colorVec.z = Graph( shieldHealthFrac, crossover1, crossover2, color2.z, color3.z )
	}
	else
	{
		                                                               
		colorVec.x = color3.x
		colorVec.y = color3.y
		colorVec.z = color3.z
	}

	return colorVec
}


string function GetPlayerDeathSound1P()
{
	if ( IsFiringRangeGameMode() )
		return "player_death_begin_survival_firingrange"

	return "player_death_begin_survival"
}


void function PlayLocal1PDeathSound()
{
	EmitSoundOnEntity( GetLocalClientPlayer(), GetPlayerDeathSound1P() )
}


void function StopLocal1PDeathSound()
{
	StopSoundOnEntity( GetLocalClientPlayer(), GetPlayerDeathSound1P() )
}


void function OnClientPlayerAlive( entity player )
{
	player.Signal( "OnClientPlayerAlive" )                                                                         
	player.EndSignal( "OnClientPlayerAlive" )

	if ( IsWatchingReplay() )
		return

	if ( GetGameState() < eGameState.Playing )
		return
}


void function OnClientPlayerDying( entity player )
{
	player.Signal( "OnClientPlayerDying" )                                                                         
	player.EndSignal( "OnClientPlayerDying" )

	Assert( player == GetLocalClientPlayer() )

	if ( IsWatchingReplay() )
		return

	player.cv.deathTime = Time()

	thread DeathCamCheck( player )
}


void function DeathCamCheck( entity player )
{
	wait GetRespawnButtonCamTime( player )
}


void function ShowSpawnDelayMessage( float nextSpawnTime )
{
	float waitTime = max( nextSpawnTime - Time(), 0 )

	if ( waitTime < 1.0 )
		return

	entity player = GetLocalClientPlayer()

	while ( !IsAlive( player ) && waitTime > 0.0 )
	{
		waitTime = max( nextSpawnTime - Time(), 0 )

		AddPlayerHint( waitTime, 0.25, $"", "#GAMEMODE_DEPLOYING_IN_N", int( waitTime ) )

		wait 1.0
	}
}


void function ServerCallback_HideNextSpawnMessage()
{
	entity player = GetLocalClientPlayer()

	HidePlayerHint( "#GAMEMODE_DEPLOYING_IN_N" )
}


bool function IsPlayerEliminated( entity player )
{
	bool rv = player.GetPlayerNetBool( "isEliminated" )
	return rv
}


void function PlayerFieryDeath( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnClientPlayerAlive" )
	clGlobal.levelEnt.EndSignal( "OnSpectatorMode" )

	vector offset = <0, 0, 0>
	if ( player.IsTitan() )
		offset = <0, 0, 96>

	entity scriptRef = CreatePropDynamic( $"mdl/dev/empty_model.rmdl", player.GetOrigin() + offset, player.GetAngles() )
	scriptRef.SetParent( player )

	int fxHandle = StartParticleEffectOnEntity( scriptRef, GetParticleSystemIndex( $"P_burn_player" ), FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID )

	OnThreadEnd(
		function () : ( fxHandle, scriptRef )
		{
			EffectStop( fxHandle, false, false )
			if ( IsValid( scriptRef ) )
				scriptRef.Destroy()
		}
	)
	WaitForever()
}


void function ServerCallback_GiveMatchLossProtection()
{
	clGlobal.showMatchLossProtection = true
}


void function EnableDoDeathCallback( entity ent )
{
	ent.DoDeathCallback( true )
}


void function ServerCallback_GameModeAnnouncement()
{
	entity player   = GetLocalClientPlayer()
	string gameMode = GameRules_GetGameMode()

	if ( GameMode_GetCustomIntroAnnouncement( gameMode ) != null )
	{
		void functionref(entity) func = GameMode_GetCustomIntroAnnouncement( gameMode )
		func( player )
		return
	}

	int team = player.GetTeam()

	float totalDuration = 0.0

	AnnouncementData announcement

	if ( GetGameState() == eGameState.Resolution )
	{
		                   
		announcement = Announcement_Create( "#GAMEMODE_EPILOGUE" )
	}
	else
	{
		announcement = Announcement_Create( GAMETYPE_TEXT[gameMode] )
		announcement.announcementStyle = ANNOUNCEMENT_STYLE_BIG

		                                                               
		Announcement_SetSubText( announcement, GAMEDESC_CURRENT )

		if ( GameMode_IsDefined( gameMode ) )
		{
			if ( GameMode_GetAttackDesc( gameMode ) != "" && team == GetGlobalNetInt( "attackingTeam" ) )
				Announcement_SetSubText( announcement, GameMode_GetAttackDesc( gameMode ) )

			if ( GameMode_GetDefendDesc( gameMode ) != "" && team != GetGlobalNetInt( "attackingTeam" ) )
				Announcement_SetSubText( announcement, GameMode_GetDefendDesc( gameMode ) )
		}
	}


	AnnouncementFromClass( player, announcement )                             
}


bool function GetHideCrosshairHitIndicatorOverride()
{
	return file.hideCrosshairHitIndicatorOverride
}


void function SetHideCrosshairHitIndicatorOverride( bool value )
{
	file.hideCrosshairHitIndicatorOverride = value
}