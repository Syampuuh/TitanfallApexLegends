untyped

globalize_all_functions

global const float FLOAT_INFINITY = 3.40282e+38 + 3.40282e+38
global const float FLOAT_INDETERMINATE = FLOAT_INFINITY * 0.0
global const float FLOAT_NAN = -FLOAT_INDETERMINATE

global const float DEG_TO_RAD = 0.01745329251994              
global const float RAD_TO_DEG = 57.29577951308232              

global const float DOT_1DEGREE =	0.9998476951564
global const float DOT_2DEGREE =	0.9993908270191
global const float DOT_3DEGREE =	0.9986295347546
global const float DOT_4DEGREE =	0.9975640502598
global const float DOT_5DEGREE =	0.9961946980917
global const float DOT_6DEGREE =	0.9945218953683
global const float DOT_7DEGREE =	0.9925461516413
global const float DOT_8DEGREE =	0.9902680687416
global const float DOT_9DEGREE =	0.9876883405951
global const float DOT_10DEGREE =	0.9848077530122
global const float DOT_15DEGREE =	0.9659258262891
global const float DOT_20DEGREE =	0.9396926207859
global const float DOT_25DEGREE =	0.9063077870367
global const float DOT_30DEGREE =	0.866025403784
global const float DOT_45DEGREE =	0.707106781187
global const float DOT_60DEGREE =	0.5
global const float DOT_80DEGREE =	0.17364817766
global const float DOT_85DEGREE =	0.0871557427477

global const string WHITESPACE_CHARACTERS = "\r\n\t "                                   

                        
global const PST_TIME_ZONE_OFFSET = -8                               
global const PDT_TIME_ZONE_OFFSET = -7
global enum eDaysOfWeek
{
	SUNDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	_NUM_DAYS
}
global const array<string> MONTH_NAMES = [
	"#MONTH_JAN",
	"#MONTH_FEB",
	"#MONTH_MAR",
	"#MONTH_APR",
	"#MONTH_MAY",
	"#MONTH_JUN",
	"#MONTH_JUL",
	"#MONTH_AUG",
	"#MONTH_SEP",
	"#MONTH_OCT",
	"#MONTH_NOV",
	"#MONTH_DEC",
]
global struct TimeParts
{
	int year
	int month
	int day
	int hour
	int minute
	int second
}
global struct DisplayTime
{
	int days
	int hours
	int minutes
	int seconds
}

global struct Coord
{
	vector pos
	vector ang
}

global struct AABB
{
	vector mins
	vector maxs
}

global enum eStreamMode
{
	DISABLED,
	KILLER,
	ALL,
}

global struct Timeout
{
	float startTime
	float duration
}

global struct ShuffleData
{
	array<int> _indices
	int        _pos
}

global struct DebounceData
{
	float              lastRunTime = 0.0
	bool               isQueued = false
	void functionref() latestFunc
}

const int THROTTLE_DEFAULT_MAXPERINTERVAL = 1
const float THROTTLE_DEFAULT_INTERVAL = 1.0
global struct ThrottleData
{
	float lastProcessTime = 0.0
	float decayingActionCount = 0
	float interval = THROTTLE_DEFAULT_INTERVAL
	int   maxPerInterval = THROTTLE_DEFAULT_MAXPERINTERVAL
}

global struct WaitQuotaItem
{
	int _count
	int _budget
}

struct
{
	int  lastHostThreadMode
	int  lastScriptPrecacheErrors
	int  lastReportFatal
	bool devUnlockedSPMissions

	int hud_setting_accessibleChatCache
} file

void function ShUtilityAll_Init()
{
	#document( "DistanceAlongVector", "" )
	#document( "GetClosestPointOnLineSegment", "Get the nearest point on a line segment" )
	#document( "GetDistanceFromLineSegment", "" )
	#document( "GetDistanceSqrFromLineSegment", "" )

	RegisterSignal( "Timeout" )
	RegisterSignal( "CancelTimeout" )

	#if !UI                                                                                                      

		                    
		PrecacheParticleSystem( $"P_wpn_ghurka_swipe_FP" )
		PrecacheParticleSystem( $"P_wpn_ghurka_swipe_3P" )
		PrecacheParticleSystem( $"P_ghurka_amb_plasma_FP" )
		PrecacheParticleSystem( $"P_ghurka_amb_plasma_3P" )
		PrecacheParticleSystem( $"P_ghurka_plasma_mdl" )
		PrecacheParticleSystem( $"P_ghurka_plasma_mdl_3P" )
	#endif
}


Timeout function BeginTimeout( float duration )
{
	Timeout to
#if UI
	to.startTime = UITime()
#else
	to.startTime = Time()
#endif      
	to.duration = duration
	thread __RunTimeoutInternal( to )
	return to
}


void function __RunTimeoutInternal( Timeout to )
{
	EndSignal( to, "CancelTimeout" )
	wait to.duration
	Signal( to, "Timeout" )
}


void function CancelTimeoutIfAlive( Timeout to )
{
	Signal( to, "CancelTimeout" )
}
                                                
   
  	                          
   

void function PrintObject( obj, int indent, int depth, int maxDepth )
{
	if ( IsTable( obj ) )
	{
		if ( depth >= maxDepth )
		{
			printl( "{...}" )
			return
		}

		printl( "{" )
		foreach ( k, v in obj )
		{
			print( TableIndent( indent + 2 ) + k + " = " )
			PrintObject( v, indent + 2, depth + 1, maxDepth )
		}
		printl( TableIndent( indent ) + "}" )
	}
	else if ( IsArray( obj ) )
	{
		if ( depth >= maxDepth )
		{
			printl( "[...]" )
			return
		}

		printl( "[" )
		foreach ( v in obj )
		{
			print( TableIndent( indent + 2 ) )
			PrintObject( v, indent + 2, depth + 1, maxDepth )
		}
		printl( TableIndent( indent ) + "]" )
	}
	else if ( obj != null )
	{
		printl( "" + obj )
	}
	else
	{
		printl( "<null>" )
	}
}

                                       
string function GetStack( int offset = 2 )
{
	string stackInfo = ""

	for ( int i = offset; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break

		if ( i != offset )
		{
			stackInfo += "\n"
		}

		stackInfo += getstackinfos( i )["src"] + " [" + getstackinfos( i )["line"] + "], " + getstackinfos( i )["func"] + "()"
	}

	return stackInfo
}

string function GetPreviousFunction()
{
	int i = 3
	if ( !("src" in getstackinfos( i )) )
		return ""
	return "Called from: " + getstackinfos( i )["src"] + " [" + getstackinfos( i )["line"] + "] : " + getstackinfos( i )["func"] + "() "
}


bool function IsNewThread()
{
	int i
	for ( i = 0 ; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break
	}

	return (i == 3)
}


bool function CallingFuncIsNewThread()
{
	int i
	for ( i = 0 ; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break
	}

	const int CHECK_DEPTH = 4
	return (i == CHECK_DEPTH)
}


void function AssertIsNewThread()
{
	Assert( CallingFuncIsNewThread(), "Must be threaded" )
}


void function AssertParameters( func, int paramCount, string paramDesc )
{
	table funcInfos = expect table( func.getinfos() )
	string funcName = expect string( funcInfos.name )
	                                                                 
	Assert( funcInfos.parameters.len() == (paramCount + 1), "Function \"" + funcName + "\" must have exactly " + paramCount + " parameters (" + paramDesc + ")." )
}


string function GetNameForEnum( table<string, int> enumTable, int val )
{
	foreach ( string name, int index in enumTable )
	{
		if ( index == val )
			return name
	}
	return format( "%s() - INVALID: %d", FUNC_NAME(), val )
}


void function PrintTable( tbl, int indent = 0, int maxDepth = 4 )
{
	print( TableIndent( indent ) )
	PrintObject( tbl, indent, 0, maxDepth )
}


string function TableIndent( int indent )
{
	return ("                                            ").slice( 0, indent )
}


string function RepeatString( string str, int times )
{
	string out = ""
	for ( int i = 0; i < times; i++ )
	{
		out += str
	}
	return out
}


bool function IsOdd( int num )
{
	return (num % 2) == 1
}


bool function IsEven( int num )
{
	return !IsOdd( num )
}


float function DegToRad( float degrees )
{
	return degrees * DEG_TO_RAD
}


float function RadToDeg( float radians )
{
	return radians * RAD_TO_DEG
}


float function CalcFOVScale( float baseFOV, float zoomScale )
{
	return RadToDeg( atan( tan( DegToRad( baseFOV / 2.0 ) ) / zoomScale ) ) * 2
}

int function CalcZoomMag( float baseFOV, float fov )
{
	float magf = tan( DegToRad( baseFOV/2 ) ) / tan( DegToRad( fov/2 ) )
	return int ( floor( magf + 0.5) )
}


vector function RotateAroundOrigin2D( vector originToRotate, vector origin, float angRadians )
{
	vector rotated     = <0, 0, originToRotate.z>
	float sinOffsetAng = sin( angRadians )
	float cosOffsetAng = cos( angRadians )
	vector offset      = originToRotate - origin

	rotated.x = origin.x + (offset.x * cosOffsetAng) - (offset.y * sinOffsetAng)
	rotated.y = origin.y + (offset.x * sinOffsetAng) + (offset.y * cosOffsetAng)

	return rotated
}


vector function RotateVector( vector vec, vector rotateAngles )
{
	return vec.x * AnglesToForward( rotateAngles ) + vec.y * -1.0 * AnglesToRight( rotateAngles ) + vec.z * AnglesToUp( rotateAngles )

	                                                            
	                                             
	                                                            
	                                                        
}


AABB function RotateAABB( vector mins, vector maxs, vector rotateAngles )
{
	vector cnr_000 = RotateVector( < mins.x, mins.y, mins.z >, rotateAngles )
	vector cnr_001 = RotateVector( < mins.x, mins.y, maxs.z >, rotateAngles )
	vector cnr_010 = RotateVector( < mins.x, maxs.y, mins.z >, rotateAngles )
	vector cnr_011 = RotateVector( < mins.x, maxs.y, maxs.z >, rotateAngles )
	vector cnr_100 = RotateVector( < maxs.x, mins.y, mins.z >, rotateAngles )
	vector cnr_101 = RotateVector( < maxs.x, mins.y, maxs.z >, rotateAngles )
	vector cnr_110 = RotateVector( < maxs.x, maxs.y, mins.z >, rotateAngles )
	vector cnr_111 = RotateVector( < maxs.x, maxs.y, maxs.z >, rotateAngles )

	AABB result
	result.mins = <
	min( cnr_000.x, min( cnr_001.x, min( cnr_010.x, min( cnr_011.x, min( cnr_100.x, min( cnr_101.x, min( cnr_110.x, cnr_111.x ) ) ) ) ) ) ),
	min( cnr_000.y, min( cnr_001.y, min( cnr_010.y, min( cnr_011.y, min( cnr_100.y, min( cnr_101.y, min( cnr_110.y, cnr_111.y ) ) ) ) ) ) ),
	min( cnr_000.z, min( cnr_001.z, min( cnr_010.z, min( cnr_011.z, min( cnr_100.z, min( cnr_101.z, min( cnr_110.z, cnr_111.z ) ) ) ) ) ) )
	>
	result.maxs = <
	max( cnr_000.x, max( cnr_001.x, max( cnr_010.x, max( cnr_011.x, max( cnr_100.x, max( cnr_101.x, max( cnr_110.x, cnr_111.x ) ) ) ) ) ) ),
	max( cnr_000.y, max( cnr_001.y, max( cnr_010.y, max( cnr_011.y, max( cnr_100.y, max( cnr_101.y, max( cnr_110.y, cnr_111.y ) ) ) ) ) ) ),
	max( cnr_000.z, max( cnr_001.z, max( cnr_010.z, max( cnr_011.z, max( cnr_100.z, max( cnr_101.z, max( cnr_110.z, cnr_111.z ) ) ) ) ) ) )
	>
	return result
}


float function RadWrap( float ang, float lowValue = -PI )
{
	return ((ang - lowValue) % (2.0 * PI)) + lowValue
}


vector function FindAnyPerpendicularVector( vector v )
{
	return RotateVector( <0, 0, 1> * Length( v ), VectorToAngles( Normalize( v ) ) )
}


float function GetArcLengthDeg( float startDeg, float endDeg )
{
	if ( endDeg < startDeg )
		endDeg += 360

	return fabs( startDeg - endDeg )
}

bool function CirclesAreIntersecting( vector org1, float rad1, vector org2, float rad2 )
{
	float distBetweenCircles = Distance( org1, org2 )
	float epsilon = 1

	                                      
	if ( distBetweenCircles < fabs( rad1 - rad2 ) + epsilon )
		return false
	else if ( distBetweenCircles < fabs( rad2 - rad1 ) + epsilon )
		return false

	                                 
	else if ( distBetweenCircles == 0 && rad2 == rad1 )
		return false

	                          
	else if ( distBetweenCircles > ( rad1 + rad2 + epsilon ) )
		return false

	return true
}

bool function IsCircleAEncompassingCircleB( vector org1, float rad1, vector org2, float rad2 )
{
	float epsilon
	float distBetweenCircles = Distance( org1, org2 )
	if ( ( distBetweenCircles < fabs( rad1 - rad2 ) + epsilon ) && ( rad1 > rad2 ) )
		return true

	return false
}

array<vector> function GetCircleToCircleIntersectionPoints( vector org1, float rad1, vector org2, float rad2, vector up = < 0, 0, 1 >, bool debugDraw = false )
{
	float distBetweenCircles        = Distance( org1, org2 )
	float distOrg1ToIntersectCenter = ( ( rad1 * rad1 ) - ( rad2 * rad2 ) + ( distBetweenCircles * distBetweenCircles ) ) / ( 2.0 * distBetweenCircles )

	vector intersectDir    = Normalize( org2 - org1 )
	vector intersectCenter = intersectDir * distOrg1ToIntersectCenter

	float intersectHeight = sqrt( ( rad1 * rad1 ) - ( distOrg1ToIntersectCenter * distOrg1ToIntersectCenter ) )
	vector heightDir      = CrossProduct( up, intersectDir )

	array<vector> intersectionPoints = [ intersectCenter + ( heightDir * intersectHeight ), intersectCenter - ( heightDir * intersectHeight ) ]

	if ( debugDraw )
	{
		#if SERVER || CLIENT
		                 
		DebugDrawLine( org1, org1 + < 0, 0, 32 >, COLOR_RED, true, 1.0 )
		DebugDrawLine( org2, org2 + < 0, 0, 32 >, COLOR_GREEN, true, 1.0 )

		                               
		DebugDrawLine( org2, intersectionPoints[ 0 ] + org1, COLOR_WHITE, true, 1.0 )
		DebugDrawLine( org2, intersectionPoints[ 1 ] + org1, COLOR_BLACK, true, 1.0 )
		#endif
	}

	return intersectionPoints
}

bool function IsLobbyMapName( string levelname )
{
	if ( levelname == "mp_lobby" )
		return true

	return false
}

bool function IsStormPoint()
{
	string mapName
	#if UI
		mapName = GetActiveLevel()
	#else
		mapName = GetMapName()
	#endif
	return mapName == "mp_rr_tropic_island"
}

bool function Freelance_IsHubLevel()
{
#if 0
	      
		                                 
	     
		                             
	      

	                 
	 
		                    
			           
	 
#endif     
	return false
}


bool function Is2TeamPvPGame()
                                                                                             
{
	return (MAX_TEAMS == 2)
}


bool function IsMultiTeamPvPGame()
{
	return (MAX_TEAMS > 2)
}


bool function IsFFAGame()
{
	return (MAX_TEAMS == MAX_PLAYERS)
}


bool function IsSingleTeamMode()
{
	return (1 == GetCurrentPlaylistVarInt( "max_teams", 2 ))
}


bool function IsMultiTeamMission()
{
	if ( IsSingleTeamMode() )
		return false
	if ( Freelance_IsHubLevel() )
		return false
	return true
}


bool function IsShotgunsAndSnipersMode()
{
	return GetCurrentPlaylistVarBool( "shotguns_and_snipers_mode", false )
}


bool function IsArmedAndDangerousEvolvedMode()
{
	return GetCurrentPlaylistName() == "armed_and_dangerous_evolved"
}


int function GetExpectedSquadSize( entity player = null )
{
	                                                                                               
	return int ( GetCurrentPlaylistVarFloat( "max_players", 60 ) / GetCurrentPlaylistVarFloat( "max_teams", 20 ) )
}


bool function IsDuoMode()
{
	return (GetCurrentPlaylistVarFloat( "max_players", 60 ) / GetCurrentPlaylistVarFloat( "max_teams", 20 ) == 2.0)
}


bool function IsSoloMode()
{
	return GetCurrentPlaylistVarBool( "solo_mode", false )
}


bool function IsLastPlaylistSolo( entity player )
{
	return GetPersistentLastGameTypeFlag( player, eGameType.SOLO )
}


bool function IsS03E03Mode()
{
	return GetCurrentPlaylistVarBool( "s03e03_mode", false )
}


bool function IsThirdPersonMode()
{
	return GetCurrentPlaylistVarBool( "thirdperson_mode", false )
}


bool function IsSpawnOnSquadMode()
{
	return GetCurrentPlaylistVarBool( "spawn_on_squad_mode", false )
}

bool function IsShadowRoyaleMode()
{
	return GetCurrentPlaylistVarBool( "shadow_royale_mode", false )
}

bool function IsPVEMode()
{
	#if UI
		{
			string playlistName = GetCurrentPlaylistName()
			if ( playlistName.find( "freelance" ) == 0 )
				return true

			return false
		}
	#else
		#if MP_PVEMODE
			return true
		#else
			return false
		#endif
	#endif              
}


bool function IsNightMapMode()
{
	return GetCurrentPlaylistVarBool( "night_map_mode", false )
}


bool function IsAlwaysBeClosingMode()
{
	return GetCurrentPlaylistVarBool( "always_be_closing_mode", false )
}


bool function IsGoldRushMode()
{
	return GetCurrentPlaylistVarBool( "gold_rush_mode", false )
}


bool function IsDummieMode()
{
	return GetCurrentPlaylistVarBool( "dummie_mode", false )
}

bool function IsRingCollapseGameMode()
{
	return GetCurrentPlaylistVarBool( "is_ring_collapse", false )
}

bool function IsACETakeOverGameMode()
{
	return GetCurrentPlaylistVarBool( "is_ace_takeover", false )
}

bool function IsAprilFools_S8_Mode()
{
	return GetCurrentPlaylistVarBool( "is_april_fools_s8", false )
}

bool function HasBoundaryWall()
{
	return GetCurrentPlaylistVarBool( "has_boundary_wall", false )
}

                        
bool function Control_IsModeEnabled()
{
	#if UI
		return GetCurrentPlaylistVarBool( "is_control_game", false )
	#endif

	#if CLIENT || SERVER
		return GameRules_GetGameMode() == GAMEMODE_CONTROL
	#endif
}
                              

                      
                                           
 
                                                                    
 
      

int function GetEnemyTeam( int team )
{
	if ( IsMultiTeamPvPGame() )
		return TEAM_UNASSIGNED

	if ( team == TEAM_SPECTATOR )
		return TEAM_UNASSIGNED

	Assert( team == TEAM_IMC || team == TEAM_MILITIA )

	return (TEAM_IMC + TEAM_MILITIA) - team
}


array<int> function GetAllEnemyTeams( int team )
{
	array<int> resultArray
	if ( Is2TeamPvPGame() || IsSingleTeamMode() )
	{
		resultArray.append( GetEnemyTeam( team ) )
		return resultArray
	}

	int maxTeams = GetCurrentPlaylistVarInt( "max_teams", MAX_TEAMS )
	Assert( team >= TEAM_MULTITEAM_FIRST )
	Assert( team <= TEAM_MULTITEAM_LAST )

	for ( int i = TEAM_MULTITEAM_FIRST; i < TEAM_MULTITEAM_FIRST + maxTeams; ++i )
	{
		if ( i == team )
			continue

		resultArray.append( i )
	}

	return resultArray
}


array<int> function GetAllTeams()
{
	array<int> resultArray

	int maxTeams = GetCurrentPlaylistVarInt( "max_teams", MAX_TEAMS )

	for ( int i = TEAM_MULTITEAM_FIRST; i < TEAM_MULTITEAM_FIRST + maxTeams; ++i )
	{
		resultArray.append( i )
	}

	return resultArray
}

                                                                    
bool function IsPositionWithinRadius( float radius, vector position1, vector position2 )
{
	float radiusToTestSqr = pow( radius, 2 )
	float positionDistSqr = Distance2DSqr( position1, position2 )

	if ( positionDistSqr < radiusToTestSqr )
		return true

	return false
}

int function GetDefaultNonSpectatorTeam()
{
	int resultTeam

	if ( Is2TeamPvPGame() )
		resultTeam = TEAM_IMC
	else
		resultTeam = TEAM_MULTITEAM_FIRST

	return resultTeam
}


string function GetMapDisplayNameAllCaps( string mapname )
{
	return "#" + mapname + "_ALLCAPS"
}


string function GetMapDisplayName( string mapname )
{
	return "#" + mapname
}


string function GetMapDisplayDesc( string mapname )
{
	return "#" + mapname + "_CLASSIC_DESC"
}


string function StringReplace( string baseString, string searchString, string replaceString )
{
	Assert( searchString.len() > 0, "cannot use StringReplace with an empty searchString" )

	string newString = ""

	int searchIndex = 0
	while( searchIndex < (baseString.len() - searchString.len() + 1) )
	{
		var occurenceIndexOrNull = baseString.find_olduntyped( searchString, searchIndex )

		if ( occurenceIndexOrNull == null )
			break

		int occurenceIndex = expect int( occurenceIndexOrNull )

		newString += baseString.slice( searchIndex, occurenceIndex )
		newString += replaceString

		searchIndex = occurenceIndex + searchString.len()
	}

	newString += baseString.slice( searchIndex )

	return newString
}


var function MakeRegexp( string patternString )
{
	return regexp( patternString )
}


bool function Regexp_DoesMatch( var pattern, string str )
{
	return expect bool(pattern.match( str ))
}


array<string> function Regexp_Match( var pattern, string str )
{
	var captureListOrNull = pattern.capture( str )

	if ( captureListOrNull == null )
		return []

	array captureList = expect array( captureListOrNull )

	array<string> captures = []
	foreach ( var captureRawInfo in captureList )
	{
		table captureInfo = expect table( captureRawInfo )
		captures.append( str.slice( captureInfo.begin, captureInfo.end ) )
	}

	return captures
}


bool function DoesMatchRegexp( string baseString, string patternString )
{
	return expect bool(regexp( patternString ).match( baseString ))
}


string function RegexpReplace( string baseString, string patternString, string replaceString )
{
	var regexpReplaceSubstitutionPattern = regexp( "\\$(\\d+)" )                            

	Assert( patternString.len() > 0, "cannot use RegexpReplace with an empty patternString" )

	array<var> replaceStringPartList = []

	int substitutionSearchIndex = 0
	while( substitutionSearchIndex < replaceString.len() )
	{
		var substitutionCaptureListOrNull = regexpReplaceSubstitutionPattern.capture( replaceString, substitutionSearchIndex )

		if ( substitutionCaptureListOrNull == null )
			break

		array substitutionCaptureList = expect array( substitutionCaptureListOrNull )

		table matchInfo = expect table( substitutionCaptureList[0] )

		string skipped = replaceString.slice( substitutionSearchIndex, matchInfo.begin )
		if ( skipped.len() > 0 )
		{
			replaceStringPartList.append( replaceString.slice( substitutionSearchIndex, matchInfo.begin ) )
		}

		table numberCaptureInfo = expect table( substitutionCaptureList[1] )
		replaceStringPartList.append( int( replaceString.slice( numberCaptureInfo.begin, numberCaptureInfo.end ) ) )

		substitutionSearchIndex = expect int( matchInfo.end )
	}

	string replaceStringRemainder = replaceString.slice( substitutionSearchIndex )
	if ( replaceStringRemainder.len() > 0 )
	{
		replaceStringPartList.append( replaceStringRemainder )
	}

	string newString = ""
	var pattern      = regexp( patternString )

	int searchIndex = 0
	while( searchIndex < baseString.len() )
	{
		var captureListOrNull = pattern.capture( baseString, searchIndex )

		if ( captureListOrNull == null )
			break

		array captureList = expect array( captureListOrNull )

		table matchInfo = expect table( captureList[0] )

		newString += baseString.slice( searchIndex, matchInfo.begin )

		foreach ( var replaceStringPart in replaceStringPartList )
		{
			if ( type( replaceStringPart ) == "int" )
			{
				int captureIndex = expect int( replaceStringPart )

				Assert( captureIndex < captureList.len(), "Invalid substituion in replacement string (saw $" + captureIndex + " but there's only " + captureList.len() + " captures)" )

				table captureInfo = expect table( captureList[captureIndex] )
				newString += baseString.slice( captureInfo.begin, captureInfo.end )
			}
			else
			{
				newString += expect string( replaceStringPart )
			}
		}

		searchIndex = expect int( matchInfo.end )
	}

	newString += baseString.slice( searchIndex )

	return newString
}


string function RegexpReplaceFunc( string baseString, string patternString, string functionref( array<string> captures ) replaceFunc )
{
	Assert( patternString.len() > 0, "cannot use RegexpReplace with an empty patternString" )

	string newString = ""
	var pattern      = regexp( patternString )

	int searchIndex = 0
	while( searchIndex < baseString.len() )
	{
		var captureListOrNull = pattern.capture( baseString, searchIndex )

		if ( captureListOrNull == null )
			break

		array captureList = expect array( captureListOrNull )

		table matchInfo = expect table( captureList[0] )

		newString += baseString.slice( searchIndex, matchInfo.begin )

		array<string> captureStrList = []
		foreach ( var captureInfoRaw in captureList )
		{
			table captureInfo = expect table( captureInfoRaw )
			captureStrList.append( baseString.slice( captureInfo.begin, captureInfo.end ) )
		}

		newString += replaceFunc( captureStrList )

		searchIndex = expect int( matchInfo.end )
	}

	newString += baseString.slice( searchIndex )

	return newString
}


array<array<string> > function RegexpFindAll( string baseString, string patternString )
{
	array<array<string> > matches = []
	var pattern                   = regexp( patternString )

	int searchIndex = 0
	while( searchIndex < baseString.len() )
	{
		var captureListOrNull = pattern.capture( baseString, searchIndex )

		if ( captureListOrNull == null )
			break

		array captureList = expect array( captureListOrNull )

		table matchInfo = expect table( captureList[0] )

		array<string> captureStringList = []
		foreach ( var captureRawInfo in captureList )
		{
			table captureInfo = expect table( captureRawInfo )
			if( captureInfo.end < searchIndex )
				captureStringList.append( "" )                                                                      
			else
				captureStringList.append( baseString.slice( captureInfo.begin, captureInfo.end ) )
		}

		searchIndex = expect int( matchInfo.end )

		matches.append( captureStringList )
	}

	return matches
}


float function RoundToNearestInt( float value )
{
	return floor( value + 0.5 )
}


float function RoundToNearestMultiplier( float value, float multiplier )
{
	Assert( multiplier > 0 )
	bool neg = value < 0
	value = fabs( value )

	float remainder = value % multiplier

	value -= remainder

	if ( remainder >= (multiplier / 2) )
		value += multiplier

	return neg ? -value : value
}


int function HIWORD( int value )
{
	return (value >> 16) & 0xFFFF
}


int function LOWORD( int value )
{
	return value
}


bool function IsWeaponKeyFieldDefined( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )

	if ( val != null )
		return true

	return false
}


string function GetWeaponInfoFileKeyField_GlobalString( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect string( val )
}

string function GetWeaponInfoFileKeyField_WithMods_GlobalString( string ref, array<string> mods, string variable )
{
	var val = GetWeaponInfoFileKeyField_WithMods_Global( ref, mods, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect string( val )
}

int function GetWeaponInfoFileKeyField_GlobalInt( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect int( val )
}


int function GetWeaponInfoFileKeyField_GlobalInt_WithDefault( string ref, string variable, int defaultVal )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	return val != null ? expect int( val ) : defaultVal
}


float function GetWeaponInfoFileKeyField_GlobalFloat( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect float( val )
}


bool function GetWeaponInfoFileKeyField_GlobalBool( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect bool( val )
}

vector function GetWeaponInfoFileKeyField_GlobalVectorFloat( string ref, string variable, string delimiter = WHITESPACE_CHARACTERS )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	expect string( val )
	array<string> arr = split( val, delimiter )
	Assert( arr.len() >= 3, "Vector value \"" + val + " has < 3 arguments" )
	return <float(arr[0]), float(arr[1]), float(arr[2])>
}

vector function GetWeaponInfoFileKeyField_GlobalVectorInt( string ref, string variable, string delimiter = WHITESPACE_CHARACTERS )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	expect string( val )
	array<string> arr = split( val, delimiter )
	Assert( arr.len() >= 3, "Vector value \"" + val + " has < 3 arguments" )
	return <int(arr[0]), int(arr[1]), int(arr[2])>
}


#if SERVER
       
                                                   
 
	                                        
	                       
	                              
	         
	                       
	 
		                                 
		   
	 
	                       
 
      
#endif

#if SERVER
                                                             
 
	                                       
		      

	                                        
	                  

	                                 
 
#endif


#if SERVER
                                                            
 
	                                        
	                        
	 
		                  
			           
	 
	            
 
#endif


#if SERVER
                                                             
 
	                                        
		      

	                                        
	                             

	                                 
 
#endif


#if SERVER
                                                   
 
	                               
 
#endif


void function WaitFrame()
{
	                                                                                                                                                                          
	wait 0.0001
}


void function WaitFrames( int frames )
{
	int framesRemaining = frames
	while ( framesRemaining > 0 )
	{
		WaitFrame()
		framesRemaining--
	}
}


#if SERVER
                                          
                                    
 
	                                                               	                          
	                          
 
#endif


string function VectorToString( vector vec )
{
	return "< " + vec.x + "," + vec.y + "," + vec.z + " >"
}

string function VectorToColorString( vector color, float alpha )
{
	return color.x + " " + color.y + " " + color.z + " " + alpha
}

vector function FlattenNormalizeVec( vector v )
{
	return Normalize( <v.x, v.y, 0> )
}

bool function VectorWithinBounds( vector v, float maxValue )
{
	return (fabs( v.x ) < maxValue && fabs( v.y ) < maxValue && fabs( v.z ) < maxValue)
}


#if CLIENT || UI
int function GetReportStyle()
{
	#if PLAYSTATION_PROG                                        
		if ( CrossplayUserOptIn() )
			return GetCurrentPlaylistVarInt( "enable_report", 2 )
		return 0
	#else
		return GetCurrentPlaylistVarInt( "enable_report", 2 )
	#endif
}
#endif

vector function GetClosestPointOnPlane( vector a, vector b, vector c, vector p, bool clampInside = false )
{
	vector n    = CrossProduct( b - a, c - a )
	float eqTop = DotProduct( p - a, n )
	float eqBot = DotProduct( n, n )

	                                                    
	if ( fabs( eqBot ) < 0.001 )
		return GetClosestPointOnLineSegment( a, b, p )

	float magnitude = eqTop / eqBot

	vector endPoint = p - (n * magnitude)

	if ( clampInside )
	{
		float testAB = DotProduct( CrossProduct( b - a, n ), p - a )
		float testBC = DotProduct( CrossProduct( c - b, n ), p - b )
		float testCA = DotProduct( CrossProduct( a - c, n ), p - c )

		                                                          
		if ( testAB * testBC < 0 || testBC * testCA < 0 )
		{
			vector lineAB = GetClosestPointOnLineSegment( a, b, p )
			vector lineBC = GetClosestPointOnLineSegment( b, c, p )
			vector lineCA = GetClosestPointOnLineSegment( c, a, p )

			vector closestVector = lineAB
			float closestDist    = DistanceSqr( p, lineAB )
			float dist           = DistanceSqr( p, lineBC )
			if ( dist < closestDist )
			{
				closestDist = dist
				closestVector = lineBC
			}
			dist = DistanceSqr( p, lineCA )
			if ( dist < closestDist )
			{
				closestDist = dist
				closestVector = lineCA
			}
			return closestVector
		}
		                                            
	}

	return endPoint
}


float function DistanceAlongVector( vector origin, vector lineStart, vector lineForward )
{
	vector originDif = origin - lineStart
	return DotProduct( originDif, lineForward )
}

                     
vector function GetClosestPointOnLineSegment( vector a, vector b, vector p )
{
	float distanceSqr = LengthSqr( a - b )

	if ( distanceSqr == 0.0 )
		return a

	float t = DotProduct( p - a, b - a ) / distanceSqr
	if ( t < 0.0 )
		return a
	else if ( t > 1.0 )
		return b

	return a + t * (b - a)
}


vector function GetClosestPointOnLine( vector a, vector b, vector p )
{
	float distanceSqr = LengthSqr( a - b )

	if ( distanceSqr == 0.0 )
		return a

	float t = DotProduct( p - a, b - a ) / distanceSqr

	return a + t * (b - a)
}


vector ornull function GetIntersectionOfLineAndPlane( vector a, vector b, vector planePoint, vector planeNormal )
{
	float sT = DotProduct( planeNormal, planePoint - a )
	float sB = DotProduct( planeNormal, b - a )

	if ( sB > -0.0000001 && sB < 0.0000001 )
		return null

	float s = sT / sB
	return a + (b - a) * s
}


float function GetDistanceFromLineSegment( vector a, vector b, vector p )
{
	vector closestPoint = GetClosestPointOnLineSegment( a, b, p )
	return Distance( p, closestPoint )
}


float function GetDistanceSqrFromLineSegment( vector a, vector b, vector p )
{
	vector closestPoint = GetClosestPointOnLineSegment( a, b, p )
	return DistanceSqr( p, closestPoint )
}


float function GetProgressAlongLineSegment( vector P, vector A, vector B )
{
	vector AP = P - A
	vector AB = B - A

	float ab2   = DotProduct( AB, AB )                         
	float ap_ab = DotProduct( AP, AB )                         
	float t     = ap_ab / ab2
	return t
}


string function PadString( string str, int len )
{
	for ( int i = str.len(); i < len; i++ )
		str += " "

	return str
}


bool function IsSpawner( entity ent )
{
	return (IsValid( ent ) && ent.GetNetworkedClassName() == "spawner")
}


string function GetAISettingsStringForMode()
{
	return "aiSettingsFile"
}


       
                                                                                                                                        
float function EaseIn( float val )
{
	return AttackDecay( 0, 2, val )
}


float function EaseOut( float val )
{
	return AttackDecay( 2, 0, val )
}


float function AttackDecay( float attack, float decay, float time )
{
	float sum = attack + decay
	float a   = sum - 2.0
	float b   = (3.0 - attack) - sum
	float c   = attack
	float t   = max( min( time, 1.0 ), 0.0 )

	return t * (c + t * (b + t * a))
}


float function Clamp( float value, float minValue, float maxValue )
{
	return max( min( value, maxValue ), minValue )
}


int function ClampInt( int value, int minValue, int maxValue )
{
	return maxint( minint( value, maxValue ), minValue )
}
       


void function RemoveDupesFromSorted_String( array<string> data )
{
	for ( int i = 0; i < data.len() - 1; i++ )
	{
		if ( data[i] == data[i + 1] )
		{
			data.remove( i )
			i--
		}
	}
}


function SortAlphabetize( a, b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


int function SortStringAlphabetize( string a, string b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


int function SortAssetAlphabetize( asset a, asset b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


void function RemoveDupesFromSorted_Asset( array<asset> data )
{
	for ( int i = 0; i < data.len() - 1; i++ )
	{
		if ( data[i] == data[i + 1] )
		{
			data.remove( i )
			i--
		}
	}
}

#if CLIENT || UI
void function DisablePrecacheErrors()
{
	file.lastHostThreadMode = GetConVarInt( "host_thread_mode" )
	file.lastScriptPrecacheErrors = GetConVarInt( "script_precache_errors" )
	file.lastReportFatal = GetConVarInt( "fs_report_sync_opens_fatal" )

	#if CLIENT
		entity player = GetLocalClientPlayer()
		player.ClientCommand( "host_thread_mode 0" )
		player.ClientCommand( "script_precache_errors 0" )
		player.ClientCommand( "fs_report_sync_opens_fatal 0" )
	#endif

	#if UI
		ClientCommand( "host_thread_mode 0" )
		ClientCommand( "script_precache_errors 0" )
		ClientCommand( "fs_report_sync_opens_fatal 0" )
	#endif
}

void function RestorePrecacheErrors()
{
	#if CLIENT
		entity player = GetLocalClientPlayer()
		player.ClientCommand( "host_thread_mode " + file.lastHostThreadMode )
		player.ClientCommand( "script_precache_errors " + file.lastScriptPrecacheErrors )
		player.ClientCommand( "fs_report_sync_opens_fatal " + file.lastReportFatal )
	#endif

	#if UI
		ClientCommand( "host_thread_mode " + file.lastHostThreadMode )
		ClientCommand( "script_precache_errors " + file.lastScriptPrecacheErrors )
		ClientCommand( "fs_report_sync_opens_fatal " + file.lastReportFatal )
	#endif
}
#endif

#if SERVER
                                     
 
	                                      
	 
		                                                         
	 
 

                                     
 
	                                      
	 
		                                                         
	 
 
#endif          

string function GetTitanReadyHintFromSetFile( asset setFile )
{
	return GetGlobalSettingsString( setFile, "readyhint" )
}


bool function CoinFlip()
{
	return RandomInt( 2 ) != 0
}

#if CLIENT || UI
ToolTipData function CreateSimpleToolTip( string titleText, string descText, string actionHint1 = "", string actionHint2 = "", string actionHint3 = "" )
{
	ToolTipData toolTipData
	toolTipData.titleText = titleText
	toolTipData.descText = descText
	toolTipData.actionHint1 = actionHint1
	toolTipData.actionHint2 = actionHint2
	toolTipData.actionHint3 = actionHint3

	return toolTipData
}
#endif


#if CLIENT || UI
bool function PointInBounds( vector point, UIPos pos, UISize size )
{
	if ( point.x < pos.x )
		return false
	if ( point.y < pos.y )
		return false
	if ( point.x > pos.x + size.width )
		return false
	if ( point.y > pos.y + size.height )
		return false

	return true
}
#endif


#if UI || CLIENT
                                                                           
UIPos function REPLACEHud_GetPos( var panel )
{
	var untypedPos = Hud_GetPos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}

                                                                              
UIPos function REPLACEHud_GetAbsPos( var panel )
{
	var untypedPos = Hud_GetAbsPos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}

                                                                               
UIPos function REPLACEHud_GetBasePos( var panel )
{
	var untypedPos = Hud_GetBasePos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}

                                                                             
UISize function REPLACEHud_GetSize( var panel )
{
	var untypedSize = Hud_GetSize( panel )

	UISize size
	size.width = expect int( untypedSize[0] )
	size.height = expect int( untypedSize[1] )

	return size
}

UIPos function REPLACEHud_GetParentRelativePos( var panel )
{
	var untypedPos = Hud_GetParentRelativePos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}

UISize function GetScreenSize()
{
	#if UI
		return REPLACEHud_GetSize( GetMenu( "MainMenu" ) )
	#elseif CLIENT
		array screenSize = expect array( Hud.GetScreenSize() )

		UISize size
		size.width = expect int( screenSize[0] )
		size.height = expect int( screenSize[1] )

		return size
	#endif
}

UIScaleFactor function GetContentScaleFactor( var panel )
{
	UISize size
	float heightBasis = 1080.0

	#if UI
		size = REPLACEHud_GetSize( panel )
	#elseif CLIENT
		array screenSize = expect array( panel.GetScreenSize() )
		size.width = expect int( screenSize[0] )
		size.height = expect int( screenSize[1] )
	#endif

	float aspectRatio = size.width / float( size.height )

	UIScaleFactor scaleFactor
	scaleFactor.x = size.width / (heightBasis * aspectRatio)
	scaleFactor.y = size.height / heightBasis

	return scaleFactor
}

UIScaleFactor function GetContentFixedScaleFactor( var panel )
{
	UISize size
	float vwidth  = 1920
	float vheight = 1080

	#if UI
		size = REPLACEHud_GetSize( panel )
	#elseif CLIENT
		array screenSize = expect array( panel.GetScreenSize() )
		size.width = expect int( screenSize[0] )
		size.height = expect int ( screenSize[1] )
	#endif

	float rx = size.width / vwidth
	float ry = size.height / vheight

	UIScaleFactor scaleFactor
	if ( rx < ry )
	{
		scaleFactor.x = rx
		scaleFactor.y = rx
	}
	else
	{
		scaleFactor.x = ry
		scaleFactor.y = ry
	}

	return scaleFactor
}

bool function ButtonIsBoundToAction( int buttonID, string actionSubString )
{
	string binding = GetEffectiveButtonBinding( buttonID )
	if ( binding.tolower().find_olduntyped( actionSubString.tolower() ) != null )
		return true

	return false
}

bool function ButtonIsBoundToHoldAction( int buttonID, string actionSubString )
{
	string binding = GetEffectiveButtonHoldBinding( buttonID )
	if ( binding.tolower().find_olduntyped( actionSubString.tolower() ) != null )
		return true

	return false
}

bool function ButtonIsBoundToPing( int buttonID )
{
	return ButtonIsBoundToAction( buttonID, "+ping" )
}

#endif                

                                    
   
  	                                     
   

                                                                     
   
  	                                                                            
  	                                                                                                                                      
  	                                                  
  	                             
  	 
  		                                                                                                          
  		                                                      
  
  		                           
  			        
  	 
  	          
   

string function BackslashToSlash( string originalString )
{
	array<string> tokens = split( originalString, "\\" )
	if ( tokens.len() == 0 )
		return ""

	string resultString = tokens[0]
	for ( int index = 1; index < tokens.len(); index++ )
	{
		resultString += "/"
		resultString += tokens[index]
	}

	return resultString
}


array<string> function GetTrimmedSplitString( string originalString, string splitChars )
{
	array<string> stringList = split( originalString, splitChars )
	for ( int i = 0 ; i < stringList.len() ; i++ )
		stringList[i] = strip( stringList[i] )
	return stringList
}


array<string> function GetTrimmedSplitLoweredString( string originalString, string splitChars )
{
	array<string> stringList = split( originalString, splitChars )
	for ( int i = 0 ; i < stringList.len() ; i++ )
		stringList[i] = strip( stringList[i] ).tolower()
	return stringList
}


int function SortByEntIndex( entity a, entity b )
{
	                       
	if ( a.GetEntIndex() > b.GetEntIndex() )
		return 1
	else if ( a.GetEntIndex() < b.GetEntIndex() )
		return -1

	return 0
}


int function SortByTeamMemberIndex( entity a, entity b )
{
	if ( a.GetTeamMemberIndex() > b.GetTeamMemberIndex() )
		return 1
	else if ( a.GetTeamMemberIndex() < b.GetTeamMemberIndex() )
		return -1

	return 0
}


#if !UI
bool function AllegianceCheck( int req, entity entA, entity entB )
{
	if ( req == eAllegiance.IRRELEVANT )
		return true
	if ( req == eAllegiance.FRIENDLY_ONLY )
		return IsFriendlyTeam( entA.GetTeam(), entB.GetTeam() )
	if ( req == eAllegiance.ENEMY_ONLY )
		return IsEnemyTeam( entA.GetTeam(), entB.GetTeam() )

	Assert( 0, ("Unhandled allegience req #:" + req) )
	return false
}
#endif       

vector function GetRandomCenterBiasedToEdge( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360 )
{
	float deviation = RandomFloatRange( 0.0, 1.0 )
	deviation = minDeviation + (sqrt( deviation ) * (maxDeviation - minDeviation))
	vector angles    = <0, RandomFloatRange( minAngle, maxAngle ) % 360, 0>
	vector newCenter = center + (AnglesToForward( angles ) * deviation)
	return newCenter
}


vector function GetRandomCenter( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360, var randomSeed = null )
{
	float deviation
	vector angles
	if ( IsValid ( randomSeed ) )
	{
		deviation = RandomFloatRangeSeeded( randomSeed, minDeviation, maxDeviation )
		angles = <0, RandomFloatRangeSeeded( randomSeed, minAngle, maxAngle ) % 360, 0>
	}
	else
	{
		deviation = RandomFloatRange( minDeviation, maxDeviation )
		angles = <0, RandomFloatRange( minAngle, maxAngle ) % 360, 0>
	}
	vector newCenter = center + (AnglesToForward( angles ) * deviation)
	return newCenter
}


vector function GetRandomCenterDistributed( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360 )
{
	float deviation   = RandomFloatRange( minDeviation, maxDeviation )
	float angles      = RandomFloatRange( minAngle, maxAngle ) % 360
	float scale_ratio = 0
	if ( maxDeviation > 0 )	              
		scale_ratio = maxDeviation / sqrt( maxDeviation )
	float r           = sqrt( deviation ) * scale_ratio
	return center + (< deg_cos( angles ) * r, deg_sin( angles ) * r, 0 >)
}

table<string, table<int, string> > reverseEnumLookupMap = {}
bool function BuildEnumReverseLookup( string enumName, bool assertOnDuplicates = true )
{
	table enumTableCopy = expect table(getconsttable()[enumName])

	table<int, string> reverseLookup = {}
	foreach ( string key, int value in enumTableCopy )
	{
		if ( value in reverseLookup )
		{
			Assert( !assertOnDuplicates, "Enum '" + enumName + "' has two keys with value '" + string(value) + "'" )
			return false
		}
		reverseLookup[value] <- key
	}
	reverseEnumLookupMap[enumName] <- reverseLookup
	return true
}


bool function IsValidEnumValue( string enumName, int value )
{
	if ( !(enumName in reverseEnumLookupMap) )
		BuildEnumReverseLookup( enumName )

	return (value in reverseEnumLookupMap[enumName])
}


string function GetEnumString( string enumName, int value )
{
	                                                                    

	if ( !(enumName in reverseEnumLookupMap) )
		BuildEnumReverseLookup( enumName )

	return reverseEnumLookupMap[enumName][value]
}


string function DEV_GetEnumStringSafe( string enumName, int value )
{
	if ( IsValidEnumValue( enumName, value ) )
		return GetEnumString( enumName, value )

	return "<UNKNOWN ENUM VALUE FOR '" + enumName + "': " + value + ">"
}


string function GetEnumStringSlow( table enumTbl, int value )
{
	foreach ( entryKey, entryValue in enumTbl )
	{
		if ( entryValue == value )
			return expect string(entryKey)
	}

	return "<UNKNOWN ENUM VALUE: " + value + ">"
}


string function DEV_EscapeString( string str, bool wrapInQuotes = true )
{
	string out = RegexpReplace( str, "[\\t\\n\\r\\\"\\\\]", "$0" )
	if ( wrapInQuotes )
		out = "\"" + out + "\""
	return out
}


string function DEV_ArrayConcat( array<string> arr, string sep = ",", bool shouldQuote = true )
{
	string out   = ""
	bool isFirst = true
	foreach ( string part in arr )
	{
		if ( isFirst )
			isFirst = false
		else
			out += sep

		if ( shouldQuote )
			part = DEV_EscapeString( part )

		out += part
	}
	return out
}


int function SortByInventoryIndexAndCount( ConsumableInventoryItem a, ConsumableInventoryItem b )
{
	if ( a.type < b.type )
		return -1
	if ( a.type > b.type )
		return 1

	if ( a.count > b.count )
		return -1
	if ( a.count < b.count )
		return 1

	return 0
}

                                                                                     
array<string> function RegexpFindAllSimple( string baseString, string patternString )
{
	array<string> matches = []
	var pattern           = regexp( patternString )

	int searchIndex = 0
	while ( searchIndex < baseString.len() )
	{
		var captureListOrNull = pattern.capture( baseString, searchIndex )

		if ( captureListOrNull == null )
			break

		array captureList = expect array( captureListOrNull )
		table matchInfo   = expect table( captureList[0] )

		Assert( captureList.len() == 2, "Your RegExp is too advanced. Use RegexpFindAll instead." )

		table captureInfo = expect table( captureList[1] )
		matches.append( baseString.slice( captureInfo.begin, captureInfo.end ) )

		searchIndex = expect int( matchInfo.end )
	}

	return matches
}


vector function RandomVec( float range )
{
	                                                   
	vector vec = <0, 0, 0>
	vec.x = RandomFloatRange( -range, range )
	vec.y = RandomFloatRange( -range, range )
	vec.z = RandomFloatRange( -range, range )

	return vec
}


float function real_float_modulo( float x, float n )
{
	return ((x % n) + n) % n
}


int function real_int_modulo( int x, int n )
{
	return ((x % n) + n) % n
}

#if SERVER || CLIENT
vector function OriginToGround( vector origin, int traceMask = TRACE_MASK_NPCWORLDSTATIC, entity tracingEnt = null )
{
	vector endOrigin         = <origin.x, origin.y, -MAX_WORLD_COORD_BUFFER >
	array <entity> ignoreArray = []
	if ( IsValid( tracingEnt ) )
		ignoreArray.append( tracingEnt )

	TraceResults traceResult = TraceLine( origin, endOrigin, ignoreArray, traceMask, TRACE_COLLISION_GROUP_NONE, tracingEnt )

	return traceResult.endPos
}
#endif

      
           

void function Shuffle_Init( ShuffleData sd, int count )
{
	Assert( count > 0 )
	sd._indices.resize( count )
	for ( int idx = 0; idx < count; ++idx )
		sd._indices[idx] = idx

	sd._pos = count
}


int function Shuffle_GetNextIndex( ShuffleData sd )
{
	Assert( sd._indices.len() > 0 )

	array<int> idxs = sd._indices
	int count       = idxs.len()
	if ( count == 1 )
		return idxs[0]

	++(sd._pos)
	if ( sd._pos >= count )
	{
		int lastIndexPlayed = ((sd._pos == count) ? idxs.top() : -1)
		idxs.randomize()
		if ( idxs[0] == lastIndexPlayed )
			idxs.reverse()                 

		sd._pos = 0
	}

	return idxs[sd._pos]
}


int function Shuffle_GetCount( ShuffleData sd )
{
	return sd._indices.len()
}


      

#if SERVER || CLIENT
vector function LocalPosToWorldPos( vector pos, entity ent )
{
	return ent.GetOrigin() + RotateVector( pos, ent.GetAngles() )
}
vector function LocalPosToWorldPos_NoEnt( vector pos, vector parentPos, vector parentAng )
{
	return parentPos + RotateVector( pos, parentAng )
}
vector function WorldPosToLocalPos( vector pos, entity ent )
{
	return RotateVector( pos - ent.GetOrigin(), AnglesInverse( ent.GetAngles() ) )
}
vector function WorldPosToLocalPos_NoEnt( vector pos, vector parentPos, vector parentAng )
{
	return RotateVector( pos - parentPos, AnglesInverse( parentAng ) )
}
vector function LocalDirToWorldDir( vector dir, entity ent )
{
	return RotateVector( dir, ent.GetAngles() )
}
vector function LocalDirToWorldDir_NoEnt( vector dir, vector parentAng )
{
	return RotateVector( dir, parentAng )
}
vector function WorldDirToLocalDir( vector dir, entity ent )
{
	return RotateVector( dir, AnglesInverse( ent.GetAngles() ) )
}
vector function WorldDirToLocalDir_NoEnt( vector dir, vector parentAng )
{
	return RotateVector( dir, AnglesInverse( parentAng ) )
}
vector function LocalAngToWorldAng( vector ang, entity ent )
{
	return AnglesCompose( ent.GetAngles(), ang )
}
vector function LocalAngToWorldAng_NoEnt( vector ang, vector parentAng )
{
	return AnglesCompose( parentAng, ang )
}
vector function WorldAngToLocalAng( vector ang, entity ent )
{
	return AnglesCompose( AnglesInverse( ent.GetAngles() ), ang )
}
vector function WorldAngToLocalAng_NoEnt( vector ang, vector parentAng )
{
	return AnglesCompose( AnglesInverse( parentAng ), ang )
}
#endif

void function WaitForever()
{
	#if SERVER
		                                         
	#elseif CLIENT
		clGlobal.levelEnt.WaitSignal( "forever" )
	#elseif UI
		WaitSignal( uiGlobal.signalDummy, "forever" )
	#endif
}


bool function IsSurvivalTraining()
{
	return GetCurrentPlaylistVarBool( "survival_training", false )
}

bool function IsFiringRangeGameMode()
{
	return GetCurrentPlaylistVarBool( "survival_firingrange", false )
}

bool function FiringRangeHasFriendlyFire()
{
	return GetCurrentPlaylistVarBool( "firingrange_has_friendlyfire", true )
}

                         
                                           
 
                                                                
 

                                            
 
                                                                   
 
      

bool function FreelanceSystemsAreEnabled()
{
	const bool ENABLED_BY_DEFAULT = false
	return GetCurrentPlaylistVarBool( "freelance_systems_enabled", ENABLED_BY_DEFAULT )
}
                      
bool function SpectreShacksAreEnabled()
{
	return GetCurrentPlaylistVarBool( "spectre_shacks_enabled", true )
}
      

                       
                                    
 
                                                                 
 
      

float function LerpFloat( float startValue, float endValue, float time )
{
	return ((1 - time) * startValue + time * endValue)
}


string function RandomHex( int length = 16 )
{
	string out = ""
	for ( int idx = 0; idx < length; idx++ )
	{
		int c = RandomInt( 16 )
		out += format( "%c", (c < 10 ? '0' : ('A' - 10)) + c )
	}
	return out
}


int function StringHash( string str )
{
	int res    = 0
	int length = str.len()
	for ( int i = 0; i < length; i++ )
	{
		res *= 31
		res += expect int( str[i] )
	}
	return res
}



#if CLIENT || UI
int function SortByScriptId( var a, var b )
{
	int aId = int( Hud_GetScriptID( a ) )
	int bId = int( Hud_GetScriptID( b ) )
	if ( aId > bId )
		return 1
	else if ( bId > aId )
		return -1

	return 0
}
#endif

bool function IsNormalized( vector vec )
                                            
{
	return fabs( 1.0 - LengthSqr( vec ) ) < 0.01
}


#if CLIENT
void function UpdateAccessibilityChatHintEnabledCache()
{
	file.hud_setting_accessibleChatCache = GetConVarInt( "hud_setting_accessibleChat" )
}
#endif

#if CLIENT || UI
bool function IsAccessibilityChatHintEnabled()
{
	#if CLIENT
		return file.hud_setting_accessibleChatCache == 1 || file.hud_setting_accessibleChatCache == 3
	#endif
	#if UI
		return GetConVarInt( "hud_setting_accessibleChat" ) == 1 || GetConVarInt( "hud_setting_accessibleChat" ) == 3
	#endif
}
#endif


#if CLIENT || UI
bool function IsAccessibilityChatToSpeech()
{
	if ( !IsAccessibilityAvailable() )
		return false

	return GetConVarInt( "speechtotext_enabled" ) > 0
}
#endif

#if CLIENT || UI
bool function IsAccessibilityAvailable()
{
	#if UI
		if ( GetLanguage() != "english" )
			return false
	#endif

	return true
}
#endif


#if CLIENT || UI
int function GetStreamerMode()
{
	return GetConVarInt( "hud_setting_streamerMode" )
}
#endif


#if CLIENT || UI
bool function DisplayKillerName()
{
	return GetStreamerMode() < eStreamMode.KILLER
}
#endif


#if CLIENT || UI
bool function DisplayObituaryName()
{
	return GetStreamerMode() < eStreamMode.ALL
}
#endif

#if CLIENT || UI
bool function DisplayHopupPopup()
{
	bool forceHidePopup = GetCurrentPlaylistVarBool( "hud_hide_hopuppopup", false )
	return !forceHidePopup && GetConVarBool( "hud_setting_showHopUpPopUp" )
}
#endif

#if CLIENT || UI
bool function IsNetGraphEnabled()
{
	return GetConVarInt( "net_netGraph2" ) > 0
}
#endif

#if CLIENT || UI
bool function IsAnonymousModeEnabled()
{
	return GetConVarInt( "hud_setting_anonymousMode" ) > 0
}
#endif

#if CLIENT || UI
vector function GetKeyColor( int colorID, int optionalParam = 0 )
{
	Assert( optionalParam >= 0, "optionalParam must not be negative" )
	return ColorPalette_GetColorFromID( colorID + optionalParam )
}
#endif


#if UI
bool function IsAccessibilityNarrationEnabled()
{
	if ( !IsAccessibilityAvailable() )
		return false

	return GetConVarInt( "hud_setting_accessibleChat" ) == 2 || GetConVarInt( "hud_setting_accessibleChat" ) == 3
}
#endif


void function Debounce( DebounceData data, float interval, void functionref() func )
{
	data.latestFunc = func

	if ( data.isQueued )
		return

	thread __DebounceInternalThread( data, interval )
}


void function __DebounceInternalThread( DebounceData data, float interval )
{
	OnThreadEnd( void function() : ( data ) {
		data.isQueued = false
		data.latestFunc = null
	} )

	data.isQueued = true

#if UI
	wait max( 0.01, interval - (UITime() - data.lastRunTime) )
	data.lastRunTime = UITime()
#else
	wait max( 0.01, interval - (Time() - data.lastRunTime) )
	data.lastRunTime = Time()
#endif      
	data.latestFunc()
}


ThrottleData function InitThrottle( float interval = THROTTLE_DEFAULT_INTERVAL, int maxPerInterval = THROTTLE_DEFAULT_MAXPERINTERVAL )
{
	ThrottleData data
	data.interval = interval
	data.maxPerInterval = maxPerInterval

	return data
}


bool function Throttle( ThrottleData data )
{
#if UI
	float timeSinceLastAction = UITime() - data.lastProcessTime
	data.lastProcessTime = UITime()
#else
	float timeSinceLastAction = Time() - data.lastProcessTime
	data.lastProcessTime = Time()
#endif      

	data.decayingActionCount = max( 0.0, data.decayingActionCount - timeSinceLastAction / (data.interval / data.maxPerInterval) )
	if ( data.decayingActionCount > data.interval )
		return true

	data.decayingActionCount += 1.0
	return false
}



const float GAMMA = 2.4
vector function LinearToSrgb( vector inputColor )
{
	inputColor.x = (inputColor.x < 0.0031308) ? (inputColor.x > 0.0 ? inputColor.x * 12.92 : inputColor.x) : 1.055 * pow( inputColor.x, 1.0 / GAMMA ) - 0.055
	inputColor.y = (inputColor.y < 0.0031308) ? (inputColor.y > 0.0 ? inputColor.y * 12.92 : inputColor.y) : 1.055 * pow( inputColor.y, 1.0 / GAMMA ) - 0.055
	inputColor.z = (inputColor.z < 0.0031308) ? (inputColor.z > 0.0 ? inputColor.z * 12.92 : inputColor.z) : 1.055 * pow( inputColor.z, 1.0 / GAMMA ) - 0.055

	return inputColor
}


  	                                                                                                                                                                                                                                           
  	                                                                                                                                                                                                                                                     
  	                                                                                                                                                                                                                         
  	                                                                                                                                                                                                                           
  	                                                                                                                                                                                                                                                      
  	                                                                                                                                                                                                                                    

#if SERVER || CLIENT || UI
var unixTimestampStringPattern = null
var datetimeStringPattern = null
int ornull function DateTimeStringToUnixTimestamp( string str )
{
	                             

	str = strip( str )
	array<string> captures

	                 
	                                           
	unixTimestampStringPattern = MakeRegexp( "^\\d+$" )
	captures = Regexp_Match( unixTimestampStringPattern, str )
	Assert( captures.len() == 0 || captures.len() == 1 )
	if ( captures.len() == 1 )
		return int(captures[0])

	                                       
	                                      
	datetimeStringPattern = MakeRegexp( "^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d) (\\d\\d):(\\d\\d):(\\d\\d) ([\\+\\-])(\\d\\d):(\\d\\d)$" )
	captures = Regexp_Match( datetimeStringPattern, str )
	Assert( captures.len() == 0 || captures.len() == 10 )
	if ( captures.len() == 0 )
		return null
	TimeParts parts
	parts.year = int(captures[1])
	parts.month = int(captures[2])
	parts.day = int(captures[3])
	parts.hour = int(captures[4])
	parts.minute = int(captures[5])
	parts.second = int(captures[6])
	int timezoneOffsetHours = (captures[7] == "+" ? 1 : -1) * int(captures[8])
	Assert( int(captures[9]) == 0 )                                    
	return GetUnixTimeFromParts( parts, timezoneOffsetHours )
}
#endif

int function GetUnixTimePST()
{
	int unixTime = GetUnixTimestamp()
	unixTime += (PST_TIME_ZONE_OFFSET * SECONDS_PER_HOUR)
	return unixTime
}


int function GetUnixTimePDT()
{
	int unixTime = GetUnixTimestamp()
	unixTime += (PDT_TIME_ZONE_OFFSET * SECONDS_PER_HOUR)
	return unixTime
}


TimeParts function GetUnixTimeParts( int unixtime, int timezoneOffsetHours = -7 )
{
	unixtime += SECONDS_PER_HOUR * timezoneOffsetHours

	                                                                                                                  
	TimeParts parts

	                                

	parts.second = unixtime % 60
	unixtime /= 60

	parts.minute = unixtime % 60
	unixtime /= 60

	parts.hour = unixtime % 24
	unixtime /= 24

	                                                                           

	unixtime += 719499

	                                                                                              
	                                                                      

	for ( parts.year = 1969 ; unixtime > __YearToDays( parts.year + 1 ) + 30; parts.year++ )
	{
	}

	                                                                            
	unixtime -= __YearToDays( parts.year )

	                                                                                                                      

	                                                                         
	for ( parts.month = 1 ; parts.month < 12 && unixtime > 367 * (parts.month + 1) / 12; parts.month++ )
	{
	}

	                                                     
	unixtime -= 367 * parts.month / 12

	                                                       

	                                                                                             
	parts.month += 2
	if ( parts.month > 12 )
	{
		parts.month -= 12
		parts.year++
	}

	parts.day = unixtime

	return parts
}


int function GetUnixTimeFromParts( TimeParts parts, int timezoneOffsetHours )
{
	int y                     = parts.year - (parts.month <= 2 ? 1 : 0)
	int era                   = (y >= 0 ? y : y - 399) / 400
	int yoe                   = y - era * 400            
	int doy                   = (153 * (parts.month + (parts.month > 2 ? -3 : 9)) + 2) / 5 + parts.day - 1            
	int doe                   = yoe * 365 + yoe / 4 - yoe / 100 + doy               
	int days_since_1970_01_01 = era * 146097 + doe - 719468

	return (SECONDS_PER_DAY * days_since_1970_01_01
	+ SECONDS_PER_HOUR * (parts.hour - timezoneOffsetHours)
	+ SECONDS_PER_MINUTE * parts.minute
	+ parts.second)
}


int function __YearToDays( int y )
{
	return (y) * 365 + (y) / 4 - (y) / 100 + (y) / 400
}


DisplayTime function SecondsToDHMS( int seconds )
{
	DisplayTime dt

	               
	dt.days = int( floor( seconds / SECONDS_PER_DAY ) )

	                
	int hourSeconds = seconds % SECONDS_PER_DAY
	dt.hours = int( floor( hourSeconds / SECONDS_PER_HOUR ) )

	                  
	int minuteSeconds = hourSeconds % SECONDS_PER_HOUR
	dt.minutes = int( floor( minuteSeconds / SECONDS_PER_MINUTE ) )

	                                
	int remainingSeconds = minuteSeconds % SECONDS_PER_MINUTE
	dt.seconds = int( ceil( remainingSeconds ) )

	return dt
}


string function GetDaysHoursMinutesSecondsString( int seconds )
{
	                                                       
	DisplayTime dt = SecondsToDHMS( seconds )
	return format( "%i:%02i:%02i.%02i", dt.days, dt.hours, dt.minutes, dt.seconds )
}


int function GetDayOfWeek( int unixTime )
{
	return int( (floor( unixTime / SECONDS_PER_DAY ) + 4) % 7 )
}


string function GetDayOfWeekName( int dayOfWeek )
{
	array<string> days = ["#SUNDAY", "#MONDAY", "#TUESDAY", "#WEDNESDAY", "#THURSDAY", "#FRIDAY", "#SATURDAY"]
	Assert( dayOfWeek >= 0 && dayOfWeek < days.len() )
	return days[dayOfWeek]
}


string function GetDateTimeString( int unixTime, int timezoneOffsetHours = -7 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%04i-%02i-%02i %02i:%02i:%02i", timeParts.year, timeParts.month, timeParts.day, timeParts.hour, timeParts.minute, timeParts.second )
}


string function GetDateTimeStringNoYearNoSeconds( int unixTime, int timezoneOffsetHours = 0 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%02i/%02i %02i:%02i", timeParts.month, timeParts.day, timeParts.hour, timeParts.minute )
}


string function GetTimeString( int unixTime )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime )
	return format( "%02i:%02i:%02i", timeParts.hour, timeParts.minute, timeParts.second )
}


int function GetStartOfDay( int unixTime )
{
	TimeParts timeParts    = GetUnixTimeParts( unixTime )
	int unixTimeStartOfDay = unixTime
	unixTimeStartOfDay = unixTimeStartOfDay - (timeParts.hour * SECONDS_PER_HOUR) - (timeParts.minute * SECONDS_PER_MINUTE) - timeParts.second
	return unixTimeStartOfDay
}


int function GetEndOfDay( int unixTime )
{
	return GetStartOfDay( unixTime + SECONDS_PER_DAY )
}


int function SecondsRemainingInDay( int unixTime )
{
	int endOfDay = GetEndOfDay( unixTime )
	return endOfDay - unixTime
}


void function WaitForUnixTime( int unixTime )
{
	while ( true )
	{
		float delay = float(unixTime - GetUnixTimestamp())
		if ( delay <= 0.0 )
			break

		#if DEV
			wait min( 1.0, delay )
		#else
			wait delay
		#endif
	}
}


#if CLIENT || UI
bool function CanSendFriendRequest( entity player )
{
	if ( !GetCurrentPlaylistVarBool( "enable_squad_friend_invite", true ) )
		return false

	return true
}

bool function CanInviteSquadMate( string uid )
{
	if ( !GetCurrentPlaylistVarBool( "enable_squad_invite", true ) )
		return false

	if ( IsInMyParty( uid ) )
		return false

	if ( GetParty().numFreeSlots == 0 )
		return false

	return true
}

bool function IsInMyParty( string uid )
{
	Party party = GetParty()
	foreach ( p in party.members )
	{
		if ( p.uid == uid )
			return true
	}
	return false
}
#endif

  
  
WaitQuotaItem function WaitFrameQuota_Init( int maxPerFrame )
{
	WaitQuotaItem wq
	wq._count = 0
	wq._budget = maxPerFrame
	return wq
}


void function WaitFrameQuota_Reset( WaitQuotaItem wq )
{
	wq._count = 0
}


void function WaitFrameQuota( WaitQuotaItem wq )
{
	wq._count += 1
	if ( wq._count < wq._budget )
		return
	wq._count = 0
	WaitFrame()
}


entity function AssertLocalOrServerValidPlayer( entity player )
{
	#if SERVER
		                           
	#elseif CLIENT || UI
		if ( player == null )
			player = GetLocalClientPlayer()
		Assert( player == GetLocalClientPlayer() )
	#endif

	return player
}


bool function IsEverythingUnlocked()
{
	#if DEV
		if ( GetCurrentPlaylistVarBool( "dev_force_everything_unlocked", false ) )
			return true
	#endif

	return EverythingUnlockedConVarEnabled()
}

                          
string function StripRuiStringFormatting( string text )
{
	string newText = text
	while ( newText.find( "`" ) != -1 )
	{
		int idx = newText.find( "`" )

		if ( newText.len() < 2 )
			return ""

		string a = ""

		if ( idx > 0 )
		{
			a = newText.slice( 0, idx )
		}

		string b = ""

		if ( idx + 2 < newText.len() )
		{
			b = newText.slice( idx + 2, newText.len() )
		}

		newText = a + b
	}

	return newText
}

#if SERVER
                                               
 
	                                                 
 
#endif


var function GetRandomWeighted( ... )
{
	Assert( vargc % 2 == 0, "Must pass pairs to GetRandomWeighted!" )
	float total = 0.0
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
		total += expect float(vargv[argIdx + 0])

	float choice = RandomFloat( total )
	total = 0.0
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
	{
		total += expect float(vargv[argIdx + 0])
		if ( choice < total )
			return vargv[argIdx + 1]
	}

	Assert( false )
	return null
}


#if SERVER || CLIENT
FXHandle function StartWorldFXWithHandle( asset fxAsset, vector pos, vector ang )
{
	int fxAssetId = GetParticleSystemIndex( fxAsset )
	#if SERVER
		                                                                     
	#elseif CLIENT
		return StartParticleEffectInWorldWithHandle( fxAssetId, pos, ang )
	#endif
}
#endif


#if SERVER || CLIENT
FXHandle function StartEntityFXWithHandle( entity ent, asset fxAsset, int attachType, int attachData )
{
	int fxAssetId = GetParticleSystemIndex( fxAsset )
	#if SERVER
		                                                                                         
	#elseif CLIENT
		return StartParticleEffectOnEntity( ent, fxAssetId, attachType, attachData )
	#endif
}
#endif


#if SERVER || CLIENT
FXHandle function CleanupFXHandle( FXHandle fxHandle, bool doRemoveAllParticlesNow = true, bool doPlayEndCap = false )
{
	#if SERVER
		                          
		 
			               
			                              
			 
				                       
				                               
			 
			                        
				                       
			    
				                   
			                                

			                  
		 

		           
	#elseif CLIENT
		if ( EffectDoesExist( fxHandle ) )
			EffectStop( fxHandle, doRemoveAllParticlesNow, doPlayEndCap )

		return -1
	#endif
}
#endif


#if SERVER || CLIENT
void function CleanupFXArray( array<FXHandle> fxHandleArray, bool doRemoveAllParticlesNow, bool doPlayEndCap )
{
	string stopType
	if ( doRemoveAllParticlesNow )
	{
		Assert( !doPlayEndCap )
		stopType = "destroyImmediately"
	}
	else if ( doPlayEndCap )
		stopType = "playEndcap"
	else
		stopType = "normal"

	foreach ( FXHandle fxHandle in fxHandleArray )
	{
		#if SERVER
			                          
			 
				                                

				                  
			 
		#elseif CLIENT
			if ( EffectDoesExist( fxHandle ) )
				EffectStop( fxHandle, doRemoveAllParticlesNow, doPlayEndCap )
		#endif
	}
	fxHandleArray.clear()
}
#endif


#if SERVER || CLIENT
array<entity> function GetEntArrayByScriptNameSequence( string fmtStr, int firstIdx = 0 )
{
	array<entity> out = []
	int idx           = firstIdx
	while ( true )
	{
		array<entity> ents = GetEntArrayByScriptName( format( fmtStr, idx ) )
		if ( ents.len() == 0 )
			break
		else if ( ents.len() == 1 )
			out.append( ents[0] )
		else
			Warning( "GetEntArrayByScriptNameSequence found more than one ent with script name \"%s\".", format( fmtStr, idx ) )
	}
	return out
}
#endif


void function WaitSignals( var obj, array<string> signals )
{
	Assert( signals.len() > 0 )
	waitthread __WaitSignalsInternal( obj, signals )
}


void function __WaitSignalsInternal( var obj, array<string> signals )
{
	foreach ( string signal in signals )
		EndSignal( obj, signal )
	WaitForever()
}


void function WaitEndSignal( var obj, string signal )
{
	waitthread __WaitEndSignalInternal( obj, signal )
}


void function __WaitEndSignalInternal( var obj, string signal )
{
	EndSignal( obj, signal )
	WaitForever()
}


#if SERVER || CLIENT
int function GetSkinIndexByName_Safe( entity ent, string skinName )
{
	if ( ent.GetSkinCount() == 0 )
	{
		                     
		Warning( "GetSkinIndexByName_Safe called on ent with bad model. Callstack:\n%s", GetStack() )
		return -1
	}
	return ent.GetSkinIndexByName( skinName )
}
#endif


#if SERVER || CLIENT
void function SetSkinByName_Safe( entity ent, string skinName )
{
	if ( ent.GetSkinCount() == 0 )
	{
		                     
		Warning( "SetSkinByName_Safe called on ent with bad model. Callstack:\n%s", GetStack() )
		return
	}
	int skinIdx = ent.GetSkinIndexByName( skinName )
	if ( skinIdx == -1 )
	{
		Warning( "SetSkinByName_Safe called with bad skin name (\"%s\"). Callstack:\n%s", skinName, GetStack() )
		return
	}
	ent.SetSkin( skinIdx )
}
#endif


#if SERVER || CLIENT
bool function CanScriptPlaceableBePlacedOn( entity hitEnt )
{
	                                                           

	if ( hitEnt.IsWorld() )
		return true

	var hitEntClassname = hitEnt.GetNetworkedClassName()

	if ( hitEntClassname == "func_brush" || hitEntClassname == "script_mover" )
		return true

	return false
}
#endif


#if SERVER || CLIENT
bool function ShouldScriptedPlaceableParentTo( entity hitEnt )
{
	var hitEntClassname = hitEnt.GetNetworkedClassName()

	if ( hitEntClassname == "func_brush" || hitEntClassname == "script_mover" )
		return true

	return false
}
#endif


#if SERVER || CLIENT
vector function RoundVectorInLocalSpace( vector vec, float interval, vector parentPos, vector parentAng )
{
	vec = WorldPosToLocalPos_NoEnt( vec, parentPos, parentAng )
	vec = RotateVector( vec, AnglesInverse( parentAng ) )
	vec = <floor( vec.x / interval ) * interval, floor( vec.y / interval ) * interval, floor( vec.z / interval ) * interval >
	vec = RotateVector( vec, parentAng )
	vec = LocalPosToWorldPos_NoEnt( vec, parentPos, parentAng )
	return vec
}
#endif

#if DEV && (SERVER || CLIENT)
void function DEV_LifetimeDebugTool( entity thing )
{
	while ( true )
	{
		bool isValid          = IsValid( thing )
		bool isValidThisFrame = IsValid_ThisFrame( thing )
		printf( "[DEV_LifetimeDebugTool] %s, IsValid() = %s, IsValid_ThisFrame() = %s", string( thing ), string(isValid), string(isValidThisFrame) )

		if ( !isValid && !isValidThisFrame )
			break

		wait 1.0
	}
}
#endif


#if SERVER
                                                                                                
 
	                               

	                     
		                             

	                                          
		                       
			               
	   

	          
 
#endif


#if SERVER
                                                                                                                                                 
 
	                      

	                 
	              
	 
		                                                                   
		                  
			     

		                      
			        
		                     
			        

		                 
	 

	          
 
#endif


#if SERVER || CLIENT || UI
vector function DirFBLRUD_ToDir( DirFBLRUD dir )
{
	switch ( dir )
	{
		case DIR_FBLRUD_FORWARD:
			return <1, 0, 0>

		case DIR_FBLRUD_BACK:
			return <-1, 0, 0>

		case DIR_FBLRUD_LEFT:
			return <0, 1, 0>

		case DIR_FBLRUD_RIGHT:
			return <0, -1, 0>

		case DIR_FBLRUD_UP:
			return <0, 0, 1>

		case DIR_FBLRUD_DOWN:
			return <0, 0, -1>
	}
	Assert( false, "Bad direction: " + dir )
	return <0, 0, 0>
}
#endif


#if SERVER || CLIENT || UI
float function DirFBLRUD_ForwardLength( DirFBLRUD dir, vector vec )
{
	switch ( dir )
	{
		case DIR_FBLRUD_FORWARD:
			return vec.x

		case DIR_FBLRUD_BACK:
			return -1.0 * vec.x

		case DIR_FBLRUD_LEFT:
			return vec.y

		case DIR_FBLRUD_RIGHT:
			return -1.0 * vec.y

		case DIR_FBLRUD_UP:
			return vec.z

		case DIR_FBLRUD_DOWN:
			return -1.0 * vec.z
	}
	Assert( false, "Bad direction: " + dir )
	return 0.0
}
#endif


#if CLIENT || UI
void functionref( bool success ) MenuExtendedUse_callback = null
void function StartMenuExtendedUse( var focusElem, var holdToUseElem, float duration, bool requireControllerFocus, void functionref( bool success ) callback,
string loopSound = "survival_titan_linking_loop", string successSound = "ui_menu_store_purchase_success" )
{
	                                                                                       
	if ( MenuExtendedUse_callback != null )
		return

	MenuExtendedUse_callback = callback
	#if UI
		bool isForClientVM = false
		thread _MenuExtendedUse_InternalThread( focusElem, holdToUseElem, duration, loopSound, successSound, isForClientVM, requireControllerFocus )
	#elseif CLIENT
		RunUIScript( "_ClientToUI_MenuExtendedUseBegin", focusElem, holdToUseElem, duration, loopSound, successSound, requireControllerFocus )
	#endif
}
#endif


#if UI
void function _ClientToUI_MenuExtendedUseBegin( var focusElem, var holdToUseElem, float duration, string loopSound, string successSound, bool requireControllerFocus )
{
	bool isForClientVM = true
	thread _MenuExtendedUse_InternalThread( focusElem, holdToUseElem, duration, loopSound, successSound, isForClientVM, requireControllerFocus )
}
#elseif CLIENT
void function _UIToClient_MenuExtendedUseEnded( bool success )
{
	Assert( MenuExtendedUse_callback != null )
	MenuExtendedUse_callback( success )
	MenuExtendedUse_callback = null
}
#endif


#if UI
bool _MenuExtendedUse_InternalThread_isActive = false
void function _MenuExtendedUse_InternalThread( var focusElem, var holdToUseElem, float duration, string loopSound, string successSound, bool isForClientVM, bool requireControllerFocus )
{
	                                                     
	if ( _MenuExtendedUse_InternalThread_isActive )
		return
	_MenuExtendedUse_InternalThread_isActive = true

	Hud_Show( holdToUseElem )
	HideGameCursor()

	var rui = Hud_GetRui( holdToUseElem )
	RuiSetBool( rui, "isVisible", true )
	RuiSetGameTime( rui, "startTime", ClientTime() )
	RuiSetFloat( rui, "duration", duration )

	float uiEndTime = ClientTime() + duration

	if ( loopSound != "" )
		EmitUISound( loopSound )

	bool[1] success = [false]

	OnThreadEnd( void function() : ( loopSound, rui, holdToUseElem, isForClientVM, success ) {
		ShowGameCursor()
		Hud_Hide( holdToUseElem )
		RuiSetBool( rui, "isVisible", false )
		if ( loopSound != "" )
			StopUISound( loopSound )

		if ( isForClientVM )
		{
			RunClientScript( "_UIToClient_MenuExtendedUseEnded", success[0] )
		}
		else
		{
			Assert( MenuExtendedUse_callback != null )
			MenuExtendedUse_callback( success[0] )
			MenuExtendedUse_callback = null
		}

		_MenuExtendedUse_InternalThread_isActive = false
	} )

	while ( true )
	{
		bool isButtonHeld = false
		if ( InputIsButtonDown( MOUSE_LEFT ) || InputIsButtonDown( BUTTON_A ) )
			isButtonHeld = true

		bool allowRightClick = true
		if ( allowRightClick && (InputIsButtonDown( MOUSE_RIGHT ) || InputIsButtonDown( BUTTON_X )) )
			isButtonHeld = true

		if ( !isButtonHeld )
			break

		if ( ClientTime() >= uiEndTime )
			break

		if ( GetMouseFocus() != focusElem && !GetDpadNavigationActive() )
		{
			if ( IsControllerModeActive() && requireControllerFocus )
				break
			else if ( !IsControllerModeActive() )
				break
			                                                                                                                    
		}

		vector screenPos = ConvertCursorToScreenPos()
		Hud_SetPos( holdToUseElem, screenPos.x - Hud_GetWidth( holdToUseElem ) * 0.5, screenPos.y - Hud_GetHeight( holdToUseElem ) * 0.5 )
		WaitFrame()
	}

	if ( ClientTime() < uiEndTime )
		return

	if ( IsLobby() )
		return

	if ( successSound != "" )
		EmitUISound( successSound )
	success[0] = true
}
#endif


#if SERVER || CLIENT || UI
bool function IsInfiniteAmmoEnabled()
{
	#if DEV
		if ( GetConVarBool( "sv_infinite_ammo" ) )
			return true
	#endif
	return false
}
#endif


#if SERVER || CLIENT
void function DestroyEntities( array<entity> ents )
{
	foreach ( entity ent in ents )
		if ( IsValid( ent ) )
			ent.Destroy()
}
#endif

void function SetConVarFloatFromPlaylist( string varName, float floatVal )
{
	SetConVarFloat( varName, GetCurrentPlaylistVarFloat( varName, floatVal ) )
}


#if CLIENT || UI
bool function IsUserOnSamePlatform( string hardware )
{
	#if UI
		return hardware == GetUnspoofedPlayerHardware()
	#endif
	#if CLIENT
		entity player = GetLocalClientPlayer()
		return IsValid( player ) ? hardware == player.GetUnspoofedHardware() : false
	#endif
}

bool function IsUserOnSamePlatformID( int hardwareID )
{
	#if UI
		int localPlayerHardwareID = GetHardwareFromName( GetUnspoofedPlayerHardware() )
		if( ( hardwareID == HARDWARE_PS4 || hardwareID == HARDWARE_PS5 ) && (localPlayerHardwareID == HARDWARE_PS4 || localPlayerHardwareID == HARDWARE_PS5) )
		{
			return true
		}
		else if( ( hardwareID == HARDWARE_XBOXONE || hardwareID == HARDWARE_XB5 ) && (localPlayerHardwareID == HARDWARE_XBOXONE || localPlayerHardwareID == HARDWARE_XB5) )
		{
			return true
		}
		else
		{
			return hardwareID == GetHardwareFromName( GetUnspoofedPlayerHardware() )
		}
		return false
	#endif
	#if CLIENT
		entity player = GetLocalClientPlayer()
		if( !IsValid( player ) )
		{
			return false
		}
		int localPlayerHardwareID = GetHardwareFromName( player.GetUnspoofedHardware() )
		if( ( hardwareID == HARDWARE_PS4 || hardwareID == HARDWARE_PS5 ) && (localPlayerHardwareID == HARDWARE_PS4 || localPlayerHardwareID == HARDWARE_PS5) )
		{
			return true
		}
		else if( ( hardwareID == HARDWARE_XBOXONE || hardwareID == HARDWARE_XB5 ) && (localPlayerHardwareID == HARDWARE_XBOXONE || localPlayerHardwareID == HARDWARE_XB5) )
		{
			return true
		}
		else
		{
			return IsValid( player ) ? hardwareID == GetHardwareFromName( player.GetUnspoofedHardware() ) : false
		}
		return false
	#endif
}

bool function CrossplayUserOptIn()
{
	return IsUserOptedInToCrossPlay() && CrossplayEnabled()
}


bool function CrossplayEnabled()
{
	return GetConVarInt( "crossPlay_enabled" ) != 0
}

string function PlatformIDToIconString( int platformID )
{
	if ( IsUserOnSamePlatformID( platformID ) )
	{
		switch ( platformID )
		{
			case HARDWARE_PC:
                    
			case HARDWARE_PC_STEAM:
      
				return Localize( "#CROSSPLAY_ICON_PC" )

			case HARDWARE_PS4:
			case HARDWARE_PS5:
				return Localize( "#CROSSPLAY_ICON_PS4" )

			case HARDWARE_XBOXONE:
			case HARDWARE_XB5:
				return Localize( "#CROSSPLAY_ICON_XBOX" )

			case HARDWARE_SWITCH:
				return Localize( "#CROSSPLAY_ICON_NX" )

			default:
				return ""
		}
	}
	else
	{
		switch ( platformID )
		{
			case HARDWARE_PC:
                    
			case HARDWARE_PC_STEAM:
      
				return Localize( "#CROSSPLAY_ICON_PC" )

			case HARDWARE_PS4:
			case HARDWARE_XBOXONE:
			case HARDWARE_SWITCH:
			case HARDWARE_XB5:
			case HARDWARE_PS5:
				return Localize( "#CROSSPLAY_ICON_CONTROLLER" )

			default:
				return ""
		}
	}

	Assert( false, "Unhandled platformID " + platformID )
	unreachable
}
#endif                


bool function AreClubInvitesEnabled()
{
	return GetConVarInt( "clubs_showInvites" ) == eClubInviteDisplayLevel.ENABLED
}


                                                                                 
                                                                                                                                           
bool function IsMadMaggieHost()
{
	return GetCurrentPlaylistVarBool( "is_maggie_host", false )
}
                                

#if SERVER || CLIENT
const float ROG_MIN_VERT_DISTRIB 		= 1024.0 * 4.0                                       
const float ROG_MAX_VERT_DISTRIB 		= 1024.0 * 6.0
const float ROG_MIN_HORIZ_DISTRIBUTION			= 1024 * 12.0
const float ROG_DEFAULT_GRID_HALF_SIZE			= 64000.0
const int ROG_MAX_SPAWN_POOL_BEFORE_REDUCTION	= 100
const float ROG_MAX_SPAWN_TO_POOL_SATURATION	= 0.5

                                                                                                                                                            
                                       
                                                             
array<entity> function RandomOrientedGridDistribution(
			array<entity> possibleLocationEnts,						                                                                    
			int numDesiredSpawns,									                                          
			float defaultGridHalfSize = ROG_DEFAULT_GRID_HALF_SIZE,		                                                                                                                                                                                                            
			float minDesiredVertSpacingParam = ROG_MIN_VERT_DISTRIB,					                                                                                                          
			float maxDesiredVertSpacingParam = ROG_MAX_VERT_DISTRIB,					                                                                                                  
			float minDesiredHorizSpacing = ROG_MIN_HORIZ_DISTRIBUTION,					                                                                                                                                
			int maxNumSpawnsBeforeReduction = ROG_MAX_SPAWN_POOL_BEFORE_REDUCTION,		                                                                                      
			float maxSpawnSaturationBeforeRandomPick = ROG_MAX_SPAWN_TO_POOL_SATURATION 	                                                                                                                                          
		)
{
	                         
	int numSpawnPoints       	= possibleLocationEnts.len()
	int numSpawnsToReturn = numDesiredSpawns

	if ( (numSpawnPoints == 0) || (numSpawnsToReturn == 0) )
	{
		array<entity> empty
		return empty
	}

	float desiredToLocationRatio = float( numSpawnsToReturn / numSpawnPoints )
	if ( desiredToLocationRatio > maxSpawnSaturationBeforeRandomPick )
	{
		if ( numSpawnsToReturn > numSpawnPoints )
			numSpawnsToReturn = numSpawnPoints

		printt( "!!! WARNING !!! Ratio of desired tick spawns to available locations too high to be worth it! Randomizing and returning results!", desiredToLocationRatio )
		possibleLocationEnts.randomize()
		return possibleLocationEnts.slice( 0, numSpawnsToReturn )
	}

	vector verticalAxis   = Normalize( < RandomFloatRange( -1, 1 ), RandomFloatRange( -1, 1 ), 0 > )
	vector horizAxis      = CrossProduct( verticalAxis, < 0, 0, 1 > )
	vector vertAxisOrigin = verticalAxis * -defaultGridHalfSize

	bool verbosePrint = GetCurrentPlaylistVarInt( "debug_loot_ticks", 0 ) == 1

	                       
	                                                                                                                                                          
	                                                                                        
	                       
	array<table> selectedSpawnPositions
	float closestSpawnOriginToVertAxisOrigin  = defaultGridHalfSize
	float furthestSpawnOriginToVertAxisOrigin = 0
	float minWidth                            = defaultGridHalfSize
	float maxWidth                            = -defaultGridHalfSize
	bool shouldDiscardSomeCandidates          = numSpawnPoints > maxNumSpawnsBeforeReduction                            
	int numSelectedSpawnEnts
	foreach( spawnEnt in possibleLocationEnts )
	{
		if ( !IsValid( spawnEnt ) )
			continue

		                                                                                                          
		if ( shouldDiscardSomeCandidates && CoinFlip() )
			continue

		numSelectedSpawnEnts++

		vector vertAxisOriginToEnt      = spawnEnt.GetOrigin() - vertAxisOrigin
		float distToVertAxisOrigin      = DotProduct2D( vertAxisOriginToEnt, verticalAxis )
		float horizDistToVertAxisOrigin = DotProduct2D( vertAxisOriginToEnt, horizAxis )
		selectedSpawnPositions.append( { ent = spawnEnt, vertDist = distToVertAxisOrigin, horizDist = horizDistToVertAxisOrigin } )

		                                                 
		if ( distToVertAxisOrigin > furthestSpawnOriginToVertAxisOrigin )
			furthestSpawnOriginToVertAxisOrigin = distToVertAxisOrigin
		else if ( distToVertAxisOrigin < closestSpawnOriginToVertAxisOrigin )
			closestSpawnOriginToVertAxisOrigin = distToVertAxisOrigin

		                                
		if ( horizDistToVertAxisOrigin > maxWidth )
			maxWidth = horizDistToVertAxisOrigin
		else if( horizDistToVertAxisOrigin < minWidth )
			minWidth = horizDistToVertAxisOrigin
	}

	selectedSpawnPositions.sort( SortSpawnPositionsByVertDist )

	if ( numSelectedSpawnEnts < numSpawnsToReturn )
		numSpawnsToReturn = numSelectedSpawnEnts

	                       
	                                                                                                          
	                                                                                                                                                                                        
	                                                                                                                                 
	  
	                                                                                                     
	                                                                                                       
	                       
	Assert( maxDesiredVertSpacingParam > minDesiredVertSpacingParam, "Max loottick distribution distance is smaller than min distribution! Fix it!" )

	float vertAxisSpawnRange     = furthestSpawnOriginToVertAxisOrigin - closestSpawnOriginToVertAxisOrigin
	float maxDesiredSpawnSpacing = ( vertAxisSpawnRange * 0.9 ) / numSpawnsToReturn		                                                                            
	float minDesiredSpawnSpacing = minDesiredVertSpacingParam
	if ( maxDesiredSpawnSpacing > maxDesiredVertSpacingParam )
		maxDesiredSpawnSpacing = maxDesiredVertSpacingParam

	if ( maxDesiredSpawnSpacing < minDesiredVertSpacingParam )
		minDesiredSpawnSpacing = maxDesiredSpawnSpacing - 1

	float verticalDistanceTraveled = closestSpawnOriginToVertAxisOrigin			                                                                      
	int numVertSplits              = 0
	int lastSafetyCheckedSpawnEnt  = 0
	array<float> generatedVertSplits	                                                                                             
	while( true )
	{
		float newVerticalDistanceTraveled = RandomFloatRange( minDesiredSpawnSpacing, maxDesiredSpawnSpacing )
		verticalDistanceTraveled += newVerticalDistanceTraveled

		if ( verticalDistanceTraveled > furthestSpawnOriginToVertAxisOrigin )
			break

		                                                                                         
		int numSpawnEntsBetweenLastAndCurrentSelection
		for( int i = lastSafetyCheckedSpawnEnt; i < numSelectedSpawnEnts; i++ )
		{
			float curVertDist = expect float( selectedSpawnPositions[ i ].vertDist )
			if ( curVertDist > verticalDistanceTraveled )
				break

			numSpawnEntsBetweenLastAndCurrentSelection = i - lastSafetyCheckedSpawnEnt
		}

		                                                                                                                                                                                                                  
		if ( numSpawnEntsBetweenLastAndCurrentSelection == 0 )
		{
			float vertDistMidpointToNext = FLT_MAX
			float nextSpawnEntVertDist   = expect float( selectedSpawnPositions[ lastSafetyCheckedSpawnEnt + 1 ].vertDist )                                                                                                
			if ( ( lastSafetyCheckedSpawnEnt + 2 ) < numSelectedSpawnEnts )
			{
				float spawnEntAfterNext_vertDist = expect float( selectedSpawnPositions[ lastSafetyCheckedSpawnEnt + 2 ].vertDist )
				vertDistMidpointToNext = ( spawnEntAfterNext_vertDist - nextSpawnEntVertDist ) * 0.5
			}

			float safetyBuffer 			= min( 128, vertDistMidpointToNext )
			lastSafetyCheckedSpawnEnt 	+= 1
			verticalDistanceTraveled 	= nextSpawnEntVertDist + safetyBuffer
		}
		else
			lastSafetyCheckedSpawnEnt += numSpawnEntsBetweenLastAndCurrentSelection

		numVertSplits++
		generatedVertSplits.append( verticalDistanceTraveled )
	}

	if ( verbosePrint )
		printt( "Num generated vert splits:", generatedVertSplits.len(), "num div selections:", numSpawnsToReturn )

	                                                                                                                                                                                                 
	                                                                                                            
	int numVertSplitsToUse = minint( numSpawnsToReturn, numVertSplits )
	generatedVertSplits.randomize()
	                                                                                         
	array<float> vertSplitsToUse = generatedVertSplits.slice( 0, numVertSplitsToUse )
	vertSplitsToUse.sort( SortLowestFloat )

	                       
	                                                                                                                                 
	                                                                                                                                                         
	                                                                                                               
	  
	  		     			  						   			  
	  		   	  			 						 		     
	  		   				 		 		  		 			 
	  	                                                                      		                
	  		   				 						 			 
	  		   		 	 	 						 			 	                                                                           
	  		   				 			 			 		 	 
	  												                                                                                                                         
	  
	  		                           
	  
	                                                                                                                                                          
	                                                                                                                                                                                                         
	                                                                            
	                                                                                                                                                
	                       
	array<entity> spawnSelections
	int idx_vertSplit
	float horizTarget = RandomFloatRange( minWidth, maxWidth )
	int curAxisBestSpawnEntChoice
	float curBestChoiceDistSQ = defaultGridHalfSize * defaultGridHalfSize

	for( int i = 0; i < numSelectedSpawnEnts; i++ )
	{
		entity spawnEnt        = expect entity( selectedSpawnPositions[ i ].ent )
		float spawnEntVertDist = expect float( selectedSpawnPositions[ i ].vertDist )
		float curVerticalSplit = vertSplitsToUse[ idx_vertSplit ]

		if ( ( spawnEntVertDist < curVerticalSplit ) && ( spawnEntVertDist - curVerticalSplit ) < minDesiredSpawnSpacing )
		{
			float spawnEntHorizDist = expect float( selectedSpawnPositions[ i ].horizDist )
			float vertDistDiff      = curVerticalSplit - spawnEntVertDist
			float horizDistDiff     = fabs( horizTarget - spawnEntHorizDist )
			float distSQ            = ( vertDistDiff * vertDistDiff ) + ( horizDistDiff * horizDistDiff )
			if ( distSQ < curBestChoiceDistSQ )
			{
				                                                                                                                        
				bool curBestChoiceIsLastAxisSelection = ( idx_vertSplit > 0 ) && ( spawnEnt == spawnSelections.top() )
				if ( ( idx_vertSplit == 0 ) || !curBestChoiceIsLastAxisSelection )
				{
					curBestChoiceDistSQ       = distSQ
					curAxisBestSpawnEntChoice = i
				}
			}

			int nextSpawnEntIdx      = i + 1
			bool moreSpawnEntsRemain = nextSpawnEntIdx < numSelectedSpawnEnts

			if ( moreSpawnEntsRemain )
			{
				float nextVertDist                = expect float( selectedSpawnPositions[ nextSpawnEntIdx ].vertDist )
				bool moreSpawnEntsInVerticalSplit = nextVertDist <= curVerticalSplit
				if ( !moreSpawnEntsInVerticalSplit )
				{
					spawnSelections.append( expect entity( selectedSpawnPositions[ curAxisBestSpawnEntChoice ].ent ) )

					                                                                                                                                            
					idx_vertSplit++
					bool shouldChooseNewHorizTarget = idx_vertSplit < numVertSplitsToUse
					if ( shouldChooseNewHorizTarget )
					{
						curBestChoiceDistSQ = defaultGridHalfSize * defaultGridHalfSize

						array<float> newHorizTargetChoices
						float selectedSpawnHorizPosition = expect float( selectedSpawnPositions[ curAxisBestSpawnEntChoice ].horizDist )
						float horizTargetLowEndStart     = selectedSpawnHorizPosition - minDesiredHorizSpacing

						if ( horizTargetLowEndStart > minWidth )
							newHorizTargetChoices.append( RandomFloatRange( minWidth, horizTargetLowEndStart ) )

						float horizTargetHighEndStart = selectedSpawnHorizPosition + minDesiredHorizSpacing
						if ( horizTargetHighEndStart < maxWidth )
							newHorizTargetChoices.append( RandomFloatRange( maxWidth, horizTargetHighEndStart ) )

						if ( !newHorizTargetChoices.len() )
						{
							newHorizTargetChoices.append( RandomFloatRange( minWidth, maxWidth ) )
							Warning( "Warning! Had to select random horiz axis location for next loot tick spawn. minDesiredHorizDistributionDist (" + minDesiredHorizSpacing + ") too large, or loot bin area too narrow (" + ( maxWidth - minWidth ) + ")" )
						}

						                                                                                                                
						horizTarget = newHorizTargetChoices.getrandom()

						                                                                                                      
						i--
					}
					                                        
					else
						break
				}
			}
			else if ( !moreSpawnEntsRemain )
				spawnSelections.append( expect entity( selectedSpawnPositions[ curAxisBestSpawnEntChoice ].ent ) )
		}
	}

	return spawnSelections
}

int function SortSpawnPositionsByVertDist( table a, table b )
{
	float vertDistA = expect float( a.vertDist )
	float vertDistB = expect float( b.vertDist )

	if ( vertDistA > vertDistB )
		return 1
	else if ( vertDistB > vertDistA )
		return -1

	return 0
}

bool function IsEqualVector( vector a, vector b )
{
	return DistanceSqr( a, b) <= FLT_EPSILON
}

bool function IsEqualFloat( float left, float right )
{
	return fabs( left - right ) < FLT_EPSILON
}

float function CalculateFloatArrayVarianceWithGivenPercentile( array<float> inArr, float percentile )
{
	array<float> arr = inArr
	arr.sort()

	                                                      
	int maxIndex = int( percentile * arr.len() )

	float average = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		average += arr[i]
	}

	average /= maxIndex

	float sumOfSquares = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		float deviationFromAvg = arr[i] - average
		sumOfSquares += ( deviationFromAvg * deviationFromAvg )
	}

	return sumOfSquares / maxIndex
}

float function CalculateIntArrayVarianceWithGivenPercentile( array<int> inArr, float percentile )
{
	array<int> arr = inArr
	arr.sort()

	                                                      
	int maxIndex = int( 0.9 * arr.len() )

	float average = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		average += float( arr[i] )
	}

	average /= maxIndex

	float sumOfSquares = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		float deviationFromAvg = ( float( arr[i] ) - average )
		sumOfSquares += ( deviationFromAvg * deviationFromAvg )
	}

	return sumOfSquares / maxIndex
}

#endif                    