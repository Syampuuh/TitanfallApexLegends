#if SERVER || CLIENT || UI
global function ShChallenges_LevelInit_PreStats
global function ShChallenges_LevelInit_PostStats
global function GetAllChallenges
global function Challenge_GetTierCount
global function Challenge_LastTierIsInfinite
global function Challenge_GetCurrentTier
global function Challenge_IsComplete
global function Challenge_GetTimeSpanKind
global function Challenge_GetGoalVal
                 
global function Challenge_EitherOr_GetGoalVals
      
global function Challenge_GetBPStarsReward
global function Challenge_GetBattlepassLevelsReward
global function Challenge_GetRewards
global function Challenge_IsPremium
                 
global function Challenge_IsEitherOr
      
global function Challenge_GetProgressValue
                 
global function Challenge_EitherOr_GetProgressValues
      
global function Challenge_GetSource
global function Challenge_GetStatRefs
                 
global function Challenge_EitherOr_GetStatRefs
      
global function Challenge_CanRerollChallenge
global function Challenge_IsChallengesStateInititated
global function DoesPlayerHaveChallenge
global function RegisterChallengeSource
global function RegisterChallengeFromAsset
global function Challenge_IsAssigned
global function Challenge_GetGameModeTagColor
global function Challenge_GetGameModeTag
global function Challenge_GetGameMode
                 
global function Challenge_EitherOr_GetGameModes
      
global function IsChallengeValidAsFavorite
#if DEV
global function Challenge_GetTierDataBlock
global function Challenge_GetCharacterItemFlavors
global function PrintChallengePersistence
#endif
#endif                         

#if CLIENT || UI
global function Challenge_GetDescription
                 
global function Challenge_EitherOr_GetDescriptions
      
global function SetRuiArgsForChallengeTier
global function SetRuiArgsForChallengeReward
global function GetChallengeRewardDisplayData
global function UpdateChallengeCategorySelection
global function IncrementCategorySelection
global function DecrementCategorySelection
global function SetSeasonColors
global function SetBattlePassLevelBadgeForLevel
global function SetRuiArgsForMythicSkinChallenge
global function IsFavoriteChallenge

#if DEV
global function DEV_DumpFavoritePersistenceData
#endif
#endif

#if SERVER
                                                  
                                              
                                                
                               
                                               
                                                      
                                                      
                                                         
                                                             
                                                     
#endif

#if SERVER && DEV
                                   
                                     
                                            
                                         
                                             
                                           
                                           
                                    
                                  
                                          
                                           
                                         
                            
                                                
#endif

#if CLIENT
global function ServerToClient_AssignedChallengesDidChange
global function ServerToClient_AssignedChallengesDidChange_FromEventsRefresh
global function ServerToClient_ChallengeDataDidChange
global function UpdateMinimapChallengeRui
global function UpdateClientCategorySelectionIndexFromUI
#endif

#if DEV
global function DEV_PrintAllChallenges
#endif

#if UI
global function GetPlayerChallengeGroupData
global function GetPinnedChallenges
global function Challenge_IsPinned
global function ClientToUI_AssignedChallengesDidChange
global function ClientToUI_ChallengeDataDidChange
global function UpdateLobbyChallengeMenu
global function HideLobbyChallengeMenu
global function GetLobbyChallengeButtons
global function GetLobbyStoryChallengeButtons
global function GetPlayerChallengesWithNewProgress
global function GetRowsInChallengeProgressDataArray
global function MaybeAddChallengeClickEventToButton
global function RemoveChallengeFocusEventToButton
global function RemoveChallengeClickEventToButton
global function EventChallengesDidRefreshOnUI
global function UpdateChallengeRowsRui
global function TrySetBattlePassRewardOnButton
global function GetStarChallengeProgressStartLastMatch
global function UpdateChallengeBoxHeaderBPProgress
global function ChallengeInspectNextReward
#endif


                      
                      
                      
                      
                      

#if SERVER || CLIENT || UI
enum eChallengeCategory
{
	EVENT_00,
	EVENT_01,
	EVENT_02,
	EVENT_03,
	STORY_00,
	STORY_01,
	STORY_02,
	STORY_03,
	DAILY,
	TOP_WEEKLY
	FAVORITES,
}

global enum eChallengeGameMode
{
	ANY,
	BATTLE_ROYALE,
                        
		ARENAS,
       
	NON_MODE,
                         
		CONTROL,
       
                  
		EXCEPT_BR,
       
                         
          
       
}

const table<int, string> GAME_MODE_NAME =
{
	[eChallengeGameMode.ANY] = "#GAME_MODE_ANY",
	[eChallengeGameMode.BATTLE_ROYALE] = "#GAME_MODE_BR",
                        
		[eChallengeGameMode.ARENAS] = "#GAME_MODE_ARENAS",
       
	[eChallengeGameMode.NON_MODE] = "",                                                         
                         
		[eChallengeGameMode.CONTROL] = "#GAME_MODE_CONTROL",
       
                  
		[eChallengeGameMode.EXCEPT_BR] = "#GAME_MODE_EXCEPT_BR",
       
                         
                                                      
       
}


const table<int, string> GAME_MODE_TAG =
{
	[eChallengeGameMode.ANY] = "",
	[eChallengeGameMode.BATTLE_ROYALE] = "#GAMEMODE_TAG_BATTLE_ROYAL",
                        
		[eChallengeGameMode.ARENAS] = "#GAMEMODE_TAG_ARENAS",
       
	[eChallengeGameMode.NON_MODE] = "",                                                         
                         
		[eChallengeGameMode.CONTROL] = "#GAMEMODE_TAG_CONTROL",
       
                  
		[eChallengeGameMode.EXCEPT_BR] = "#GAMEMODE_TAG_EXCEPT_BR",
       
                         
                                                         
       
}

const table<int, vector> GAME_MODE_TAG_COLOR =
{
	[eChallengeGameMode.ANY] =  <0,0,0>,
	[eChallengeGameMode.BATTLE_ROYALE] = < 64, 148, 158 >,
                        
		[eChallengeGameMode.ARENAS] = < 108,79,198 >,
       
	[eChallengeGameMode.NON_MODE] = <0,0,0>,                                                         
                         
		[eChallengeGameMode.CONTROL] = < 215,154,8 >,
       
                  
		[eChallengeGameMode.EXCEPT_BR] = < 0,71,115 >,
       
                         
                                                
       
}

                                                                                                          
const table<int, string> GAME_MODE_TO_STAT_REF_MAP =
{
	[eChallengeGameMode.ANY] = "any",                                                                                    
	[eChallengeGameMode.BATTLE_ROYALE] = "",                                                                       
                        
		[eChallengeGameMode.ARENAS] = "arenas",
       
	[eChallengeGameMode.NON_MODE] = "",                                                         
                         
		[eChallengeGameMode.CONTROL] = "control",
       
                  
		[eChallengeGameMode.EXCEPT_BR] = "all_modes_non_br",
       
                         
                                           
       
}

global enum eChallegeDifficulty
{
	VERY_EASY,
	EASY,
	MEDIUM,
	HARD,
	VERY_HARD
}

                                                                                 
                                                                     
global enum eChallengeTimeSpanKind
{
	DAILY,
	SEASON_WEEKLY,
	SEASON_WEEKLY_RECURRING,
	EVENT,
	EVENT_SPECIAL,
	EVENT_SPECIAL_2,
	EVENT_HIDDEN,                                                                        
	MYTHIC,
	FAVORITE,                                             
}

global enum eChallengeRewardStyle
{
	                                                          
	ITEM_GENERAL = 1
	ITEM_BADGE = 2
	ITEM_WEAPON_SKIN = 3
}
global enum eTinyLabelPlacementStyle
{
	                                                          
	NONE = 0
	LEFT = 1
	CENTER = 2
	BOTTOM = 3
}
#endif


#if UI
global struct ChallengeGroupData
{
	ItemFlavor ornull event
	string            groupName
	array<ItemFlavor> challenges
	int               completedChallenges
	int               timeSpanKind
}
#endif

#if UI
global struct ChallengeProgressData
{
	                                                                                            
	ItemFlavor& challengeFlav
	int         challengeGUID
	int         tier
	int         startProgress
	int         endProgress
	int         goalProgress
	bool        isTierCompleted
	bool        isEventChallenge
	bool        isEventMain
	bool        isPinned
                  
	bool		isAlt
       

	array<ChallengeProgressData> groupArray
}
#endif

#if CLIENT || UI
global struct ChallengeRewardDisplayData
{
	ItemFlavor&       flav
	int               originalQuantity
	int               displayQuantity
	int               style
	int               rarityTier
	asset             icon
	ItemFlavor ornull badgeFlav
	int               badgeTier = -1
	string            tinyLabelText = ""
	int               tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE
	bool			  isMythicSkin
}
#endif

#if CLIENT || UI
struct ChallengeSortStruct
{
	                                              
	float progressFrac,
	int week,
	int difficulty,
	ItemFlavor& challengeFlav
}
#endif

                        
                                                                
      

                 
global const int PRIMARY_CHALLENGE_INDEX = 0
global const int ALT_CHALLENGE_INDEX = 1
      

                                                         
const bool BOTS_HAVE_CHALLENGES = false

                       
                       
                       
                       
                       

                                                              
const int MAX_UNOWNED_CHAR_CHALLENGE = 1
const array<int> DAILY_CHALLENGE_SET = [ eChallegeDifficulty.VERY_EASY, eChallegeDifficulty.EASY, eChallegeDifficulty.MEDIUM, eChallegeDifficulty.HARD, eChallegeDifficulty.VERY_HARD ]
const int NUM_DAILY_CHALLENGES = 5                                              
const int NUM_FAVORITE_CHALLENGES = 5
const int NUM_WEEKLY_CHALLENGES_MAX = 11
const int NUM_CHALLENGE_WEEKS_MAX = 13
const int NUM_CHALLENGE_BUFFER_FOR_EVENTS = 16                                                                                 
const int NUM_CHALLENGES_MAX = (NUM_WEEKLY_CHALLENGES_MAX * NUM_CHALLENGE_WEEKS_MAX) + NUM_DAILY_CHALLENGES + NUM_CHALLENGE_BUFFER_FOR_EVENTS
const int NUM_POST_GAME_CHALLENGES_MAX = 32
   

global const int MAX_REWARDS_PER_CHALLENGE_TIER = 4                                          
                                                                                            

const asset BATTLE_COMPLETED_HEADER_IMAGE = $"rui/menu/battlepass/battle_pass_completed_header"

#if SERVER || CLIENT || UI
struct ChallengeState
{
	int         persistenceIdx = -1
	ItemFlavor& flav
}
#endif


#if SERVER || CLIENT || UI
struct PlayerChallengesState
{
	table<ItemFlavor, ChallengeState>   challengeStateMap
	array<ChallengeState ornull>        persistentArrayMirror
}
#endif

#if SERVER || CLIENT || UI
struct SeasonalInfoCache
{
	ItemFlavor ornull calEventOrNull
	ItemFlavor ornull battlePassOrNull
	int expirationTimestamp
}
#endif

                 
struct StatRefMapChallengePair
{
	ItemFlavor& challenge
	bool	   statIsAlt
}
      

#if SERVER || CLIENT || UI
struct FileStruct_LifetimeLevel
{
	                                                     
                  
	table<StatEntry, array<StatRefMapChallengePair> > statEntryChallengesMap
      
                                                            
       

	table<ItemFlavor, ItemFlavor>        challengeSourceMap
	table<ItemFlavor, int>               challengeSortOrdinalMap
	SeasonalInfoCache currentSeason
	array<ItemFlavor> currentStories
	array<ItemFlavor> currentEvents

	#if SERVER
		                                                             
		                                                                              
		                                                                 
		     								                   	      
	#elseif CLIENT || UI
		PlayerChallengesState localPlayerChallengesState
		int                   _challengeCategorySelectionIndex
		array<ItemFlavor>     favoriteChallengeCache
		#if UI
			bool haveEventChallengesRefreshedOnUI = false
		#endif
	#endif

	bool hasPlaylistChallengeOverrides = false
}
FileStruct_LifetimeLevel& fileLevel

global const array<int> CHALLENGE_REROLL_COSTS = [ 0, 2, 5, 10 ]
#endif

#if SERVER || CLIENT || UI
struct
{
	bool                    initialized = false
	BattlePassReward ornull nextBattlePassReward

                                                                                                                                         
	bool					hasCompletedEventEntirely = false
	bool					hasCompletedEventDailies = false
	bool					hasCompletedRegularDailies = false
} file
#endif

table<var, void functionref(var)> WORKAROUND_challengeButtonToFocusHandlerMap = {}                         
table<var, void functionref(var)> WORKAROUND_challengeButtonToClickHandlerMap = {}                         
table<var, void functionref(var)> WORKAROUND_challengeButtonToRightClickHandlerMap = {}                         


                         
                         
                         
                         
                         

#if SERVER || CLIENT || UI
void function ShChallenges_LevelInit_PreStats()
{
	FileStruct_LifetimeLevel newFileLevel
	fileLevel = newFileLevel

	AddCallback_OnItemFlavorRegistered( eItemType.challenge, OnChallengeRegistered )

	#if SERVER && DEV
		                                                  
	#endif

	#if CLIENT
		AddCreateCallback( "player", UpdateFavoriteChallengesCache )
	#endif

	#if SERVER || CLIENT
		RegisterSignal( "ChallengeDataDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange_FromEventsRefresh" )
		Remote_RegisterClientFunction( "ServerToClient_ChallengeDataDidChange", "bool" )

		Remote_RegisterServerFunction( "ClientCallback_Challenge_ReRoll", "int", INT_MIN, INT_MAX, "int", 0, eChallengeGameMode.len() )

		Remote_RegisterServerFunction( "ClientCallback_MarkStoryPrologueCompleted", "string" )
		Remote_RegisterServerFunction( "ClientCallback_SetStoryAboutActiveChapterSeen", "string" )
	#endif

	#if UI
		RegisterSignal( "UINotification_AssignedChallengesDidChange" )
		foreach ( var button, void functionref(var) focusHandler in WORKAROUND_challengeButtonToFocusHandlerMap )
		{
			if ( IsValid( button ) )
				Hud_RemoveEventHandler( button, UIE_GET_FOCUS, focusHandler )
		}
		WORKAROUND_challengeButtonToFocusHandlerMap.clear()

		foreach ( var button, void functionref(var) clickHandler in WORKAROUND_challengeButtonToClickHandlerMap )
		{
			if ( IsValid( button ) )
				Hud_RemoveEventHandler( button, UIE_CLICK, clickHandler )
		}
		WORKAROUND_challengeButtonToClickHandlerMap.clear()

		foreach ( var button, void functionref(var) clickHandler in WORKAROUND_challengeButtonToRightClickHandlerMap )
		{
			if ( IsValid( button ) )
				Hud_RemoveEventHandler( button, UIE_CLICKRIGHT, clickHandler )
		}
		WORKAROUND_challengeButtonToRightClickHandlerMap.clear()
	#endif

	#if SERVER
		                                                             
	#endif

	file.initialized = true
}

ItemFlavor ornull function RegisterChallengeFromAsset( asset challengeAsset )
{
	                                         
	var settingsBlock = GetSettingsBlockForAsset( challengeAsset )
	var tierDataArray = GetSettingsBlockArray( settingsBlock, "tiers" )
	for ( int i = 0 ; i < GetSettingsArraySize( tierDataArray ) ; i++ )
	{
		var tierBlock       = GetSettingsArrayElem( tierDataArray, i )
		var charactersArray = GetSettingsBlockArray( tierBlock, "characters" )
		foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
		{
			asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
			if ( !IsValidItemFlavorSettingsAsset( characterAsset ) )
			{
				Warning( "Skipping challenge %s because character %s is not registered", string(challengeAsset), string(characterAsset) )
				continue
			}
		}
	}

	                         
	ItemFlavor ornull challenge = RegisterItemFlavorFromSettingsAsset( challengeAsset )

	return challenge
}
#endif


#if SERVER || CLIENT || UI
void function ShChallenges_LevelInit_PostStats()
{
	#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return
	#endif

	fileLevel.hasPlaylistChallengeOverrides = GetCurrentPlaylistVarBool( "has_playlist_challenge_overrides", false )

	int timestamp = GetUnixTimestamp()

	RefreshCachedSeasonInfo()

	fileLevel.currentStories = GetActiveStoryEventArray( timestamp )
	fileLevel.currentEvents  = GetActiveBuffetEventArray( timestamp )

	if ( fileLevel.currentStories.len() == 0 )
	{
		foreach ( string cat, int idx in eChallengeCategory )
		{
			if ( ! IsStoryCategory( idx ) )
				continue

			ItemFlavor ornull activeStory = GetActiveStoryEventForCategory( timestamp, idx )
			if ( activeStory != null )
				fileLevel.currentStories.append( expect ItemFlavor( activeStory ) )
		}
	}

	if ( fileLevel.currentEvents.len() == 0 )
	{
		foreach ( string cat, int idx in eChallengeCategory )
		{
			if ( ! IsEventCategory( idx ) )
				continue

			ItemFlavor ornull activeBuffet = GetActiveBuffetEventForCategory( timestamp, idx )
			if ( activeBuffet != null )
				fileLevel.currentEvents.append( expect ItemFlavor( activeBuffet ) )
		}
	}

	foreach ( ItemFlavor challenge in GetAllChallenges() )
	{
                   
		array<bool> fetchAltRefs = [ false ]
		if ( Challenge_IsEitherOr( challenge ) )
			fetchAltRefs.append( true )

		foreach ( bool isAlt in fetchAltRefs )
		{
                         
			int tierCount = Challenge_GetTierCount( challenge )

			for ( int i = 0 ; i < tierCount ; i++ )
			{
                     
				array<string> statRefs = Challenge_GetStatRefs( challenge, i, isAlt )
         
                                                                  
          
				foreach ( string statRef in statRefs )
				{
					if ( !IsValidStatEntryRef( statRef ) )
					{
						Assert( 0, format( "Challenge '%s' tier %d refers to non-existent stat: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), i, statRef ) )
						continue
					}

					StatEntry stat = GetStatEntryByRef( statRef )

					if ( (StatEntry_GetFlags( stat ) & eStatFlags.STORE_START_OF_PREVIOUS_MATCH) == 0 )
					{
						Assert( 0, format( "Challenge '%s' refers to stat that does not have the STORE_END_OF_PREVIOUS_MATCH flag: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
						continue
					}

					if ( (StatEntry_GetFlags( stat ) & eStatFlags.PERSISTENCE_WRITE_IMMEDIATELY) == 0 )
					{
						Assert( 0, format( "Challenge '%s' refers to stat that does not have the PERSISTENCE_WRITE_IMMEDIATELY flag: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
						continue
					}

					                                                                                                     
					                                                                                                                                      
					                                                                                                                                                                            
					                                                                                                                        
                      
					string gameModeName = GAME_MODE_NAME[Challenge_GetGameMode( challenge, isAlt )]
					string gameModeStatRef = GAME_MODE_TO_STAT_REF_MAP[Challenge_GetGameMode( challenge, isAlt )]
          
                                                                             
                                                                                           
           
					if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENT_HIDDEN )
					{
						continue
					}
                      
					else if ( gameModeStatRef != "" && Challenge_GetGameMode( challenge, isAlt ) != eChallengeGameMode.ANY && statRef.toupper().find( gameModeStatRef.toupper() ) == -1 )                                                     
          
                                                                                                                                                                                                                        
           
					{
						Assert( 0, format( "Challenge '%s' refers to stat that does not match this game mode: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
						continue
					}
                      
					else if ( gameModeStatRef != "" && Challenge_GetGameMode( challenge ) == eChallengeGameMode.EXCEPT_BR && statRef.toupper().find( gameModeStatRef.toupper() ) == -1 )
					{
						Assert( 0, format( "Challenge '%s' refers to stat that is not a mode-aggregate (any-mode-except-BR) stat: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
						continue
					}
           
					else if ( gameModeStatRef == "" )                                                   
					{
						foreach ( int idx, string val in GAME_MODE_TO_STAT_REF_MAP )
						{
							if ( val != "" && statRef.toupper().find( val.toupper() ) > -1 )                                                                  
							{
								Assert( 0, format( "Challenge '%s' refers to stat that matches another game mode: '%s'", ItemFlavor_GetHumanReadableRef( challenge ), statRef ) )
								continue
							}
						}
					}

                      
					if ( !(stat in fileLevel.statEntryChallengesMap) )
						fileLevel.statEntryChallengesMap[ stat ] <- []
					StatRefMapChallengePair	pair
					pair.challenge = challenge
					pair.statIsAlt = isAlt
					fileLevel.statEntryChallengesMap[ stat ].append( pair )
          
                                                       
                                                    
                                                                 
           
				}

                     
				if ( Challenge_GetGoalVal( challenge, i, isAlt ) <= 0 )
         
                                                    
          
				{
					Assert( 0, format( "Challenge '%s' has invalid goal val: %d", ItemFlavor_GetHumanReadableRef( challenge ), Challenge_GetGoalVal( challenge, i ) ) )
					continue
				}
			}
                   
		}
        
	}

	#if UI
		thread InitChallengesThread()
	#endif
}
#endif

#if UI
void function InitChallengesThread()
{
	while ( !IsFullyConnected() )
		WaitFrame()

	ClientToUI_AssignedChallengesDidChange()
	ClientToUI_ChallengeDataDidChange( false )                               
	SetChallengeCategory()
}
#endif

#if SERVER || CLIENT || UI
void function RegisterChallengeSource( ItemFlavor challengeFlav, ItemFlavor sourceFlav, int sortOrdinal )
{
	if ( challengeFlav in fileLevel.challengeSourceMap )
	{
		Warning( "Challenge %s source is ambiguous: %s, %s", ItemFlavor_GetHumanReadableRef( challengeFlav ), ItemFlavor_GetHumanReadableRef( fileLevel.challengeSourceMap[challengeFlav] ), ItemFlavor_GetHumanReadableRef( sourceFlav ) )
		return
	}
	fileLevel.challengeSourceMap[challengeFlav] <- sourceFlav
	fileLevel.challengeSortOrdinalMap[challengeFlav] <- sortOrdinal
}
#endif


#if SERVER
                                                                                                          
 
	                                                                  
	 
		                                
		                              
		           
	 

	                         
		      

	                                                      
		      

	                                                       
		      

	                                                                 
                  
	                                                                                       
	 
		                                                        
		 
			                                                                   
			                                                                                                     

			                                                                               
			                           
			 
				                                     
			 
		 
	 
      
                                                                                
  
                                                     
   
                                                                      
                                                                                   

                                                                             
                              
    
                                         
    
   
  
       
 
#endif


#if SERVER || CLIENT || UI
void function OnChallengeRegistered( ItemFlavor challenge )
{
	  
}
#endif


#if SERVER && DEV && !SP
                                      
 
	                                                                                      
	                                   
	                                         
	                                                                                  
	                                        
                  
	                                                                       
       
	                       

	                                                                                                                              
	                                   
	                                            
	                                                                       
                  
	                                                                       
       
	                       

	                                           
	                                                                                             
	                                                                                                                          

	                                                 
	                                              
	                                                          
	                                                    
	                                                     
	                                                              

	                                                                                         

	                                                                                   

	                                                                               
	                                                          
	 
		                                                                                
		                                 
			                                                
	 

	                           
 
#endif


#if CLIENT
void function ServerToClient_AssignedChallengesDidChange()
{
	ServerToClient_AssignedChallengesDidChange_Common( false )
}
#endif


#if CLIENT
void function ServerToClient_AssignedChallengesDidChange_FromEventsRefresh()
{
	ServerToClient_AssignedChallengesDidChange_Common( true )
}
#endif


#if CLIENT
void function ServerToClient_AssignedChallengesDidChange_Common( bool didEventChallengesRefresh )
{
	InitPlayerChallengesStateFromPersistence( GetLocalClientPlayer(), fileLevel.localPlayerChallengesState )
	RunUIScript( "ClientToUI_AssignedChallengesDidChange" )

	ServerToClient_ChallengeDataDidChange( didEventChallengesRefresh )
}
#endif


#if UI
void function ClientToUI_AssignedChallengesDidChange()
{
	InitPlayerChallengesStateFromPersistence( GetLocalClientPlayer(), fileLevel.localPlayerChallengesState )

	Signal( uiGlobal.signalDummy, "UINotification_AssignedChallengesDidChange" )
}
#endif


#if CLIENT
void function ServerToClient_ChallengeDataDidChange( bool didEventChallengesRefresh )
{
	RunUIScript( "ClientToUI_ChallengeDataDidChange", didEventChallengesRefresh )
	UpdateFavoriteChallengesCache( GetLocalClientPlayer() )
}
#endif


#if UI
void function ClientToUI_ChallengeDataDidChange( bool didEventChallengesRefresh )
{
	if ( IsLobby() && IsLocalClientEHIValid() )
	{
		UpdateFavoriteChallengesCache( GetLocalClientPlayer() )
		UpdateLobbyChallengeMenu()
		Mythics_UpdateTrackingButton()
		#if NX_PROG
			if ( !IsNxHandheldMode() )
				UpdateMiniPromoPinning()
		#else
			UpdateMiniPromoPinning()
		#endif
		var button = AllChallengesMenu_GetLastGroupButton()
		AllChallengesMenu_UpdateCategories( null )
		if ( button != null )
			AllChallengesMenu_SetLastGroupButton( button )
		AllChallengesMenu_ActivateLastGroupButton()

		if ( didEventChallengesRefresh )
			fileLevel.haveEventChallengesRefreshedOnUI = true
	}
}
#endif


#if UI
bool function EventChallengesDidRefreshOnUI()
{
	return fileLevel.haveEventChallengesRefreshedOnUI
}
#endif


#if UI
void function HideLobbyChallengeMenu()
{
	#if CHALLENGE_DEBUG
		ChallengeDbg( GetLocalClientPlayer(), "" )
	#endif

	if ( !IsConnected() )
		return

	                      
	var playPanel                  = GetPanel( "PlayPanel" )
	var challengesBoxHeader        = Hud_GetChild( playPanel, "ChallengesBox" )
	var battlePassNextRewardButton = Hud_GetChild( playPanel, "ChallengesNextBPReward" )
	var challengesBoxHeaderRui     = Hud_GetRui( challengesBoxHeader )             
	var allChallengesButton        = Hud_GetChild( playPanel, "AllChallengesButton" )

	var challengeCatergoryLeft      = Hud_GetChild( playPanel, "ChallengeCatergoryLeftButton" )
	var challengeCatergorySelection = Hud_GetChild( playPanel, "ChallengeCatergorySelection" )
	var challengeCatergoryRight     = Hud_GetChild( playPanel, "ChallengeCatergoryRightButton" )
	var eventPrizeTrackButton       = Hud_GetChild( playPanel, "EventPrizeTrackButton" )
	var storyPrizeTrackButton       = Hud_GetChild( playPanel, "StoryPrizeTrackButton" )
	var challengesTags = Hud_GetChild( playPanel, "ChallengesTags" )


	array<var> btnList = GetLobbyChallengeButtons()
	array<var> btnStoryList = GetLobbyStoryChallengeButtons()

	entity player = GetLocalClientPlayer()

	foreach ( button in btnList )
		Hud_Hide( button )

	foreach ( button in btnStoryList )
		Hud_Hide( button )

	Hud_Hide( challengesBoxHeader )
	Hud_Hide( battlePassNextRewardButton )
	Hud_Hide( allChallengesButton )
	Hud_Hide( challengeCatergoryLeft )
	Hud_Hide( challengeCatergorySelection )
	Hud_Hide( challengeCatergoryRight )
	Hud_Hide( eventPrizeTrackButton )
	Hud_Hide( storyPrizeTrackButton )
	Hud_Hide( challengesTags )
}

void function UpdateLobbyChallengeMenu()
{
	#if CHALLENGE_DEBUG
		ChallengeDbg( GetLocalClientPlayer(), "" )
	#endif

	if ( !IsConnected() )
		return

	                      
	var playPanel                  = GetPanel( "PlayPanel" )
	var challengesBoxHeader        = Hud_GetChild( playPanel, "ChallengesBox" )
	var battlePassNextRewardButton = Hud_GetChild( playPanel, "ChallengesNextBPReward" )
	var challengesBoxHeaderRui     = Hud_GetRui( challengesBoxHeader )             
	var allChallengesButton        = Hud_GetChild( playPanel, "AllChallengesButton" )

	var challengeCatergoryLeft      = Hud_GetChild( playPanel, "ChallengeCatergoryLeftButton" )
	var challengeCatergorySelection = Hud_GetChild( playPanel, "ChallengeCatergorySelection" )
	var challengeCatergoryRight     = Hud_GetChild( playPanel, "ChallengeCatergoryRightButton" )
	var eventPrizeTrackButton       = Hud_GetChild( playPanel, "EventPrizeTrackButton" )
	var storyPrizeTrackButton       = Hud_GetChild( playPanel, "StoryPrizeTrackButton" )
	var challengesTags       		= Hud_GetChild( playPanel, "ChallengesTags" )

	var challengesBlur       = Hud_GetChild( playPanel, "ChallengesBlur" )


	array<var> btnList = GetLobbyChallengeButtons()
	array<var> btnStoryList = GetLobbyStoryChallengeButtons()

	entity player = GetLocalClientPlayer()

	int timestamp = GetUnixTimestamp()

	int challengeCategory          = GetChallengeDisplayCategory()
	ItemFlavor ornull currentEvent = null
	ItemFlavor ornull currentBuffetEvent = null

	if ( fileLevel.currentEvents.len() > 0 )
		currentBuffetEvent = fileLevel.currentEvents[ 0 ]

	if ( IsStoryCategory( challengeCategory ) )
	{
		if ( fileLevel.currentStories.len() > 0 )
			currentEvent = fileLevel.currentStories[ 0 ]
	}
	else if ( IsEventCategory( challengeCategory ) )
	{
		currentEvent = currentBuffetEvent
	}

	array<ItemFlavor> challenges = GetChallengesByCategory( player, challengeCategory, currentEvent )

	UpdateChallengeCategorySelection( Hud_GetRui( challengeCatergorySelection ) )
	UpdateChallengeCategoryTint( currentEvent, challengeCatergoryLeft, challengeCatergorySelection, challengeCatergoryRight, allChallengesButton )

	if ( IsEventCategory( challengeCategory ) && currentEvent != null )
	{
		expect ItemFlavor( currentEvent )
		FilterOutMainChallengeIfValid( currentEvent, challenges )
	}

	HideLobbyChallengeMenu()
	if ( IsStoryCategory( challengeCategory ) )
		UpdateChallengeBoxRowButtons( player, challenges, btnStoryList, currentEvent )
	else
		UpdateChallengeBoxRowButtons( player, challenges, btnList, currentEvent )


	UpdateChallengeBoxHeader( player, challengesBoxHeader, currentEvent )
	UpdateChallengeBoxHeaderReward( player, battlePassNextRewardButton, currentEvent )
	UpdateEventTrackButton( player, eventPrizeTrackButton, currentBuffetEvent )
	UpdateStoryTrackButton( player, storyPrizeTrackButton, currentEvent )
	UpdateChallengeTags( challengesTags )

	Hud_SetVisible( challengesTags, !IsStoryCategory( challengeCategory ) )
	Hud_Show( challengesBoxHeader )
	Hud_Show( allChallengesButton )
	Hud_Show( challengeCatergoryLeft )
	Hud_Show( challengeCatergorySelection )
	Hud_Show( challengeCatergoryRight )
	Hud_Show( challengesBlur )

	                                                  
	  
	                                
	                                                                                             
	   
	 	                                                  
	 	 
	 		                                                      
	 		 
	 			                        
	 			     
	 		 
	 	 
	  
	                                                      
          
}

bool function ShouldChallengeCountTowardsNewness( ItemFlavor challenge )
{
	if ( !Newness_IsItemFlavorNew( challenge ) )
		return false

	if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING )
		return false

	if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENT_HIDDEN )
		return false

	if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENT_SPECIAL_2 )
		return false

	return true
}
#endif

#if CLIENT
void function UpdateMinimapChallengeRui( array<var> ruiArray )
{
	if ( !IsConnected() )
		return

	#if CHALLENGE_DEBUG
		ChallengeDbg( GetLocalClientPlayer(), "" )
	#endif

	                                                                         
	var titleRui           = ruiArray[0]
	array<var> rowRuiArray = clone ruiArray
	rowRuiArray.remove( 0 )

	entity player = GetLocalClientPlayer()

	int timestamp = GetUnixTimestamp()
	ItemFlavor ornull currentEvent

	int challengeCategory = GetChallengeDisplayCategory( true )

	if ( IsEventCategory( challengeCategory ) )
	{
		if ( IsEventCategory( challengeCategory ) )
			currentEvent = GetActiveBuffetEventForCategory( timestamp, challengeCategory )
		else
			currentEvent = GetActiveBuffetEventForIndex( timestamp, 0 )
	}



	array<ItemFlavor> challenges = GetChallengesByCategory( player, challengeCategory, currentEvent )

	if ( IsEventCategory( challengeCategory ) && currentEvent != null )
	{
		expect ItemFlavor( currentEvent )
		FilterOutMainChallengeIfValid( currentEvent, challenges )
	}

	UpdateChallengeCategorySelection( titleRui, true, true )
	UpdateChallengeRowsRui( player, challenges, rowRuiArray )
}
#endif

void function FilterOutMainChallengeIfValid( ItemFlavor currentEvent, array<ItemFlavor> challenges )
{
	BuffetEventModesAndChallengesData eventData = BuffetEvent_GetModesAndChallengesData( currentEvent )
	if ( eventData.mainChallengeFlav != null )
	{
		ItemFlavor main = expect ItemFlavor( eventData.mainChallengeFlav )
		int idx         = challenges.find( main )
		if ( idx >= 0 )
		{
			challenges.remove( idx )
		}
	}
}

#if UI || CLIENT
array<ItemFlavor> function GetChallengesByCategory( entity player, int challengeCategory, ItemFlavor ornull currentEvent )
{
	bool hasActiveEvent = false
	if ( currentEvent != null )
	{
		expect ItemFlavor( currentEvent )
		hasActiveEvent = true
	}

	array<ItemFlavor> challenges
	if ( IsEventCategory( challengeCategory ) )
	{
		challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT, -1, currentEvent )
	}
	else if ( IsStoryCategory( challengeCategory ) )
	{
		expect ItemFlavor( currentEvent )

		challenges = StoryEvent_GetCurrentChapterChallenges( player,  currentEvent )
	}
	else
	{
		switch( challengeCategory )
		{
			case eChallengeCategory.DAILY:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.DAILY )
				break

			case eChallengeCategory.TOP_WEEKLY:
				challenges = GetWeeklyChallengesSortedByProgress( player )
				break

			case eChallengeCategory.FAVORITES:
				challenges = GetFavoriteChallenges( player )
				break

				unreachable
		}
	}

	return challenges
}
#endif

#if CLIENT || UI
array<ItemFlavor> function GetWeeklyChallengesSortedByProgress( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = 5

	array<ChallengeSortStruct> challengeSortArray

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpanKind( challengeFlav ) == eChallengeTimeSpanKind.SEASON_WEEKLY )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( Challenge_IsComplete( player, challengeFlav ) )
				continue

			int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
			int goalVal     = Challenge_GetGoalVal( challengeFlav, currentTier )

			int current            = 0
			array<string> statRefs = Challenge_GetStatRefs( challengeFlav, currentTier )
			foreach ( string statRef in statRefs )
			{
				Assert( IsValidStatEntryRef( statRef ) )
				StatEntry entry = GetStatEntryByRef( statRef )
				Assert( entry.type == eStatType.INT )
				current += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
			}

			int marker = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

			float progressFrac = float(current - marker) / float(goalVal)

                    
			if ( Challenge_IsEitherOr( challengeFlav ) )
			{
				bool getAlt = true
				int markerAlt  = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarkerAlt" )
				int goalValAlt = Challenge_GetGoalVal( challengeFlav, currentTier, getAlt )
				int currentAlt = 0

				array<string> altRefs = Challenge_GetStatRefs( challengeFlav, currentTier, getAlt )
				foreach ( string statRef in statRefs )
				{
					Assert( IsValidStatEntryRef( statRef ) )
					StatEntry entry = GetStatEntryByRef( statRef )
					Assert( entry.type == eStatType.INT )
					currentAlt += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
				}

				if ( ( float(currentAlt - markerAlt) / float(goalValAlt) ) > progressFrac )
					progressFrac = float(currentAlt - markerAlt) / float(goalValAlt)
			}
         

			ChallengeSortStruct sortStruct
			sortStruct.progressFrac  = progressFrac
			sortStruct.week          = Challenge_FindAssignedWeekOrder( player, challengeFlav )
			sortStruct.difficulty    = Challenge_GetDifficulty( challengeFlav )
			sortStruct.challengeFlav = challengeFlav

			challengeSortArray.append( sortStruct )
		}
	}
	challengeSortArray.sort( Challenge_SortByProgress )
	#if DEV
		foreach ( ChallengeSortStruct sortStruct in challengeSortArray )
		{
			printt( sortStruct.challengeFlav._____INTERNAL_humanReadableRef + "\t" + sortStruct.progressFrac + "\t" + sortStruct.week )
		}
	#endif

	array<ItemFlavor> topWeeklyChallenges = []
	int maxSize                           = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	string prevDescription
	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		ItemFlavor challenge = challengeSortArray[ index ].challengeFlav
		int challengeTier    = Challenge_GetCurrentTier( player, challenge )
		string challengeDesc = Challenge_GetDescription( challenge, challengeTier )
		if ( challengeDesc == prevDescription )
		{
			                                                                                                   
			continue
		}

		prevDescription = challengeDesc
		topWeeklyChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topWeeklyChallenges.len() >= maxSize )
			break
	}

	return topWeeklyChallenges
}
#endif

#if CLIENT || UI
int function Challenge_FindAssignedWeekOrder( entity player, ItemFlavor challengeFlav )
{
	int weekIndex = Challenge_GetWeekNumber( challengeFlav )

	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
	{
		#if CLIENT
			int groupIndex = player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )
		#else
			int groupIndex = GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )
		#endif
		if ( groupIndex == weekIndex )
			return i
	}

	return -1                                   
}
#endif

#if CLIENT || UI
int function Challenge_SortByProgress( ChallengeSortStruct a, ChallengeSortStruct b )
{
	              
	if ( a.progressFrac < b.progressFrac )
		return 1
	else if ( a.progressFrac > b.progressFrac )
		return -1

	              
	if ( a.week > b.week )
		return 1
	else if ( a.week < b.week )
		return -1

	              
	if ( a.difficulty > b.difficulty )
		return 1
	else if ( a.difficulty < b.difficulty )
		return -1

	return 0
}
#endif

#if SERVER
                                                                                                      
 
	                                           

	                      
	                                                               
	 
		                                                                                                         

		                                                                
		 
			                     
		 
		                                
		 
			                                                
			                                                                          
			                  
			     
		 
	 

	                         
	 
		                                        
		                                                                                              
	 

	                                             
	                                                                                       
 
#endif

#if SERVER
                                                                
 
	                                                               
	 
		                                                                                                              
		                                              
			        

		                                                               
		                                

		                                                           
			                                                                          
	 
 
#endif

#if CLIENT || UI
void function UpdateFavoriteChallengesCache( entity player )
{
	Assert( IsValid( player ) )

	if ( player != GetLocalClientPlayer() )
		return

	fileLevel.favoriteChallengeCache.clear()
	for ( int index = 0; index < NUM_FAVORITE_CHALLENGES; index++ )
	{
		SettingsAssetGUID challengeGUID = player.GetPersistentVarAsInt( format( "favoriteChallengeGUID[%d]", index ) )
		if ( !IsValidItemFlavorGUID( challengeGUID ) )
			continue

		ItemFlavor challengeFlav = GetItemFlavorByGUID( challengeGUID )

		if ( !IsChallengeValidAsFavorite( player, challengeFlav ) )
			continue

		fileLevel.favoriteChallengeCache.append( challengeFlav )
	}
}
#endif

#if CLIENT || UI
bool function HasFavoriteChallenges()
{
	return fileLevel.favoriteChallengeCache.len() > 0
}
#endif

#if CLIENT || UI
bool function IsFavoriteChallenge( ItemFlavor challengeFlav )
{
	entity player = GetLocalClientPlayer()
	return fileLevel.favoriteChallengeCache.contains( challengeFlav )
}
#endif

#if CLIENT || UI
array<ItemFlavor> function GetFavoriteChallenges( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = 5

	array<ChallengeSortStruct> challengeSortArray
	PlayerChallengesState pcs                = GetPlayerChallengesState( player )
	array<ItemFlavor> favoriteChallengeArray = fileLevel.favoriteChallengeCache

	foreach ( ItemFlavor challengeFlav in favoriteChallengeArray )
	{
		if ( !IsChallengeValidAsFavorite( player, challengeFlav ) )
			continue

		int currentTier     = Challenge_GetCurrentTier( player, challengeFlav )
		int currentProgress = Challenge_GetProgressValue( player, challengeFlav, currentTier )
		int goalProgress    = Challenge_GetGoalVal( challengeFlav, currentTier )

		ChallengeSortStruct sortStruct
		sortStruct.progressFrac  = float(currentProgress) / float(goalProgress)
		sortStruct.difficulty    = Challenge_GetDifficulty( challengeFlav )
		sortStruct.challengeFlav = challengeFlav

		challengeSortArray.append( sortStruct )
	}

	challengeSortArray.sort( Challenge_SortByProgress )

	array<ItemFlavor> topFavoriteChallenges = []
	int maxSize                             = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		topFavoriteChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topFavoriteChallenges.len() >= maxSize )
			break
	}

	return topFavoriteChallenges
}
#endif

#if SERVER || CLIENT || UI
bool function IsChallengeValidAsFavorite( entity player, ItemFlavor challengeFlav )
{
	if ( !Challenge_IsAssigned( player, challengeFlav ) )
		return false
	if ( Challenge_IsComplete( player, challengeFlav ) )
		return false
	if ( !IsChallengePlaylistEnabled( challengeFlav ) )
		return false

	return true
}
#endif

#if (CLIENT || UI) && DEV
void function DEV_DumpFavoritePersistenceData()
{
	entity player = GetLocalClientPlayer()

	printt( "PERSISTENCE" )
	for ( int index = 0; index < NUM_FAVORITE_CHALLENGES; index++ )
	{
		SettingsAssetGUID challengeGUID = player.GetPersistentVarAsInt( format( "favoriteChallengeGUID[%d]", index ) )
		printt( "\t", index, "challengeGUID", challengeGUID )

		if ( !IsValidItemFlavorGUID( challengeGUID ) )
		{
			printt( "\t\t-------" )
			continue
		}

		ItemFlavor challengeFlav = GetItemFlavorByGUID( challengeGUID )

		bool assigned        = Challenge_IsAssigned( player, challengeFlav )
		bool playlistEnabled = IsChallengePlaylistEnabled( challengeFlav )
		bool complete        = assigned ? Challenge_IsComplete( player, challengeFlav ) : false

		printt( index, "\tchallengeFlav", ItemFlavor_GetHumanReadableRef( challengeFlav ), assigned, playlistEnabled, complete )
	}
	printt( "\tCASHE" )
	foreach ( int index, ItemFlavor challengeFlav in fileLevel.favoriteChallengeCache )
	{
		bool assigned        = Challenge_IsAssigned( player, challengeFlav )
		bool playlistEnabled = IsChallengePlaylistEnabled( challengeFlav )
		bool complete        = assigned ? Challenge_IsComplete( player, challengeFlav ) : false

		printt( "\t", index, "\tchallengeFlav", ItemFlavor_GetHumanReadableRef( challengeFlav ), assigned, playlistEnabled, complete )
	}
}
#endif

#if SERVER && DEV
                                                               
 
	                                                               
	 
		                                                                          
	 

	                                                                                       
 
#endif

#if UI || CLIENT
array<int> function GetChallengeCategoryIDArray( bool hideStories = false )
{
	array<int> categoryIDtoStringArray = []

	        
	int eventIdx                       = eChallengeCategory.EVENT_00
	foreach ( event in fileLevel.currentEvents )
	{
		Assert( IsEventCategory( eventIdx ) )
		categoryIDtoStringArray.append( eventIdx++ )
	}

	                                                                                 
	if( !hideStories )
	{
		int storyIdx                       = eChallengeCategory.STORY_00
		foreach ( story in fileLevel.currentStories )
		{
			if( StoryEvent_GetShowInChallengeBoxBool( story ) ){
				Assert( IsStoryCategory( storyIdx ) )
				categoryIDtoStringArray.append( storyIdx++ )
			}
		}
	}

	bool hasFavorites = HasFavoriteChallenges()
	if ( hasFavorites )
		categoryIDtoStringArray.append( eChallengeCategory.FAVORITES )

	categoryIDtoStringArray.extend( [ eChallengeCategory.DAILY, eChallengeCategory.TOP_WEEKLY ] )

	return categoryIDtoStringArray
}

void function UpdateChallengeCategorySelection( var rui, bool longName = false, bool hideStories = false )
{
	                                                                                              
	if ( !IsConnected() )
		return

	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray( hideStories )
	int selectionSlots                 = categoryIDtoStringArray.len()
	                                                                                                                  

	int newSelectionIndex = ClampInt( fileLevel._challengeCategorySelectionIndex, 0, selectionSlots )
	fileLevel._challengeCategorySelectionIndex = newSelectionIndex

	string category = GetCategoryStringFromType( categoryIDtoStringArray[ newSelectionIndex ], longName )
	RuiSetInt( rui, "selectionSlots", selectionSlots )                            
	RuiSetInt( rui, "selectionID", newSelectionIndex )                         
	RuiSetString( rui, "selectionText", category )                                            

	#if UI
		int currCat = GetChallengeDisplayCategory( hideStories )
		if ( IsEventCategory( currCat ) )
		{
			int timestamp                  = GetUnixTimestamp()
			ItemFlavor ornull currentEvent = GetActiveBuffetEventForCategory( timestamp, currCat )

			                                                                                                                                
			if ( currentEvent == null )
			{
				RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
				RuiSetBool( rui, "eventActive", false )
				return
			}

			Assert( currentEvent != null )
			expect ItemFlavor( currentEvent )
			Assert( ItemFlavor_GetType( currentEvent ) == eItemType.calevent_buffet )

			int endTime           = CalEvent_GetFinishUnixTime( currentEvent )
			int remainingDuration = endTime - GetUnixTimestamp()

			RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? ClientTime() + remainingDuration : RUI_BADGAMETIME )
			RuiSetBool( rui, "eventActive", true )
		}
		else if ( IsStoryCategory( currCat ) )
		{
			int timestamp                  = GetUnixTimestamp()
			ItemFlavor ornull currentEvent = GetActiveStoryEventForCategory( timestamp, currCat )

			                                                                                                                                
			if ( currentEvent == null )
			{
				RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
				RuiSetBool( rui, "eventActive", false )
				return
			}

			Assert( currentEvent != null )
			expect ItemFlavor( currentEvent )
			Assert( ItemFlavor_GetType( currentEvent ) == eItemType.calevent_story_challenges )

			int endTime           = CalEvent_GetFinishUnixTime( currentEvent )
			int remainingDuration = endTime - GetUnixTimestamp()

			RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? ClientTime() + remainingDuration : RUI_BADGAMETIME )
			RuiSetBool( rui, "eventActive", true )
		}
		else
		{
			switch( currCat )
			{
				case eChallengeCategory.DAILY:
					int remainingDuration = GetPersistentVarAsInt( "dailyExpirationTime" ) - Daily_GetCurrentTime()
					RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? ClientTime() + remainingDuration : RUI_BADGAMETIME )
					RuiSetBool( rui, "eventActive", false )
					break

				case eChallengeCategory.TOP_WEEKLY:
				case eChallengeCategory.FAVORITES:
					RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
					RuiSetBool( rui, "eventActive", false )
					break
			}
		}
	#endif
}
#endif

#if UI
void function SetChallengeCategory()
{
	array<int> categoryIDArray = GetChallengeCategoryIDArray()

	if ( file.hasCompletedEventDailies || file.hasCompletedEventEntirely )
	{
		int categoryToSet = file.hasCompletedRegularDailies ? eChallengeCategory.TOP_WEEKLY : eChallengeCategory.DAILY

		foreach( int index, int categoryID in categoryIDArray )
		{
			if ( categoryID == categoryToSet )
			{
				fileLevel._challengeCategorySelectionIndex = index
				break
			}
		}
	}
	else
	{
		                                                                     
		foreach ( int index, int categoryID in categoryIDArray )
		{
			if ( IsEventCategory( categoryID ) )
			{
				fileLevel._challengeCategorySelectionIndex = index
				break
			}
		}
	}

	                                                                                                       
	if ( CanRunClientScript() )
		RunClientScript( "UpdateClientCategorySelectionIndexFromUI", fileLevel._challengeCategorySelectionIndex )
}
#endif

#if CLIENT
void function UpdateClientCategorySelectionIndexFromUI( int selectionIndex )
{
	fileLevel._challengeCategorySelectionIndex = selectionIndex
}
#endif

#if UI
void function UpdateChallengeCategoryTint( ItemFlavor ornull event, var challengeCatergoryLeft, var challengeCatergorySelection, var challengeCatergoryRight, var allChallengesButton )
{
	array<var> ruiArray
	ruiArray.append( Hud_GetRui( challengeCatergoryLeft ) )
	ruiArray.append( Hud_GetRui( challengeCatergorySelection ) )
	ruiArray.append( Hud_GetRui( challengeCatergoryRight ) )
	ruiArray.append( Hud_GetRui( allChallengesButton ) )

	vector tint = <1, 1, 1>
	if ( IsEventCategory( GetChallengeDisplayCategory() ) )
	{
		Assert( event != null )
		expect ItemFlavor( event )
		tint = BuffetEvent_GetCategoryButtonTint( event )
	}

	foreach ( var rui in ruiArray )
	{
		RuiSetFloat3( rui, "backgroundTint", tint )
	}
}
#endif

#if UI || CLIENT
int function GetCategorySelectionSize( bool hideStories = false )
{
	array<int> categoryArray = GetChallengeCategoryIDArray( hideStories )
	return categoryArray.len()
}
#endif

#if UI || CLIENT
void function IncrementCategorySelection(  bool hideStories = false, var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (fileLevel._challengeCategorySelectionIndex + 1) % GetCategorySelectionSize( hideStories )
	fileLevel._challengeCategorySelectionIndex = newSelection
}
#endif

#if UI || CLIENT
void function DecrementCategorySelection( bool hideStories = false, var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (GetCategorySelectionSize( hideStories ) + fileLevel._challengeCategorySelectionIndex - 1) % GetCategorySelectionSize( hideStories )
	fileLevel._challengeCategorySelectionIndex = newSelection
}
#endif

#if UI || CLIENT
int function GetChallengeDisplayCategory( bool hideStories = false )
{
	                                                                    
	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray( hideStories )
	Assert( fileLevel._challengeCategorySelectionIndex < categoryIDtoStringArray.len() )

	if ( fileLevel._challengeCategorySelectionIndex >= categoryIDtoStringArray.len() )
		fileLevel._challengeCategorySelectionIndex = 0

	return categoryIDtoStringArray[ fileLevel._challengeCategorySelectionIndex ]
}
#endif

#if UI || CLIENT
string function GetCategoryStringFromType( int categoryID, bool longName = false )
{
	string appendStr = longName ? "_CHALLENGES" : ""

	if ( IsEventCategory( categoryID ) )
	{
		return "#CATEGORY_EVENT" + appendStr
	}
	else if ( IsStoryCategory( categoryID ) )
	{
		return "#CATEGORY_STORY" + appendStr
	}
	else
	{
		switch( categoryID )
		{
			case eChallengeCategory.DAILY:
				return "#CATEGORY_DAILY" + appendStr
				break

			case eChallengeCategory.TOP_WEEKLY:
				return "#CATEGORY_TOP_WEEKLY" + appendStr
				break

			case eChallengeCategory.FAVORITES:
				return "#CATEGORY_FAVORITES" + appendStr
				break
		}
	}

	unreachable
}
#endif

#if UI || CLIENT
void function SetSeasonColors( var rui )
{
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull season = fileLevel.currentSeason.calEventOrNull

	if ( season != null )
	{
		expect ItemFlavor( season )
		RuiSetFloat3( rui, "seasonBGColor", Season_GetTabBGDefaultCol( season ) )
		RuiSetFloat3( rui, "seasonColor", Season_GetTabBGSelectedCol( season ) )
	}
}
#endif

#if UI
array<var> function GetLobbyChallengeButtons()
{
	var playPanel = GetPanel( "PlayPanel" )

	array<var> buttons
	for ( int rowIdx = 0; rowIdx < 5; rowIdx++ )
		buttons.append( Hud_GetChild( playPanel, "ChallengeButton" + rowIdx ) )

	return buttons
}

array<var> function GetLobbyStoryChallengeButtons()
{
	var playPanel = GetPanel( "PlayPanel" )

	array<var> buttons
	for ( int rowIdx = 0; rowIdx < 1; rowIdx++ )
		buttons.append( Hud_GetChild( playPanel, "StoryChallengeButton" + rowIdx ) )

	return buttons
}
#endif











































                          
                          
                          
                          
                          

#if UI
array<ChallengeGroupData> function GetPlayerChallengeGroupData( entity player )
{
	Assert( player == GetLocalClientPlayer() )
	array<ChallengeGroupData> groupData
	array<ItemFlavor> challenges = []

	        
	foreach ( event in fileLevel.currentEvents )
	{
		challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT, -1, event )
		ChallengeGroupData g = CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_EVENT" ), challenges, eChallengeTimeSpanKind.EVENT )
		g.event = event
		groupData.append( g )
	}

	                
	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT_HIDDEN )                                                                 
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_EVENT_REWARD" ), challenges, eChallengeTimeSpanKind.EVENT_HIDDEN ) )                                                                           

	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT_SPECIAL_2 )                                                                                      
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_EVENT_SPECIAL" ), challenges, eChallengeTimeSpanKind.EVENT_SPECIAL_2 ) )

	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENT_SPECIAL )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_EVENT_SPECIAL" ), challenges, eChallengeTimeSpanKind.EVENT_SPECIAL ) )

	challenges = GetAssignedChallengesByTimeSpan( GetLocalClientPlayer(), eChallengeTimeSpanKind.DAILY )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_DAILY" ), challenges, eChallengeTimeSpanKind.DAILY ) )

	                     
	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_SEASON_WEEKLY_RECURRING" ), challenges, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING ) )

	         
	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
	{
		int groupIndex = GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )
		if ( groupIndex == 0 )
			break                                                                               
		challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.SEASON_WEEKLY, groupIndex )
		if ( challenges.len() > 0 )
			groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_WEEKLY", i + 1 ), challenges, eChallengeTimeSpanKind.SEASON_WEEKLY ) )
	}

	                    
	challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.MYTHIC )
	groupData.append( CreateChallengeGroup( player, Localize( "#CHALLENGE_GROUP_MYTHIC" ), challenges, eChallengeTimeSpanKind.MYTHIC ) )

	                       
	challenges = GetFavoriteChallenges( player )
	groupData.append( CreateChallengeGroup( player, Localize( "#CATEGORY_FAVORITES" ), challenges, eChallengeTimeSpanKind.FAVORITE ) )


	return groupData
}
#endif

#if UI
array<ItemFlavor> function GetPinnedChallenges()
{
	PlayerChallengesState pcs = GetPlayerChallengesState( GetLocalClientPlayer() )

	array<ItemFlavor> pinnedChallenges
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_IsPinned( challengeFlav ) )
			pinnedChallenges.append( challengeFlav )
	}

	return pinnedChallenges
}
#endif


#if SERVER
                                                             
 
	                          
	                                                                   
 

                                                                                      
 
	                         
		      
	                                

	       
		                                    
			      
	      

	                                                      
		      

	                                                
		      

	                                                        
	                                         
		      

	            
		                       
		 
			                                                                                     
		 
	 

	                         
	                                                 

	                                                       
	                                                                                              

	                        

	                                 
	                                                 
	                                                                                
	 
		                                                       
		                     
			                                                     
	 

	                                                                                           

	                                   
		        

	                                                          
	 
		                                                
		                           
	 

	                           
	 
		                      
		                                               
		                                              
	 

	                                   
		        

	                
	 
		                                          
		                                                                                
			                                           

		                                       
		 
			                                                                
			 
				                                                                                         
				                           
					                                 
			 

			                                                                                                           
		 
	 

	                                   
		        

	                                             

	                         

	                                                                       
		                         

	                                                                             

	                               
	 
		                   
	 
	    
	 
		                                     
		                                                                                        
		                                                            
		                                    
		 
			                   
			                                                                         
		 
	 

	                                   
		        

	                                                           

	                                   
		        

	                                              

	                                   
		        

	                                                       

	                                   
		        

	                                              

	                                   
		        

	                                                                                                         

	                                                      
	                                                                                      
	 
		                
		 
			                                                                              
			                            
				                                 
		 

		                                                         
		                                                                   

		                                   
		                                                         
		 
			                                                                        
			                                      
			 
				                                                  
				                                                                                                                            
					                                                                  
						                                                                          
					    
						                                                                   
				   
			 

                    
				                                            
				 
					                
					                                                                
					                                      
					 
						                                                  
						                                                                                                                            
							                                                                  
								                                                                          
							    
								                                                                   
						   
					 
				 
         
		 

		                                                        
		                                                                
		                                                            
		 
			                                                
			                                                
			               
		 

		                                                                   

		                                                                                                                    
		                                                                                                                            
		 
                    
			                                                        
         

			                                                                                                           
			                                                                            
			                          
			                                      
			 
				                                                  
				                                                                        
			 
			                                  
				                                                                                             
		 

		                                                                                               
		                                                                                                                                 
		 
			                                                                            
			                          
			                                      
			 
				                                                  
				                                                                        
			 
			                                                                                             

                    
				                                            
				 
					                
					                                                                    
					                  
					                                      
					 
						                                                  
						                                                                        
					 
					                                                                                                
				 
         
		 
	 
 
#endif

#if SERVER || CLIENT || UI
PlayerChallengesState function GetPlayerChallengesState( entity player = null )
{
	player = AssertLocalOrServerValidPlayer( player )
	#if SERVER
		                                                 
	#elseif CLIENT || UI
		return fileLevel.localPlayerChallengesState
	#endif
}
#endif

#if SERVER || CLIENT || UI
void function InitPlayerChallengesStateFromPersistence( entity player, PlayerChallengesState pcs )
{
	if ( !IsValid( player ) )
		return

	#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return
	#endif

	foreach ( ChallengeState ornull cs in pcs.persistentArrayMirror )
	{
		if ( cs == null )
			continue
		expect ChallengeState(cs)
		cs.persistenceIdx = -1
		ItemFlavor badItemFlav
		cs.flav = badItemFlav
	}
	pcs.persistentArrayMirror.clear()
	pcs.persistentArrayMirror.resize( NUM_CHALLENGES_MAX, null )
	pcs.challengeStateMap.clear()

	#if SERVER
		                               
	#endif

	for ( int persistentArrayIdx = 0 ; persistentArrayIdx < NUM_CHALLENGES_MAX ; persistentArrayIdx++ )
	{
		int guid                        = player.GetPersistentVarAsInt( "challenges[" + persistentArrayIdx + "].guid" )
		ItemFlavor ornull challengeFlav = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
		if ( challengeFlav == null )
		{
			if ( guid > 0 )
			{
				#if SERVER
					                                                                                               
					                                                                           
					                                                                                  
					                                                                                 
                      
					                                                                                    
           
					                         
				#endif
			}
			continue
		}
		expect ItemFlavor( challengeFlav )

		ChallengeState cs
		cs.persistenceIdx                             = persistentArrayIdx
		cs.flav                                       = challengeFlav
		pcs.challengeStateMap[cs.flav] <- cs
		pcs.persistentArrayMirror[persistentArrayIdx] = cs
	}

	#if SERVER
		                         
			                                                                                     
	#endif
}
#endif

#if SERVER || CLIENT || UI
bool function Challenge_IsChallengesStateInititated( entity player )
{
	#if SERVER
		                                                                
			            
	#endif

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return pcs.challengeStateMap.len() > 0
}
#endif

#if SERVER
                                                                              
 
	                                

	                                

	                           
	 
		                                         
			           

		                                             

		                    
		                                                                                     

		                                                                                                           
		                                                
		                                        
		 
			                                                        
			                   
				                                
					                                          
					                           
					                
			      
			          
		 
		    
		 
			        
		 

		           
	 
 
#endif

#if SERVER
                                                            
 
	                                

	       
		                                    
			      
	      

	                                                                  
	                                      

	                         

	                                              
	                                                       

	                                                                                     
 
#endif

#if SERVER
                                                                    
 
	                                 
		      

	                                
 
#endif

#if SERVER
                                                     
 
	                                      
		      

	                                                       
		      

	       
		                                    
			      
	      

	                                                                                               

	                                             
	 
		                                          
		 
			                                                                

			                                                                    
			                                                               

			                                        
				        

			                                                                                      
			                                                                                              

			                                                                                                       
			                                                             

			                      
			                                  
			 
				                                            
				                
			 
			                                       
			 
				                                            
				                
			 

			                
				                                                                                     
		 
		    
		 
			                                                           
		 
	 
 
#endif

#if SERVER
                                                                           
 
	       
		                                    
			      
	      

	                                                                                                                             
	                                                                  
	                                                                                                                                             
	                                                                                             
	                                                                                                                                    


	                               
	                                                                                                          

	                                                  

	                                                                       
		                         

	                                                       
		                      

	                                                                    
	 
		                   
			                         
				                                           
				                           
				                                 
				                                          
		      
		      
	 


	                                                                                 
	                                                                                                       

	                                      
	                                                  
	 
		                                        
	 

	                                                        
		                                                 

	                                                                                                                                         
	                              

	                                                                 
	                                                  
	 
		                                               
		                                            
		                                  
	 

	                      
	 
		                   
			                         
				                                           
				                           
				                                 
				                                          
		      
		      
	 

	                     
	                                                  
	 
		                                            
	 

	                                                                                                               
	                                                      
	 
		                                            
		                                            
	 

	                               
	                                                                                 
	                   
		                         
			                                           
			                           
			                                 
			                                         
			                                
	      

	                                                             
	                                                                          
	                                 
	 
		                                                                                             
		                                                                                                                                   

		                                           
		 
			                                                   
			 
				                                            
				                                            
			 
		 
	 
	                                     

	                                                               
	                                                
 
#endif

#if DEV && SERVER
                                                                      
 
	                                                                                                          
	                                                 
	                                                      
	                                                                 
	                                              
 
#endif

#if SERVER
                                                                                  
 
	                                             
 
#endif

#if SERVER
                                                                                               
 
	                                                                   
 
#endif

#if SERVER
                                                                                              
 
	                                                                                             
	                                      

	                                         
	 
		                                                     
		 
			                     
			     
		 
	 

	                
	                           
		      

	                  
	                                  
	                                                                                    

	                                                      
	                                                                                   
	                                                                                                             

	                               
		                                                 
 
#endif

#if SERVER
                                                                     
 
	                                             
 
#endif

#if SERVER
                                                                   
 
	                                

	                                                                       
		                         

	                                                                             

	                               
		      

	                                     

	                                         
		           

	                                                                    

	                                                                                              
	                                              
	                                                                      

	                                 

	                                                                                
	                                                                                                                           

	                                         
		      

	                                            
	 
		                                                                 
		                                                                           
		                                                                     
	 
 
#endif

#if SERVER
                                                                                                           
 
	                                                                                             

	                        
		            

	                              

	                                                                                                          

	                                            
		            

	                                            

	                                             
	                                                                                                         
	                                                 
	                              
	                                                       

	                                 
	                                

	                                
	 
		                                                                           
		                         
		 
			                                               
			 
				                               
			 
		 
		                              
	 

	                                                          

	                                                                      
	 
		                                                   

		                                                                                 
		                                 
		                                 
		                         
		 
			                                      
			 
				                           
				     
			 

			                                               
			 
				                 
				     
			 
		 

		                           
		 
			        
		 

		                 
		 
			                                                                  
			 
				        
			 
		 

		                                                         

		                                    
		 
			        
		 

		                                                       
		 
			                                                                                                                     
			                                                                                                                                           
			 
				        
			 
		 

		                                    
	 

	                                   
	 
		                                       
	 

	                                         

	                                                       
	                                                                                     
	           
 
#endif

#if SERVER
                                                                                                                                          
 
	                                 

	                                                             
	                         
	                                

	                                                          

	                                                      
	 
		                        

		                     

		                        
		 
			                                    
				     

			                                               
			                                                                  
			                                    

			                                                                             
			                                 
			                                 
			                         
			 
				                                                           
				                                      
				 
					                                   
					                           
					     
				 

				                                               
				 
					                 
					     
				 
			 

			                           
			 
				               
				     
			 

			                 
			 
				                                                                 
				 
					                                  
				 
				    
				 
					                                                         
					               
					     
				 
			 

			                                                     
			                                      
			                                              
			 
				                                                
			 
			    
			 
				               
				     
			 

			                              

			                  
		 

		               
		 
			        
		 

		                     
		 
			                                                      
			                                 
			 
				                               
			 
			    
			 
				                                          
				     
			 
		 
		    
		 
			                                            
		 

		                           
		                        
	 

	                                          

	              
 
#endif

#if SERVER
                                                                     
 
	                                                                  
		         
	                                                                       
		        

	        
 
#endif


#if SERVER
                                                                           
 
	                                                             

	                                                                       
		                         

	                                                                             

	                                               

	                               
	 
		                                                                                            
	 

	                                            

	                                                              

	                               
	                                               
	 
		                       
			                                                                                             
	 

	                   
		                         
			                           
			                                                
	      

	                                                                                                                             
	                                                
	 
		                                                                                    

		                      
			        

		                                                                                                                                  

		                                                                                                                       
		                                                     
		                                                            
		 
			                      
			                               
			 
				                
			 
			    
			 
				                                     
				                                                                                    
			 

			                                   
			 
				                                            
				                                             
			 
		 

		                                                                             
		                                                        
		 
			                                                                                                                   

			                                                    
			 
				                                            
				 
					                                            
				 
			 
		 
	 
 
#endif


#if SERVER
                                                                                    
 
	                                                                                   

	                                                                     
	                               
	                                                    

	                                                                       
		                         

	                                                       
	 
		                                                                                                           
	 

	                                      
	 
		                               
		                                                                       
				                                                                             
		 
			                   
		 
	 

	                    
		      

	                                                                          
	                                          
	                                                                                
	 
		                                                                                         
			                                           
	 

	                                                
		                                                

	                           

	                   
		                                                   
	      

	                                                     
	 
		                   
			                                                                            
		    
			                                                           
	 
 
#endif


#if SERVER
                                                                                 
 
	                                                                                                                            
	                                                                                                                                         
	                                                                          
	                                                                                                              
	                                                                                                           

	                                                                       
		                         

	                                                                       
	                         
	 
		                               
		                                                               
			                                                      
	 

	                   
		                         
			                           
			                                                             
			                                    
	      

	                                                                                                                                
	                                                                    
	 
		                                                     

		                                                                       
			        

		                                            
		                                       
	 

	                                                                 
	                                                          
	 
		                                                        
			        

		                                            
		                                               
	 

	                      
		                                                                      
 
#endif


#if SERVER
                                                           
 
	                                

       
	                                    
		      
      

	                   
		                                  
		                                  
	      

	              
	 
		                                                     

		                                                                                                                   
		                                                                                                                
		                                              

		                             

		                                                                                  
		                              
		 
			                                                                                                                 
			                                          
			 
				                          
				 
					                             
					                                                          
				 
				                                                                                                                                                                                                                        
			 
		 

		                                                                                  
		                              
		 
			                                                                                                                 

			                                          
			 
				                          
				 
					                             
					                                                          
				 
				                                                                                                                                                                                                                        
			 
		 

		                                   
			        

		                                                                          
		 
			                              
			                                                                                                                                    

			                                      
			 
				                                                      
				                                                
			 

			                                     
			                                                                              
			                                        
			                                     
		 

		                                   
			        

		                                                                   
		 
			                                                            
			 
				                                                    
			 
		 

		                                   
			        

		                                       
		                                                                 
		 
			                                                            
			 
				                                                   
				                                 
			 
		 

		                         
		                                                                                                                                  
		                                                                                                                          
		                                                    
		                                     

		                                                                                              
		                                      
		 
			                                                                                            
			                           
			 
				                              
				                                                  
			 
		 

		                                   
			        

		                                                                          
		 
			                                                                   
			 
				                                                    
			 
		 

		                                   
			        

		                                              
		                                                                        
		 
			                                                                   
			 
				                                                   
				                                        
			 
		 

		                                   
			        

		                                                                         
		 
			                                                                
			                                                                    
		 


		                                                                                                       

		                                     
			     
		    
			                                      
	 
 
#endif


#if SERVER
                                                                                
 
	                                                              
	                                                                                                                                                                       

	                                                         

	                     
		      

	                             
	                     
	                                                                                                   
	 
		                                                            
			        

		                 
		                                                                  
		                                                             
		                                          
		                                                  


		                                                                                                             
		                                                                                  

		                  
		                                                      
		 
			                                                                  
			                                      
			 
				                                                  
				                                                                    
			 
		 
		                                                                                          

                   
		              
		                                                                                               
		 
			                                                                        
			                                      
			 
				                                                  
				                                                                    
			 
		 
		                                                                                             
        

		                   
			                                            
				                          
				                                                        
				                                                                 
                    
				                                                                                                  
				                                                                                                         
        
                                                                                                       
         
		      

		                                                                                 
			                                                                

		                                                                                   

		               
		     
	 
	                                                                                                                                                             
 
#endif


#if SERVER
                                                                                
 
	                                                              
	                                                                                                                                                                            

	                                                     
		      

	                                                         

	                                                                       
		                                                                                   

	                                                                                 
		                                                                                          

	                                                        

	                   
		                                         
			                         
			                                                        
			                                                                 
                   
			                                                                                                 
			                                                                                                        
       
                                                                                                     
        
	      

	                                           
	                                                   

	                                                                          
	                                                                                
                  
	                                                                                   
       
	                                                                                 

	                      
	                      
	                     
 
#endif


#if SERVER && DEV
                                                        
 
	                                                              
	                                                                                
	 
		                                                            
		                          
		                                      
		 
			                                                  
			                                                                     
		 

		                                                                                          

                   
		                                                       
		               
		                                      
		 
			                                                  
			                                                                     
		 
		                                                                                             
        

		                                                                                 
	 

	                                     
 
#endif


#if SERVER && DEV
                                                            
 
	                                                                                                               
	                            
	 
		                                

		                                  
		 
			                                     
		   

		                                                              

		                                                                                    
		                                 

		                                                                                     
		 
			                              
				     

			                 
				        
			                         

			       
			                                                         
			                                                                                    

			        
			                                                                                
			                                                            

			                                             
			 
				                                                  
				                                                                                               
				                                                  
			 

                    
			                                      
			 
				                  
				                                                                                   
				                
				                                                      

				                                             
				 
					                                                  
					                                                                                                       
					                                                  
				 
			 
         
		 

		                                     
	   
 
#endif


#if SERVER && DEV
                                                                                                
 
	                
		      
	                                                                 
	                                                                    

	                                                        
	 
		                                                     
		      
	 

	                                                                   
	                                                                                 
	                                                                   

	                                                                       

	                                                                  
	                                
	                                             
	 
		                                                  
		                                                                                  
	 

                  
	                                            
	 
		                  
		                                                                                     
		                                                                       

		                                                                   

		                
		                                                            
		                                             
		 
			                                                  
			                                                                                  
		 
	 
       

	                                     
 

#endif


#if SERVER && DEV
                                                          
 
	                                                              
	                                                                                         
	 
		                 
			        
		                         

		                                          
	 

	                                                                                     
 
#endif


#if SERVER && DEV
                                                               
 
	                
		      
	                                                          
	                                                             
	                                         

	                      
	                                                                                     
 
#endif


#if SERVER && DEV
                                                             
 
	                
		      
	                                                          
	                                                             
	                                         

	                      
	                                                                                     
 
#endif


#if SERVER && DEV
                                                                     
 
	                                                                 
	                                                                            
	                                                                                          
	                                                                            
	                                                                                
	                                                       

	                                                                     
	 
		                                                                                           
		                                                                                     
	 

	                                
	                                                                                     
 
#endif


#if SERVER || UI || CLIENT
#if DEV
void function PrintChallengePersistence( entity player )
{
	printt( "---------------------------" )
	printt( "CHALLENGES PERSISTENCE DUMP" )
	printt( "---------------------------" )
	printt( "" )
	printt( "dailyExpirationTime:", player.GetPersistentVarAsInt( "dailyExpirationTime" ) )
	printt( "weeklyRecurringLastResetWeek:", player.GetPersistentVarAsInt( "weeklyRecurringLastResetWeek" ) )
	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
		printt( "    ", player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" ) )
	printt( "" )
	printt( "  Assigned Challenges" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid                    = player.GetPersistentVarAsInt( "challenges[" + i + "].guid" )
		ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )

		if ( IsValid( challenge ) )
		{
			printt( "   ", i, ItemFlavor_GetHumanReadableRef( expect ItemFlavor( challenge ) ) )
			printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarker" ) )
                    
			if ( Challenge_IsEitherOr( expect ItemFlavor( challenge ) ) )
				printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarkerAlt" ) )
         
			printt( "       currentTier:", player.GetPersistentVarAsInt( "challenges[" + i + "].currentTier" ) )
		}
		else
		{
			printt( "   ", i, guid )
		}
	}

	printt( "" )
	printt( "  Post Game Challenges" )
	printt( "" )

	printt( "  postgameGrindStartTier:", player.GetPersistentVarAsInt( "postgameGrindStartTier" ) )
	printt( "  postgameGrindStartValue:", player.GetPersistentVarAsInt( "postgameGrindStartValue" ) )

	printt( "" )
	printt( "  Post Game Challenges Any Progress" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].guid" )
		if ( guid > 0 )
		{
			ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( IsValid( challenge ) )
			{
				printt( "   ", i, ItemFlavor_GetHumanReadableRef( expect ItemFlavor( challenge ) ) )
				printt( "       tierMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].tierMatchStart" ) )
				printt( "       progressMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].progressMatchStart" ) )
			}
		}
		else
		{
			printt( "   ", i, guid )
		}
	}


	printt( "" )
	printt( "--------------------------" )
	printt( "-- END PERSISTENCE DUMP --" )
	printt( "--------------------------" )
}
#endif
#endif                         


#if (DEV || ASSERTING)
void function DEV_PrintAllChallenges( bool assigned = false, bool currentBPOnly = true )
{
	                                                                             
	array<ItemFlavor> allChallenges = GetAllChallenges()

	#if CLIENT || UI
	if ( assigned )
	{
		allChallenges.clear()
		foreach ( int timeSpan in eChallengeTimeSpanKind )
		{
			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY )
				continue

			allChallenges.extend( GetAssignedChallengesByTimeSpan( GetLocalClientPlayer(), timeSpan ) )
		}
	}
	else if ( currentBPOnly )
	#endif
	#if SERVER
	                    
	#endif
	{
		allChallenges.clear()
		if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
			RefreshCachedSeasonInfo()

		ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
		if ( activeBattlePass == null )
			return

		expect ItemFlavor( activeBattlePass )

		int group = -1                                                                                                     
		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING, group ) )
		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.DAILY, group ) )

		int numWeeks = GetNumBattlePassChallengesWeeks( activeBattlePass )
		for ( int week = 1; week <= numWeeks; week++ )
			allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY, week ) )
	}

	array<string> ref            = []
	array<string> desc           = []
	array<string> xpReward       = []
	array<string> type           = []
	array<string> difficulty     = []
	array<string> gamemode       = []
	array<string> statref        = []
	array<string> matchReq       = []

	int refLen            = 0
	int descLen           = 0
	int xpRewardLen       = 0
	int typeLen           = 0
	int diffLen           = 0
	int modeLen           = 0

	printt( "------- ALL CHALLENGES -------" )
	foreach ( ItemFlavor challenge in allChallenges )
	{
		if ( !GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challenge ) ), true ) )
			continue

		string _type = GetEnumString( "eChallengeTimeSpanKind", Challenge_GetTimeSpanKind( challenge ) )

		if ( _type.len() > 16 )
			_type = _type.slice(0, 16)

		int tierCount = Challenge_GetTierCount( challenge )
		for ( int i = 0 ; i < tierCount ; i++ )
		{
			string _ref  = (i == 0) ? ItemFlavor_GetHumanReadableRef( challenge ) : ""

			#if CLIENT || UI
				string _desc = Challenge_GetDescription( challenge, i )
			#else          
				string _desc = ItemFlavor_GetHumanReadableRef( challenge )
			#endif
			_desc = StringReplace( _desc, "`1", "" )
			_desc = StringReplace( _desc, "`0", "" )
			_desc = StringReplace( _desc, "\n", " " )
			if ( tierCount > 1 )
				_desc = (i + 1) + ") " + _desc

			if ( _desc.len() > 64 )
				_desc = _desc.slice(0, 64) + "..."

                   
			if ( Challenge_IsEitherOr( challenge ) )
			{
				if ( _desc.len() > 30 )
					_desc = _desc.slice(0, 30) + "..."

				#if CLIENT || UI
					string _descAlt = Challenge_GetDescription( challenge, i, true )
				#else          
					string _descAlt = ItemFlavor_GetHumanReadableRef( challenge )
				#endif
				_descAlt = StringReplace( _desc, "`1", "" )
				_descAlt = StringReplace( _desc, "`0", "" )
				_descAlt = StringReplace( _desc, "\n", " " )
				if ( tierCount > 1 )
					_descAlt = (i + 1) + ") " + _descAlt

				if ( _descAlt.len() > 30 )
					_descAlt = _descAlt.slice(0, 30) + "..."

				_desc = _desc + " OR " + _descAlt
			}
        

			int stars = Challenge_GetBPStarsReward( challenge, i )
			string _xpReward
			if ( stars == 0 )                                                              
				_xpReward       = format( "1BP LVL" )
			else if ( stars == 1 )
				_xpReward       = format( "%d  STAR", Challenge_GetBPStarsReward( challenge, i ) )
			else if ( stars > 1 && stars < 10 )
				_xpReward       = format( "%d  STARS", Challenge_GetBPStarsReward( challenge, i ) )
			else if ( stars >= 10 )
				_xpReward       = format( "%d STARS", Challenge_GetBPStarsReward( challenge, i ) )

			string _diff = ""
			int _diffInt = Challenge_GetDifficulty( challenge )
			foreach ( key, val in eChallegeDifficulty )
			{
				if ( val == _diffInt )
					_diff = key
			}

			#if CLIENT || UI
				string _mode = Localize( GAME_MODE_NAME[Challenge_GetGameMode( challenge )] )
			#else          
				string _mode = GAME_MODE_NAME[Challenge_GetGameMode( challenge )]
			#endif

                   
			if ( Challenge_IsEitherOr( challenge ) )
			{
				#if CLIENT || UI
					string _modeAlt = Localize( GAME_MODE_NAME[Challenge_GetGameMode( challenge, true )] )
				#else          
					string _modeAlt = GAME_MODE_NAME[Challenge_GetGameMode( challenge, true )]
				#endif


				Assert ( _mode != _modeAlt, ItemFlavor_GetHumanReadableRef( challenge ) + " uses the SAME game mode - " + _mode + " - for both halves of Either/Or. This is not yet supported." )
				Assert ( _mode.tolower().find("any") == -1 && _modeAlt.tolower().find("any") == -1, ItemFlavor_GetHumanReadableRef( challenge ) + " uses 'ANY' mode for one half. This is not yet supported." )

				if ( _mode.len() > 6 )
					_mode = _mode.slice(0, 6)

				if ( _modeAlt.len() > 6 )
					_modeAlt = _modeAlt.slice(0, 6)

				_mode = _mode + " OR " + _modeAlt
			}
        

			array<string> statRefs = Challenge_GetStatRefs( challenge, i )
			string _stat = RegexpReplace( statRefs[0] , "SAID\\d+", "x" + statRefs.len() )
			_stat = _stat.slice( 6 )                  

                    
				if ( Challenge_IsEitherOr( challenge ) )
				{
					array<string> statRefsAlt = Challenge_GetStatRefs( challenge, i, true )
					string _statAlt = RegexpReplace( statRefsAlt[0] , "SAID\\d+", "x" + statRefsAlt.len() )
					_statAlt = _statAlt.slice( 6 )                  

					_stat = _stat + " OR " + _statAlt
				}
         

			Assert ( ! ( Challenge_IsStreak( challenge, i ) && Challenge_IsSingleMatch( challenge, i ) ), "Somehow we have an impossible combination of a Streak & Single-Match Challenge for " + ItemFlavor_GetHumanReadableRef( challenge ) + " Tier " + string(i) )
			string _matchreq = "       "
			if ( Challenge_IsStreak( challenge, i ) )
				_matchreq = "STREAK "
			else if ( Challenge_IsSingleMatch( challenge, i ) )
				_matchreq = "SINGLE "

			ref.append( _ref )
			desc.append( _desc )
			xpReward.append( _xpReward )
			type.append( i == 0 ? _type : "" )
			difficulty.append( _diff )
			gamemode.append( _mode )
			statref.append( _stat )
			matchReq.append( _matchreq )


			if ( _ref.len() > refLen )
				refLen = _ref.len()
			if ( _desc.len() > descLen )
				descLen = _desc.len()
			if ( _xpReward.len() > xpRewardLen )
				xpRewardLen = _xpReward.len()
			if ( _type.len() > typeLen )
				typeLen = _type.len()
			if ( _diff.len() > diffLen )
				diffLen = _diff.len()
			if ( _mode.len() > modeLen )
				modeLen = _mode.len()
		}
	}

	Assert( desc.len() == ref.len() && xpReward.len() == ref.len() && type.len() == ref.len() )

	ref.insert( 0, "ITEM FLAVOR NAME" )
	desc.insert( 0, "DESCRIPTION" )
	xpReward.insert( 0, "STARS" )
	type.insert( 0, "TYPE" )
	difficulty.insert( 0, "DIFFICULTY" )
	gamemode.insert( 0, "MODE" )
	statref.insert( 0, "STATREF" )
	matchReq.insert( 0, "MTCHRQ" )

	int weeklyCounter = 1                     
	int weeklyNum = 1                                                       
	for ( int i = 0 ; i < ref.len() ; i++ )
	{
		string _ref            = ref[i]
		string _desc           = desc[i]
		string _xpReward       = xpReward[i]
		string _type           = type[i]
		string _diff           = difficulty[i]
		string _mode           = gamemode[i]
		string _stat           = statref[i]
		string _matchreq	   = matchReq[i]

		if ( _type == "SEASON_WEEKLY" )
		{
			if ( weeklyNum > NUM_WEEKLY_CHALLENGES_MAX )
			{
				weeklyNum = 1
				weeklyCounter++
			}

			if ( weeklyNum == 1 )
			{
				printl( format( "WEEK #%d", weeklyCounter ) )
			}

			weeklyNum++

		}

		while( _ref.len() < refLen )
			_ref += " "
		while( _desc.len() < descLen )
			_desc += " "
		while( _xpReward.len() < xpRewardLen )
			_xpReward += " "
		while( _type.len() < typeLen )
			_type += " "
		while( _diff.len() < diffLen )
			_diff += " "
		while( _mode.len() < modeLen )
			_mode += " "

		printl( format( "%s  %s  %s  %s  %s  %s  %s  %s", _ref, _desc, _xpReward, _type, _diff, _mode, _matchreq, _stat ) )
	}

	printt( "------------------------------" )
	printt( "  Total Challenges:", allChallenges.len() )
	printt( "------------------------------" )
}
#endif


#if SERVER || CLIENT || UI
array<ItemFlavor> function GetAssignedChallengesByTimeSpan( entity player, int timeSpan, int weekIndex = -1, ItemFlavor ornull specificEvent = null )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpanKind( challengeFlav ) == timeSpan )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY && Challenge_GetWeekNumber( challengeFlav ) != weekIndex )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.EVENT && specificEvent != null )
			{
				expect ItemFlavor( specificEvent )
				int[1] OUT_nextRefreshUnixTime

				if( ItemFlavor_GetType( specificEvent ) == eItemType.calevent_story_challenges )
				{
					if( !StoryEvent_GetCurrentChapterChallenges( player, specificEvent ).contains( challengeFlav ) )
						continue
				}
				else
				{
					if ( !BuffetEvent_GetDailyChallenges_TEMP( specificEvent ).contains( challengeFlav ) &&
						 !BuffetEvent_GetCurrentChallenges_EXCLUDING_DAILIES( specificEvent, OUT_nextRefreshUnixTime ).contains( challengeFlav ) )
						continue
				}
			}


			results.append( challengeFlav )
		}
	}
	return results
}

bool function IsChallengePlaylistEnabled( ItemFlavor challengeFlav )
{
	if ( fileLevel.hasPlaylistChallengeOverrides == false )
		return true

	return GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challengeFlav ) ), true )
}
#endif

#if UI
void function UpdateChallengeBoxRowButtons( entity player, array<ItemFlavor> challenges, array<var> buttons, ItemFlavor ornull eventFlav )
{
	array<var> buttonRuis
	bool allChallengesInCategoryComplete = true
	int category = GetChallengeDisplayCategory()

	foreach ( int buttonIdx, var button in buttons )
	{
		                                                         
		Hud_Show( button )

		var rui = Hud_GetRui( button )
		buttonRuis.append( rui )

		RuiSetBool( rui, "challengeCanClickToReroll", false )

		if ( IsStoryCategory( category ) )
		{
			Assert( eventFlav != null )
			expect ItemFlavor( eventFlav )
			bool isStoryPrologue = false

			array storyChallengeGroups = StoryEvent_GetChapters( eventFlav )
			int stortyActiveChallengeGroup = StoryEvent_GetActiveChapter( player, eventFlav )
			isStoryPrologue = StoryEvent_GetChapterIsPrologue( storyChallengeGroups[ stortyActiveChallengeGroup ] )

			int activeChapter = StoryEvent_GetActiveChapter(player, eventFlav)

			RuiSetString( rui, "chapter", Localize(StoryEvent_GetChapterTagString( eventFlav, activeChapter ), activeChapter) )

			if( isStoryPrologue )
			{
				string prologueDesc = StoryEvent_GetPrologueLobbyDesc( storyChallengeGroups[ stortyActiveChallengeGroup ] )
				RuiSetString( rui, "challengeTierDesc", Localize( prologueDesc ) )
			}
		}
		else
		{
			if ( challenges.len() <= buttonIdx )
			{
				RuiSetBool( rui, "isVisible", false )
				Hud_SetEnabled( button, false )
				Hud_ClearToolTipData( button )
				continue
			}

			ItemFlavor challenge     = challenges[ buttonIdx ]
			bool isChallengeComplete = Challenge_IsComplete( player, challenge )                                        

			if ( !isChallengeComplete )
				allChallengesInCategoryComplete = false

			RuiSetBool( rui, "isVisible", true )

			int activeTier = Challenge_GetCurrentTier( player, challenge )
			if ( isChallengeComplete )
				activeTier = activeTier - 1                                                         

			bool canReroll = Challenge_CanRerollChallenge( challenge ) && !isChallengeComplete
			RuiSetBool( rui, "challengeCanClickToReroll", canReroll )

			int gameMode = Challenge_GetGameMode( challenge )
			RuiSetString( rui, "challengeModeTag", Challenge_GetGameModeTag( gameMode ) )
			RuiSetFloat3( rui, "challengeModeTagColor", Challenge_GetGameModeTagColor( gameMode ) )

			bool allowSetFavorites = false
			MaybeAddChallengeClickEventToButton( GetMenu( "LobbyMenu" ), button, challenge, activeTier, canReroll, isChallengeComplete, allowSetFavorites )
		}
	}

	UpdateChallengeRowsRui( player, challenges, buttonRuis )

	if ( allChallengesInCategoryComplete )
	{
		if ( IsEventCategory( category ) )
			file.hasCompletedEventDailies = true
		else if ( category == eChallengeCategory.DAILY )
			file.hasCompletedRegularDailies = true
	}

}
#endif

#if CLIENT || UI
void function UpdateChallengeRowsRui( entity player, array<ItemFlavor> challenges, array<var> rowRuis = [] )
{
	                                                                                  
	Assert( challenges.len() <= 5, "total:" + challenges.len() )

	foreach ( int rowIdx, var rui in rowRuis )
	{
		if ( challenges.len() <= rowIdx )
		{
			                            
			RuiSetBool( rui, "isVisible", false )
			continue
		}

		RuiSetBool( rui, "isVisible", true )

		#if CLIENT
			                                                                     
			RuiSetInt( rui, "rowIndex", rowIdx )
		#endif

		ItemFlavor challenge     = challenges[ rowIdx ]

		int tierCount            = Challenge_GetTierCount( challenge )                                                               
		int activeTier           = Challenge_GetCurrentTier( player, challenge )                              
		bool isChallengeComplete = Challenge_IsComplete( player, challenge )                                        
		if ( isChallengeComplete )
			activeTier = tierCount - 1                                                         
		bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )               

		int maxRewardIcons      = MAX_REWARDS_PER_CHALLENGE_TIER                                                     

		int gameMode
		string description
		int progress
		int goal

                   
		bool isEitherOrChallenge = Challenge_IsEitherOr( challenge )


		if( isEitherOrChallenge )
		{
			array<int> gameModes = Challenge_EitherOr_GetGameModes( challenge )
			array<string> descriptions = Challenge_EitherOr_GetDescriptions( challenge )
			array<int> progression = Challenge_EitherOr_GetProgressValues( player, challenge )
			array<int> goals = Challenge_EitherOr_GetGoalVals( challenge )

			bool playerIsPlayingBR = CurrentModeIsSurvival()
			int challengeIndexToUse = 0
			foreach( int idx, int data in gameModes)
			{
				string tag = Challenge_GetGameModeTag( data )
				if( ( tag != GAME_MODE_TAG[eChallengeGameMode.BATTLE_ROYALE] && !playerIsPlayingBR ) ||
					( tag == GAME_MODE_TAG[eChallengeGameMode.BATTLE_ROYALE] && playerIsPlayingBR )
				)
				{
					challengeIndexToUse = idx
				}
			}

			gameMode = gameModes[challengeIndexToUse]
			description = descriptions[challengeIndexToUse]
			progress = progression[challengeIndexToUse]
			goal = goals[challengeIndexToUse]
		}
		else
        
		{
			gameMode = Challenge_GetGameMode( challenge )
			description = Challenge_GetDescription( challenge, activeTier )
			progress = Challenge_GetProgressDisplayValue( player, challenge, activeTier )
			goal = Challenge_GetGoalDisplayVal( challenge, activeTier )
		}

		SetSeasonColors( rui )                                         

		vector rewardColor = <1, 1, 1>         
		int timeSpan       = Challenge_GetTimeSpanKind( challenge )
		if ( timeSpan == eChallengeTimeSpanKind.EVENT )
		{
			ItemFlavor eventFlav = Challenge_GetSource( challenge )
			rewardColor = BuffetEvent_GetRewardIconCol( eventFlav )
		}
		RuiSetFloat3( rui, "rewardColor", rewardColor )

		RuiSetString( rui, "challengeTierDesc", description )

		#if DEV
			bool doDebug = (InputIsButtonDown( KEY_LSHIFT ) && InputIsButtonDown( KEY_LCONTROL )) || (InputIsButtonDown( BUTTON_TRIGGER_LEFT_FULL ) && InputIsButtonDown( BUTTON_B ))
			if ( doDebug )
			{
				printt( "#challenge --", ItemFlavor_GetHumanReadableRef( challenge ) )
				RuiSetString( rui, "challengeTierDesc", ItemFlavor_GetHumanReadableRef( challenge ) + " | " + activeTier )
			}
		#endif


		RuiSetInt( rui, "challengeTierProgress", progress )
		RuiSetInt( rui, "challengeTierGoal", goal )
		RuiSetBool( rui, "challengeCompleted", isChallengeComplete )

		RuiSetString( rui, "challengeModeTag", Challenge_GetGameModeTag( gameMode ) )
		RuiSetFloat3( rui, "challengeModeTagColor", Challenge_GetGameModeTagColor( gameMode ) )

		bool showDiagonalWeapons                  = false                                                           
		bool shouldUseBadgeRuis                   = false                                                  
		array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, activeTier, showDiagonalWeapons, shouldUseBadgeRuis, false )
		if ( rewards.len() >= maxRewardIcons )
			Warning( "Too many rewards for one challenge: " + ItemFlavor_GetHumanReadableRef( challenge ) )

		for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
		{
			string ruiArgPrefix = "challengeTierReward" + rewardIdx
			if ( rewardIdx < rewards.len() )
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, rewards[ rewardIdx ] )
			else
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, null )
		}
	}
}
#endif

#if UI
void function UpdateChallengeBoxHeader( entity player, var challengesBoxHeader, ItemFlavor ornull eventFlav )
{
	var rui = Hud_GetRui( challengesBoxHeader )
	Assert( rui != null )

	RuiDestroyNestedIfAlive( rui, "headerBadgeHandle" )
	RuiSetInt( rui, "bpStarCount", -1 )
	RuiSetBool( rui, "showBPProgress", false )
	RuiSetBool( rui, "eventActive", false )
	RuiSetString( rui, "headerText", "" )
	RuiSetString( rui, "subText", "" )
	RuiSetString( rui, "challengeCategoryString", "" )
	RuiSetImage( rui, "headerImage", $"" )
	RuiSetFloat3( rui, "textColor1", <1.0, 1.0, 1.0> )
	RuiSetFloat3( rui, "textColor2", <0.7, 0.7, 0.7> )

	RemoveChallengeFocusEventToButton( challengesBoxHeader )
	RemoveChallengeClickEventToButton( challengesBoxHeader )

	int challengeCat = GetChallengeDisplayCategory()
	if ( IsEventCategory( challengeCat ) )
	{
		Assert( eventFlav != null )
		expect ItemFlavor( eventFlav )
		Assert( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_buffet )

		asset nestedAsset = $"ui/themed_shop_event_challenge_header_icon.rpak"
		var nestedHandle  = RuiCreateNested( rui, "headerBadgeHandle", nestedAsset )
		RuiSetAsset( nestedHandle, "headerIcon", BuffetEvent_GetHeaderIcon( eventFlav ) )

		RuiSetString( rui, "headerText", "" )                                          
		RuiSetString( rui, "progressTitle", ItemFlavor_GetShortName( eventFlav ) )

		vector textColor1 = BuffetEvent_GetHeaderTextCol1( eventFlav )
		vector textColor2 = BuffetEvent_GetHeaderTextCol2( eventFlav )
		RuiSetFloat3( rui, "textColor1", textColor1 )
		RuiSetFloat3( rui, "textColor2", textColor2 )

		RuiSetString( rui, "subText", "" )
		RuiSetString( rui, "challengeCategoryString", "#CATEGORY_EVENT_CHALLENGES" )
		UpdateChallengeBoxButtonEvent( challengesBoxHeader, eventFlav )

		int endTime           = CalEvent_GetFinishUnixTime( eventFlav )
		int remainingDuration = endTime - GetUnixTimestamp()

		asset headerImage = BuffetEvent_GetChallengeHeaderImage( eventFlav )
		                                                                  

		RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? ClientTime() + remainingDuration : RUI_BADGAMETIME )
		RuiSetBool( rui, "eventActive", true )
		RuiSetImage( rui, "headerImage", headerImage )

		BuffetEventModesAndChallengesData bData = BuffetEvent_GetModesAndChallengesData( eventFlav )
		ItemFlavor ornull main                  = bData.mainChallengeFlav

		if ( main != null )
		{
			expect ItemFlavor( main )
			if ( Challenge_IsAssigned( player, main ) )
			{
				int tier = minint( Challenge_GetCurrentTier( player, main ), Challenge_GetTierCount( main ) - 1 )
				int challengeProgressvalue = Challenge_GetProgressValue( player, main, tier )
				int challengeGoalValue = Challenge_GetGoalVal( main, tier )
				if ( challengeGoalValue == challengeProgressvalue )
					file.hasCompletedEventEntirely = true

				RuiSetInt( rui, "challengeTierProgress", challengeProgressvalue )
				RuiSetInt( rui, "challengeTierGoal", challengeGoalValue )
			}
		}
	}
	else if ( IsStoryCategory( challengeCat ) )
	{
		Assert( eventFlav != null )
		expect ItemFlavor( eventFlav )
		Assert( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_story_challenges )

		asset nestedAsset = $"ui/themed_shop_event_challenge_header_icon.rpak"
		var nestedHandle  = RuiCreateNested( rui, "headerBadgeHandle", nestedAsset )
		RuiSetAsset( nestedHandle, "headerIcon", StoryEvent_GetHeaderIcon( eventFlav ) )

		RuiSetString( rui, "headerText", "" )                                          
		RuiSetString( rui, "progressTitle", ItemFlavor_GetShortName( eventFlav ) )

		RuiSetString( rui, "subText", "" )
		RuiSetString( rui, "challengeCategoryString", "#CATEGORY_EVENT_STORY" )
		UpdateChallengeBoxButtonEvent( challengesBoxHeader, eventFlav )

		int endTime           = CalEvent_GetFinishUnixTime( eventFlav )
		int remainingDuration = endTime - GetUnixTimestamp()

		asset headerImage = StoryEvent_GetChapterHeaderImage( eventFlav )

		RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? ClientTime() + remainingDuration : RUI_BADGAMETIME )
		RuiSetBool( rui, "eventActive", true )
		RuiSetImage( rui, "headerImage", headerImage )

		int challengesCount = StoryEvent_GetChaptersCount( eventFlav )
		int challengesProgress = StoryEvent_GetChaptersProgress( player, eventFlav )
		Assert( challengesCount > 0, eventFlav._____INTERNAL_humanReadableRef +": Story quest has no challenges, must have at least one" )

		RuiSetInt( rui, "challengeTierGoal", challengesCount )
		RuiSetInt( rui, "challengeTierProgress", challengesProgress )
	}
	else
	{
		UpdateChallengeBoxBPLevelBadge( player, rui )
		UpdateChallengeBoxHeaderBPProgress( player, rui )

		RuiSetString( rui, "progressTitle", "#EOG_NEXT_REWARD_LABEL" )
		RuiSetString( rui, "headerText", "" )
		RuiSetString( rui, "subText", "" )
		RuiSetBool( rui, "eventActive", false )

		switch( challengeCat )
		{
			case eChallengeCategory.DAILY:
				RuiSetString( rui, "challengeCategoryString", "#CATEGORY_DAILY_CHALLENGES" )

				int remainingDuration = GetPersistentVarAsInt( "dailyExpirationTime" ) - Daily_GetCurrentTime()
				RuiSetGameTime( rui, "expireTime", remainingDuration > 0 ? ClientTime() + remainingDuration : RUI_BADGAMETIME )
				break

			case eChallengeCategory.TOP_WEEKLY:
				RuiSetString( rui, "challengeCategoryString", "#CATEGORY_TOP_WEEKLY_CHALLENGES" )
				RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
				break

			case eChallengeCategory.FAVORITES:
				RuiSetString( rui, "challengeCategoryString", "#CATEGORY_FAVORITES_CHALLENGES" )
				RuiSetGameTime( rui, "expireTime", RUI_BADGAMETIME )
				break
		}
	}
}
#endif

#if CLIENT || UI
void function UpdateChallengeBoxBPLevelBadge( entity player, var rui )
{
	EHI playerEHI                      = ToEHI( player )
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

	if ( activeBattlePass != null && rui != null )
	{
		expect ItemFlavor( activeBattlePass )

		int currentBattlePassXP  = GetPlayerBattlePassXPProgress( playerEHI, activeBattlePass, false )
		int battlePassLevel      = GetBattlePassLevelForXP( activeBattlePass, currentBattlePassXP ) + 1
		bool battlePassCompleted = battlePassLevel >= (GetBattlePassMaxLevelIndex( activeBattlePass ) + 1)

		SetBattlePassLevelBadgeForLevel( player, rui, activeBattlePass, battlePassLevel, battlePassCompleted )
	}
}
void function SetBattlePassLevelBadgeForLevel( entity player, var rui, ItemFlavor activeBattlePass, int battlePassLevel, bool battlePassCompleted )
{
	RuiDestroyNestedIfAlive( rui, "headerBadgeHandle" )

	EHI playerEHI                        = ToEHI( player )
	ItemFlavor headerBadge               = GetBattlePassProgressBadge( activeBattlePass )
	int ornull overrideDataIntegerOrNull = battlePassLevel

	ItemFlavor dummy
	CreateNestedGladiatorCardBadge( rui, "headerBadgeHandle", playerEHI, headerBadge, 0, dummy, overrideDataIntegerOrNull )

	RuiSetBool( rui, "battlePassCompleted", battlePassCompleted )

	if ( battlePassCompleted )
		RuiSetImage( rui, "headerImage", BATTLE_COMPLETED_HEADER_IMAGE )
	else
		RuiSetImage( rui, "headerImage", $"" )
}
#endif

#if CLIENT || UI
void function UpdateChallengeBoxHeaderBPProgress( entity player, var rui )
{
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

	if ( activeBattlePass != null )
	{
		expect ItemFlavor( activeBattlePass )

		if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
		{
			ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )

			if ( starChallenge != null )
			{
				expect ItemFlavor( starChallenge )

				if ( DoesPlayerHaveChallenge( player, starChallenge ) )
				{
					SetSeasonColors( rui )

					int tier     = Challenge_GetCurrentTier( player, starChallenge )
					int progress = Challenge_GetProgressValue( player, starChallenge, tier )
					RuiSetInt( rui, "bpStarCount", progress )
					RuiSetBool( rui, "showBPProgress", true )
				}
			}
		}
	}
}
#endif

#if UI
void function UpdateStoryTrackButton( entity player, var button, ItemFlavor ornull eventFlav )
{
	                                                                
	RemoveChallengeClickEventToButton( button )
	bool showButton = false
	if ( button != null )
	{
		if ( eventFlav != null )
		{
			expect ItemFlavor( eventFlav )

			if ( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_story_challenges )
			{
				void functionref(var) headerClickHandler = (void function( var button ) : ( eventFlav ) {
					EmitUISound( "ui_menu_accept" )
					StoryEvent_OnLobbyPlayPanelSpecialChallengeClicked( eventFlav )
				})

				Hud_AddEventHandler( button, UIE_CLICK, headerClickHandler )
				WORKAROUND_challengeButtonToClickHandlerMap[button] <- headerClickHandler
				showButton = true

				               
				                                                                      
				                                                                        

				                                
				                                                
				                                             
			}
		}
	}

	if ( showButton )
		Hud_Show( button )
	else
		Hud_Hide( button )
}
#endif

#if UI
void function UpdateChallengeTags( var panel )
{
	var rui = Hud_GetRui( panel )
	int modeNumber = 0
	int MaxShownModeTags = 3

	foreach(int gameMode, string name in GAME_MODE_NAME)
	{
		if(gameMode != eChallengeGameMode.ANY && gameMode != eChallengeGameMode.NON_MODE && gameMode != eChallengeGameMode.CONTROL && modeNumber < MaxShownModeTags)
		{
			RuiSetString( rui, "challengeModeTag" + modeNumber, name )
			RuiSetFloat3( rui, "challengeModeTagColor" + modeNumber, GAME_MODE_TAG_COLOR[gameMode] )
			modeNumber++
		}

	}

}
#endif

#if UI
void function UpdateEventTrackButton( entity player, var button, ItemFlavor ornull eventFlav )
{
	                                                                
	RemoveChallengeClickEventToButton( button )
	bool showButton = false
	if ( button != null )
	{
		if ( eventFlav != null )
		{
			expect ItemFlavor( eventFlav )

			if ( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_buffet )
			{
				void functionref(var) headerClickHandler = (void function( var button ) : ( eventFlav ) {
					EmitUISound( "ui_menu_accept" )
					BuffetEvent_OnLobbyPlayPanelSpecialChallengeClicked( eventFlav )
				})

				Hud_AddEventHandler( button, UIE_CLICK, headerClickHandler )
				WORKAROUND_challengeButtonToClickHandlerMap[button] <- headerClickHandler
				showButton = true

				asset buttonImage = BuffetEvent_GetChallengeButtonImage( eventFlav )
				vector textColor  = BuffetEvent_GetChallengeButtonTextCol( eventFlav )

				var rui = Hud_GetRui( button )
				RuiSetImage( rui, "buttonImage", buttonImage )
				RuiSetFloat3( rui, "textColor", textColor )
			}
		}
	}

	if ( showButton )
		Hud_Show( button )
	else
		Hud_Hide( button )
}
#endif

#if UI
void function UpdateChallengeBoxButtonEvent( var mainElem, ItemFlavor ornull eventFlav )
{
	                                                                                        

	RemoveChallengeFocusEventToButton( mainElem )
	RemoveChallengeClickEventToButton( mainElem )

	if ( mainElem != null )
	{
		if ( eventFlav != null )
		{
			expect ItemFlavor( eventFlav )

			if ( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_buffet )
			{
				void functionref(var) headerFocusHandler = (void function( var button ) : () {
					EmitUISound( "ui_menu_focus" )
				})

				Hud_AddEventHandler( mainElem, UIE_GET_FOCUS, headerFocusHandler )
				WORKAROUND_challengeButtonToFocusHandlerMap[mainElem] <- headerFocusHandler

				void functionref(var) headerClickHandler = (void function( var button ) : ( eventFlav ) {
					EmitUISound( "ui_menu_accept" )
					BuffetEvent_OnLobbyPlayPanelSpecialChallengeClicked( eventFlav )
				})

				Hud_AddEventHandler( mainElem, UIE_CLICK, headerClickHandler )
				WORKAROUND_challengeButtonToClickHandlerMap[mainElem] <- headerClickHandler
			}
			else if( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_story_challenges )
			{
				void functionref(var) headerFocusHandler = (void function( var button ) : () {
					EmitUISound( "ui_menu_focus" )
				})

				Hud_AddEventHandler( mainElem, UIE_GET_FOCUS, headerFocusHandler )
				WORKAROUND_challengeButtonToFocusHandlerMap[mainElem] <- headerFocusHandler

				void functionref(var) headerClickHandler = (void function( var button ) : ( eventFlav ) {
					EmitUISound( "ui_menu_accept" )
					StoryEventAboutDialog_SetEvent( eventFlav )
					AdvanceMenu( GetMenu( "StoryEventAboutDialog" ) )
				})

				Hud_AddEventHandler( mainElem, UIE_CLICK, headerClickHandler )
				WORKAROUND_challengeButtonToClickHandlerMap[mainElem] <- headerClickHandler
			}
		}
	}
}
#endif      

#if UI
void function UpdateChallengeBoxHeaderReward( entity player, var rewardButton, ItemFlavor ornull eventFlav )
{
	BattlePassReward ornull reward

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
	int category                       = GetChallengeDisplayCategory()

	if ( IsEventCategory( category ) )
	{
		ItemFlavor ornull event = GetActiveBuffetEventForCategory( GetUnixTimestamp(), category )
		if ( event != null )
		{
			expect ItemFlavor( event )
			BuffetEventModesAndChallengesData bemacd = BuffetEvent_GetModesAndChallengesData( event )

			if ( bemacd.mainChallengeFlav != null )
			{
				ItemFlavor mainChallenge = expect ItemFlavor(bemacd.mainChallengeFlav)

				if ( Challenge_IsAssigned( player, mainChallenge ) )
				{
					int maxTierCount  = Challenge_GetTierCount( mainChallenge )
					int playerTier    = Challenge_GetCurrentTier( player, mainChallenge )
					int activeTierIdx = minint( playerTier, maxTierCount - 1 )

					ItemFlavorBag rewards = Challenge_GetRewards( mainChallenge, activeTierIdx )
					int bestRewardIndex   = -1

					for ( int i = 0; i < rewards.flavors.len(); i++ )
					{
						if ( bestRewardIndex == -1 )
						{
							bestRewardIndex = i
							continue
						}

						ItemFlavor currentBestReward = rewards.flavors[ bestRewardIndex ]
						ItemFlavor currentReward     = rewards.flavors[ i ]

						if ( ItemFlavor_GetQuality( currentBestReward, 0 ) < ItemFlavor_GetQuality( currentReward, 0 ) )
						{
							bestRewardIndex = i
						}
					}
					if ( bestRewardIndex != -1 && playerTier < maxTierCount )
					{
						BattlePassReward r
						r.flav      = rewards.flavors[ bestRewardIndex ]
						r.quantity  = rewards.quantities[ bestRewardIndex ]
						r.isPremium = false
						r.level     = 1
						r.eventName = ItemFlavor_GetShortName( event )
						r.isEventReward = true
						reward      = r
						BattlePass_PopulateRewardButton( r, rewardButton, false, true, null )
					}
					else
					{
						Hud_Hide( rewardButton )
					}
				}
			}
		}
	}
	else if ( IsStoryCategory( category ) )
	{
		Assert( eventFlav != null )
		expect ItemFlavor( eventFlav )
		Assert( ItemFlavor_GetType( eventFlav ) == eItemType.calevent_story_challenges )

		ItemFlavorBag rewards = StoryEvent_GetCompletionReward( eventFlav )
		int bestRewardIndex   = -1

		for ( int i = 0; i < rewards.flavors.len(); i++ )
		{
			if ( bestRewardIndex == -1 )
			{
				bestRewardIndex = i
				continue
			}

			ItemFlavor currentBestReward = rewards.flavors[ bestRewardIndex ]
			ItemFlavor currentReward     = rewards.flavors[ i ]

			if ( ItemFlavor_GetQuality( currentBestReward, 0 ) < ItemFlavor_GetQuality( currentReward, 0 ) )
			{
				bestRewardIndex = i
			}
		}
		bool isOwned = StoryEvent_GetChaptersProgress( player, eventFlav ) / StoryEvent_GetChaptersCount( eventFlav  ) >= 1.0
		if ( bestRewardIndex != -1  )
		{
			BattlePassReward r
			r.flav      = rewards.flavors[ bestRewardIndex ]
			r.quantity  = rewards.quantities[ bestRewardIndex ]
			r.isPremium = false
			r.level     = 1
			r.eventName = ItemFlavor_GetShortName( eventFlav )
			r.isEventReward = true
			reward      = r
			BattlePass_PopulateRewardButton( r, rewardButton, isOwned, true, null )
		}
		else
		{
			Hud_Hide( rewardButton )
		}
	}
	else if ( activeBattlePass != null && !IsEventCategory( category ) )
	{
		expect ItemFlavor( activeBattlePass )
		if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
		{
			int battlePassLevel = GetPlayerBattlePassLevel( player, activeBattlePass, false ) + 1
			reward = TrySetBattlePassRewardOnButton( rewardButton, activeBattlePass, battlePassLevel )
		}
	}

	Hud_Hide( rewardButton )
	file.nextBattlePassReward = null

	if ( reward != null )
	{
		Hud_Show( rewardButton )
		expect BattlePassReward( reward )
		if ( InspectItemTypePresentationSupported( reward.flav ) )
			file.nextBattlePassReward = reward
	}
}

void function ChallengeInspectNextReward( var button )
{
	if ( file.nextBattlePassReward == null )
		return

	BattlePassReward rewardData = expect BattlePassReward( file.nextBattlePassReward )
	if ( rewardData.isEventReward )
		SetChallengeRewardPresentationModeActive( rewardData.flav, rewardData.quantity, -1, "#CHALLENGE_REWARD", rewardData.eventName, false )
	else
		SetBattlePassItemPresentationModeActive( rewardData )
}


BattlePassReward ornull function TrySetBattlePassRewardOnButton( var rewardButton, ItemFlavor battlePass, int battlePassLevel, bool showFreeReward = false )
{
	BattlePassReward ornull rewardToShow
	array<BattlePassReward> rewards = GetBattlePassLevelRewards( battlePass, battlePassLevel )
	int maxLevel                    = GetBattlePassMaxLevelIndex( battlePass )
	while( rewards.len() == 0 && battlePassLevel < maxLevel )
	{
		battlePassLevel++
		rewards = GetBattlePassLevelRewards( battlePass, battlePassLevel )
	}

	foreach ( reward in rewards )
	{
		if ( showFreeReward )
		{
			if ( reward.isPremium )
				continue
			rewardToShow = reward                       
			break
		}

		if ( !reward.isPremium )
			continue

		rewardToShow = reward                          
		break
	}

	if ( rewardToShow != null )
	{
		expect BattlePassReward( rewardToShow )
		BattlePass_PopulateRewardButton( rewardToShow, rewardButton, false, true, null )
	}

	return rewardToShow
}
#endif


bool function Challenge_CanRerollChallenge( ItemFlavor challenge )
{
	if ( Challenge_GetTimeSpanKind( challenge ) != eChallengeTimeSpanKind.DAILY )
		return false

	if ( Challenge_GetDifficulty( challenge ) == eChallegeDifficulty.VERY_EASY )
		return false

	array<ItemFlavor> dailyChallengePool = clone GetAllChallengesOfTimespan( eChallengeTimeSpanKind.DAILY )
	array<ItemFlavor> rerollPool

	int diff = Challenge_GetDifficulty( challenge )

	foreach ( ch in dailyChallengePool )
	{
		if ( Challenge_GetDifficulty( ch ) == diff )
			rerollPool.append( ch )
	}

	if ( rerollPool.len() <= 1 )
		return false

	return true
}

















#if CLIENT || UI
                 
void function SetRuiArgsForChallengeTier( var rui, string ruiArgPrefix, ItemFlavor challenge, int ornull displayTierIdx, int maxRewardIcons, int maxExtraRewardIcons, bool isEitherOrChallenge = false )
     
                                                                                                                                                                      
      
{
	                                                                                    
	                                                                                                                          

	entity player = GetLocalClientPlayer()
	string p      = ruiArgPrefix

	int challengeTierCount   = Challenge_GetTierCount( challenge )
	bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )
	int currentTierIdx       = Challenge_GetCurrentTier( player, challenge )
	if ( displayTierIdx == null )
		displayTierIdx = currentTierIdx
	expect int(displayTierIdx)
	displayTierIdx = ClampInt( displayTierIdx, 0, challengeTierCount - 1 )

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull season = fileLevel.currentSeason.calEventOrNull

	array<string> descriptions
	array<int> progression
	array<int> goals

                  
	if( isEitherOrChallenge )
	{
		descriptions = Challenge_EitherOr_GetDescriptions( challenge )
		progression = Challenge_EitherOr_GetProgressValues( player, challenge )
		goals = Challenge_EitherOr_GetGoalVals( challenge )
	}
	else
       
	{
		descriptions.append( Challenge_GetDescription( challenge, displayTierIdx ) )
		progression.append( Challenge_GetProgressDisplayValue( player, challenge, displayTierIdx ) )
		goals.append( Challenge_GetGoalDisplayVal( challenge, displayTierIdx )  )
	}

	                                                       
	   
	  	                                                              
	   

	foreach( int idx, string description in descriptions)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetString( rui, p + modifier + "TierDesc", description )
	}

	foreach( int idx, int progress in progression)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetInt( rui, p + modifier + "TierProgress", progress )
	}

	foreach( int idx, int goal in goals)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetInt( rui, p + modifier + "TierGoal", goal )
	}

	RuiSetInt( rui, p + "TiersCount", challengeTierCount )
	RuiSetBool( rui, p + "IsInfinite", challengeIsInfinite )
	RuiSetInt( rui, p + "ActiveTierIdx", currentTierIdx )
	RuiSetBool( rui, p + "Completed", Challenge_IsComplete( player, challenge ) )
	SetSeasonColors( rui )

	bool showDiagonalWeapons                  = false
	bool shouldUseBadgeRuis                   = false
	array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, displayTierIdx, showDiagonalWeapons, shouldUseBadgeRuis, true )

	int bestRarityTier = -1
	for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
	{
		if ( rewardIdx < rewards.len() )
		{
			ChallengeRewardDisplayData crdd = rewards[rewardIdx]
			bestRarityTier = maxint( bestRarityTier, crdd.rarityTier )
			if ( rewardIdx >= maxRewardIcons )
			{
				if ( maxRewardIcons > 0 )
					Warning( "Too many rewards for one challenge tier. RUI will not display reward with icon: %s", string(crdd.icon) )
				continue              
			}

			SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), crdd )

			continue              
		}
		else if ( rewardIdx >= maxRewardIcons )
			continue              

		                       
		SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), null )
	}

	RuiSetInt( rui, p + "TierBestRarityTier", bestRarityTier )
}

void function SetRuiArgsForChallengeReward( var rui, string ruiArgPrefix, ChallengeRewardDisplayData ornull crdd )
{
	                                                                                              
	string p = ruiArgPrefix

	RuiDestroyNestedIfAlive( rui, format( "%sUi", p ) )

	if ( crdd == null )
	{
		RuiSetInt( rui, format( "%sStyle", p ), -1 )
		RuiSetInt( rui, format( "%sRarityTier", p ), -1 )
		RuiSetImage( rui, format( "%sIcon", p ), $"" )
		RuiSetString( rui, format( "%sTinyLabelText", p ), "" )
		RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), -1 )
		return
	}
	expect ChallengeRewardDisplayData(crdd)
	RuiSetInt( rui, format( "%sStyle", p ), crdd.style )
	RuiSetInt( rui, format( "%sRarityTier", p ), crdd.rarityTier )
	RuiSetImage( rui, format( "%sIcon", p ), crdd.icon )
	if ( crdd.badgeFlav != null )
	{
		CreateNestedGladiatorCardBadge( rui, format( "%sUi", p ), LocalClientEHI(),
			expect ItemFlavor(crdd.badgeFlav), -1, null, crdd.badgeTier, false )                                                    
	}
	RuiSetString( rui, format( "%sTinyLabelText", p ), crdd.tinyLabelText )
	RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), crdd.tinyLabelPlacementStyle )

	RuiSetBool( rui, "showMythicIndicator", crdd.isMythicSkin )
	if ( crdd.isMythicSkin )
		RuiSetInt( rui, "activeMythicTier", crdd.badgeTier )
}

void function SetRuiArgsForMythicSkinChallenge( var rui, int activeTier )
{
	RuiSetInt( rui, "activeMythicTier", activeTier )
}

array<ChallengeRewardDisplayData> function GetChallengeRewardDisplayData( ItemFlavor challenge, int tierIdx, bool showDiagonalWeapons, bool shouldUseBadgeRuis, bool tinyLabelToTheLeft )
{
	array<ChallengeRewardDisplayData> displayData = []

	ItemFlavorBag rewards = Challenge_GetRewards( challenge, tierIdx )
	foreach ( int itemIdx, ItemFlavor flav in rewards.flavors )
	{
		ChallengeRewardDisplayData crdd
		crdd.flav                    = flav
		crdd.originalQuantity        = rewards.quantities[itemIdx]
		crdd.displayQuantity         = crdd.originalQuantity
		crdd.style                   = eChallengeRewardStyle.ITEM_GENERAL
		crdd.rarityTier              = ItemFlavor_GetQuality( flav, eRarityTier.COMMON )
		crdd.icon                    = CustomizeMenu_GetRewardButtonImage( flav )
		crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE

		if ( ItemFlavor_GetType( flav ) == eItemType.voucher )
		{
			bool foundQuantity = false
			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) > 0 )
			{
				crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.CENTER
			}

			if ( Voucher_GetEffectBattlepassStars( flav ) > 0 )
			{
				crdd.displayQuantity *= Voucher_GetEffectBattlepassStars( flav )
				if ( tinyLabelToTheLeft )
				{
					crdd.tinyLabelText           = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.LEFT
				}
				else
				{
					crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.CENTER
				}
			}

			if ( Voucher_GetEffectBattlepassLevels( flav ) > 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectBattlepassLevels( flav )
					crdd.icon     = $"rui/menu/challenges/challenges_icon_levelup"

					                                                                                  
					crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.NONE
					crdd.tinyLabelText           = tinyLabelToTheLeft ? Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) ) : ""
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}
			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) != 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectStatAmount( flav )

					asset voucherImage = ItemFlavor_GetIcon( flav )
					if ( voucherImage != $"" )
						crdd.icon = voucherImage
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.weapon_skin )
		{
			if ( showDiagonalWeapons )
			{
				crdd.style = eChallengeRewardStyle.ITEM_WEAPON_SKIN
				crdd.icon  = WeaponItemFlavor_GetHudIcon( WeaponSkin_GetWeaponFlavor( flav ) )
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.gladiator_card_badge )
		{
			if ( shouldUseBadgeRuis )
			{
				crdd.style     = eChallengeRewardStyle.ITEM_BADGE
				crdd.icon      = $""
				crdd.badgeFlav = flav
			}

			                                                                            
			int badgeTier = 0
			for ( int prevTierIdx = 0; prevTierIdx < tierIdx; prevTierIdx++ )
			{
				ItemFlavorBag prevTierRewards = Challenge_GetRewards( challenge, prevTierIdx )
				if ( prevTierRewards.flavors.contains( flav ) )
					badgeTier++
			}

			crdd.badgeTier = badgeTier
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.account_currency || ItemFlavor_GetType( flav ) == eItemType.apex_coins )
		{
			                                                                                                                     
			crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.BOTTOM
			crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.character_skin )
		{
			crdd.isMythicSkin = Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.MYTHIC
			if ( crdd.isMythicSkin )
				crdd.badgeTier = tierIdx + 1
		}

		if ( crdd.tinyLabelText == "" )
			crdd.tinyLabelText = crdd.displayQuantity > 1 ? FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) : ""

		displayData.append( crdd )
	}

	  
		                                                   
		 
			                               
			                                               
			                                    
			                                                               
				                                                            
			                                                         
			               
		 
	  
	return displayData
}
#endif


#if UI
void function RemoveChallengeClickEventToButton( var button )
{
	if ( button in WORKAROUND_challengeButtonToClickHandlerMap )
	{
		Hud_RemoveEventHandler( button, UIE_CLICK, WORKAROUND_challengeButtonToClickHandlerMap[button] )
		delete WORKAROUND_challengeButtonToClickHandlerMap[button]
	}
}

void function RemoveChallengeRightClickEventToButton( var button )
{
	if ( button in WORKAROUND_challengeButtonToRightClickHandlerMap )
	{
		Hud_RemoveEventHandler( button, UIE_CLICKRIGHT, WORKAROUND_challengeButtonToRightClickHandlerMap[button] )
		delete WORKAROUND_challengeButtonToRightClickHandlerMap[button]
	}
}

void function RemoveChallengeFocusEventToButton( var button )
{
	if ( button in WORKAROUND_challengeButtonToFocusHandlerMap )
	{
		Hud_RemoveEventHandler( button, UIE_GET_FOCUS, WORKAROUND_challengeButtonToFocusHandlerMap[button] )
		delete WORKAROUND_challengeButtonToFocusHandlerMap[button]
	}
}

void function MaybeAddChallengeClickEventToButton( var menu, var button, ItemFlavor challenge, int activeTier, bool canReroll, bool isChallengeComplete, bool allowSetFavorites )
{
	                                                                       
	                                                                                                                  
	                                                                                                                
	                                                                                                                           
	bool addAButtonClickEvent = false
	bool addXButtonClickEvent = false

	void functionref(var) clickHandlerAButton
	void functionref(var) clickHandlerXButton
	ToolTipData toolTipData

	if ( canReroll )
	{
		addAButtonClickEvent = true

		clickHandlerAButton = (void function( var button ) : ( challenge, activeTier, menu )
		{
			if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
				RefreshCachedSeasonInfo()

			ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

			if ( !GRX_IsInventoryReady() )
				return

			if ( activeBattlePass == null )
				return

			if ( !GRX_IsInventoryReady() )
				return

			if ( !GRX_AreOffersReady() )
				return

			expect ItemFlavor( activeBattlePass )
			ItemFlavor rerollFlav = BattlePass_GetRerollFlav( activeBattlePass )

			if ( !IsDialog( GetActiveMenu() ) )
			{
				if ( !Reroll_ShouldDoGameModeSplit( challenge ) )
				{
					OpenPurchaseRerollDialog( challenge, button, menu )
				}
				else
				{
					OpenRerollDialog( challenge, button, menu )
				}
			}
		})

		                                                         
		toolTipData.tooltipStyle = eTooltipStyle.BUTTON_PROMPT
		toolTipData.actionHint1  = Localize( "#REROLL_TOOLTIP" )
	}
	else
	{
		ItemFlavorBag challengeRewards = Challenge_GetRewards( challenge, activeTier )
		if ( challengeRewards.flavors.len() == 1 && InspectItemTypePresentationSupported( challengeRewards.flavors[0] ) )
		{
			addAButtonClickEvent = true

			ItemFlavor singleRewardFlav = challengeRewards.flavors[0]
			int singleRewardFlavQty     = challengeRewards.quantities[0]

			clickHandlerAButton = (void function( var button ) : ( challenge, activeTier, singleRewardFlav, singleRewardFlavQty, isChallengeComplete ) {
				SetChallengeRewardPresentationModeActive( singleRewardFlav, singleRewardFlavQty,
					activeTier,
					"#CHALLENGE_REWARD",
					Challenge_GetDescription( challenge, activeTier ),
					isChallengeComplete
				)
			})

			toolTipData.tooltipStyle = eTooltipStyle.BUTTON_PROMPT
			toolTipData.actionHint1  = Localize( "#VIEW_REWARD_TOOLTIP" )
		}
	}

	if ( allowSetFavorites && IsChallengeValidAsFavorite( GetLocalClientPlayer(), challenge ) )
	{
		if ( toolTipData.tooltipStyle == eTooltipStyle.DEFAULT )
			toolTipData.tooltipStyle = eTooltipStyle.BUTTON_PROMPT
		else
			toolTipData.actionHint1 += "\n"

		int favoriteCount = fileLevel.favoriteChallengeCache.len()
		bool isFavorite   = IsFavoriteChallenge( challenge )
		if ( favoriteCount < NUM_DAILY_CHALLENGES || isFavorite )
		{
			if ( isFavorite )
				toolTipData.actionHint1 += Localize( "#REMOVE_FAVORITE_TOOLTIP", favoriteCount, NUM_DAILY_CHALLENGES )
			else
				toolTipData.actionHint1 += Localize( "#ADD_FAVORITE_TOOLTIP", favoriteCount, NUM_DAILY_CHALLENGES )

			addXButtonClickEvent = true
			clickHandlerXButton  = (void function( var button ) : ( challenge, isFavorite ) {
				if ( !isFavorite )
					EmitUISound( "UI_Menu_Challenge_AddFavorite" )
				else
					EmitUISound( "UI_Menu_Challenge_RemoveFavorite" )
				SettingsAssetGUID challengeGUID = ItemFlavor_GetGUID( challenge )
				Remote_ServerCallFunction( "ClientCallback_ToggleFavoriteChallenge", challengeGUID )
			})
		}
		else
		{
			toolTipData.actionHint1 += Localize( "#ALL_FAVORITE_SELECTED_TOOLTIP", favoriteCount, NUM_DAILY_CHALLENGES )

			addXButtonClickEvent = true
			clickHandlerXButton  = (void function( var button ) : () {
				                                                      
			})
		}
	}

	                                                                                                                                      
	RemoveChallengeClickEventToButton( button )
	RemoveChallengeRightClickEventToButton( button )

	if ( addAButtonClickEvent || addXButtonClickEvent )
	{
		if ( addAButtonClickEvent )
		{
			Hud_AddEventHandler( button, UIE_CLICK, clickHandlerAButton )
			WORKAROUND_challengeButtonToClickHandlerMap[button] <- clickHandlerAButton
		}

		if ( addXButtonClickEvent )
		{
			Hud_AddEventHandler( button, UIE_CLICKRIGHT, clickHandlerXButton )
			WORKAROUND_challengeButtonToRightClickHandlerMap[button] <- clickHandlerXButton
		}
		Hud_SetToolTipData( button, toolTipData )
	}
	else
	{
		Hud_ClearToolTipData( button )
	}

	Hud_SetEnabled( button, addAButtonClickEvent || addXButtonClickEvent )
}

bool function Reroll_ShouldDoGameModeSplit( ItemFlavor challenge )
{
	if ( Challenge_GetDifficulty( challenge ) <= eChallegeDifficulty.EASY )
		return false

	return true
}
#endif


#if CLIENT || UI
string function Challenge_GetDescription( ItemFlavor challenge, int tier, bool getAlt = false )
{
	int tierCount = Challenge_GetTierCount( challenge )
	Assert( tier >= 0 && tier < tierCount , "Tier: " + tier + ", tierCount: " + tierCount )

	int challengeGoal = Challenge_GetGoalVal( challenge, tier, getAlt )

	var tierData = Challenge_GetTierDataBlock( challenge, tier )

	int challengeDisplay = Challenge_GetGoalDisplayVal( challenge, tier, getAlt )

	string tierDescription = getAlt ? GetSettingsBlockString( tierData, "descriptionAlt" ) : GetSettingsBlockString( tierData, "description" )
	if ( getAlt && tierDescription == "" )
		tierDescription = GetSettingsBlockString( tierData, "description" )

	string ornull result = null

	array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( challenge, tier )

	switch ( characterFlavors.len() )
	{
		case 0:
			result = Localize( tierDescription, challengeDisplay )
			break

		case 1:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ) )
			break

		case 2:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) )  )
			break

		case 3:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) )  )
			break

		case 4:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[3] ) )  )
			break

		default:
			Assert( 0, "Invalid number of character flavors referened in challenge " + ItemFlavor_GetHumanReadableRef( challenge ) + " tier " + tier )
			break
	}

	Assert( result != null )
	return expect string(result)
}
#endif


#if SERVER || CLIENT || UI
bool function DoesPlayerHaveChallenge( entity player, ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}
#endif


#if SERVER
                                                                                  
 
	       
		                                    
			           
	      

	                                                                                  

	                                                          

	                                                                   
	                                                         
	                                                               
	                                  
	                               
		           

	                                                              
	                                                                

	                   
		                                     
			                         
			                                                        
			                                                                 
                   
				                                                                                                 
				                                                                                                        
       
                                                                                                      
        
	      

	                                                                                                   
                  
	                                                    
	                                                                                                            
       
	                                            
	                        

	                                 
	 
                   
		                                                                     
						                                                                                                                  
       
                                                                      
        
		 
				                                                                          
				                                                                                                 
				                                        
					                                                                                    
		 
		    
		 
			                                      
			     
		 

		                                 
		                                             
			                                                             

		                                              
		 
			                                                   
		 
		    
		 
			                            

			                                                            
                    
				                                                        
         

			                                                                
			 
				                                                                                
				                                                                                
				                                                    
				 
					                                                                          
					                                                                                     
					                                                                                                  
					                                                                                                                
					                                                                                 
					                                                                
				 
				    
				 
					                                                                                                                 
					                                                 
					                                                                                                 
					              
					                                          
					 
						                                                  
						                                                                    
					 
				 

				                                                                            
					                                                                
			 
			    
			 
				                                                                                                        
			 
			                                                                                         
		 

		                         
		                  

		                                                                                           
		                                  
	 

	                                        
		            

	                                                            
	 
		                                                                  
		                                             
		                  
			                                                                                           
	 
	    
	 
		                              
		                                                             
		                                                                                    
	 

	                   
		                                   
			                         
			                                                        
			                                                                 
                   
				                                                                                                 
				                                                                                                        
       
                                                                                                      
        
	      

	           
 

                                                                           
 
	                                   
		            

	                                
	 
		                              
			            
	 

	           
 
#endif


#if SERVER
                                                               
 
	                                

	                                                      
		      

	                                                
		      

	                                                
	 
		                                                                          
		                                                                                    
		                                                                                        
	 

	                                                                                                    
	                                                                       
		                         

	                                                                             

	                               
		      

	                                     

	                                                                                       

	                          
		      

	                                

	                                                         
		           

	                                                                 
	                                                                
	                                                                                                                    
 
#endif


#if SERVER
                                                                                                                                                      
 
	                                                       
	                                                          
		                                                    

	                                                                               
		                                                                        

	                                                                   
	                                                         

	                                                                                                                                                             
	                               
		      

	                                                              
	                                                                

	                          
	                          

                  
	                                                                                   
      
                                                                             
       
	                                      
	 
		                                        
		                                              
		                                     
		                                                                     
		                                                                                       
	 

	                                            
	 
		                                                                                                                                                                       
		      
	 

	                                                                      

	             
	                                                
	 
		                                                                                       
		                
		 
			        
			     
		 
	 

	               
	 
		                                                                
		      
	 

	                                                                                         
	                                                                                                 
	                                                                                                            
                  
	                                                                                   
       


	                                                                                                                                                       
 
#endif




#if SERVER || CLIENT || UI
bool function IsChallengeTierComplete( entity player, ItemFlavor challenge, int tier, bool getAlt = false )
{
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challenge ) )

                  
	int goalVal  = Challenge_GetGoalVal( challenge, tier, getAlt ? true : false )
	int progress = Challenge_GetProgressValue( player, challenge, tier, getAlt ? true : false )
      
                                                       
                                                                     
       
	return progress >= goalVal
}
#endif


#if SERVER
                                                                                              
 
	                                                             

	                                                                           

	                                      
		                                                                                                    

	                                                                                                          
	                                                                            
	 
		                                                                                             
		                          
		 
			                                                                          
			           
		 
		    
		 
			            
		 
	 

	                                                                          
	                                                     
	                                         
	                                     
		           

	                      
	                                    
	                                      
	                                
	                                                                                                                                                                                                                     
	                             
	                                                                           
	                                   
	 
		                                           
		                                                                
		                                                                            
	 
	                                                                                                                
	 
		                                                          
		                                                                                    

		                    
		 
			                                                  
		 
	 

	                                   
	 
		                   
		                                                  
		 
			                                                                                                                                       
				                
		 

		                       
		 
			                                                                                                                                      
			                                  
			                                  
		 
		    
		 
			                                                       
			                                                                         
			 
				                                  
				                                                                                    
				                                                          
				                                                       
				 
					                                                                                                                                       
						                         
				 
				                                
					                                  
				    
					     
			 
		 
	 

	                                                 
	                                               
	 
		                                                                                   
		                                                                           
		            
	 

	           
 
#endif


#if SERVER || CLIENT || UI
array<ItemFlavor> function GetAllChallenges()
{
	                                                             
	return GetAllItemFlavorsOfType( eItemType.challenge )
}
#endif


#if SERVER || CLIENT || UI
array<ItemFlavor> function GetAllChallengesOfTimespan( int timeSpan, int weekIndex = -1 )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	array<ItemFlavor> results = []

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	                                                                                                
	if ( fileLevel.currentSeason.battlePassOrNull == null && timeSpan != eChallengeTimeSpanKind.MYTHIC )
		return results

	switch ( timeSpan )
	{
		case eChallengeTimeSpanKind.EVENT:
		case eChallengeTimeSpanKind.MYTHIC:
			foreach ( ItemFlavor challenge in GetAllChallenges() )
			{
				if ( Challenge_GetTimeSpanKind( challenge ) == timeSpan )
				{
					if ( IsChallengePlaylistEnabled( challenge ) )
						results.append( challenge )
				}
			}
			break

		case eChallengeTimeSpanKind.SEASON_WEEKLY:
		case eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING:
		case eChallengeTimeSpanKind.DAILY:
			ItemFlavor pass = expect ItemFlavor( fileLevel.currentSeason.battlePassOrNull )
			foreach ( challenge in GetBattlePassChallenges( pass, timeSpan, weekIndex ) )
			{
				if ( IsChallengePlaylistEnabled( challenge ) )
					results.append( challenge )
			}
			break
	}

	return results
}
#endif

#if UI
array<ChallengeProgressData> function GetPlayerChallengesWithNewProgress( entity player )
{
	  
		                                                                                                                  
	  

	array<int> handledGUIDs = []
	array<ChallengeProgressData> progressDataArray

	for ( int index = 0 ; index < NUM_CHALLENGES_MAX ; index++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + index + "].guid" )
		if ( guid > 0 )
		{
			                                                                                                                                           
			if ( handledGUIDs.contains( guid ) )
				continue
			handledGUIDs.append( guid )

			ItemFlavor ornull challengeFlav = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( challengeFlav != null )
			{
				expect ItemFlavor( challengeFlav )

				if ( !DoesPlayerHaveChallenge( player, challengeFlav ) )
					continue

				if ( Challenge_ShouldExcludeFromPostMatchSummary( challengeFlav ) )
					continue

				int timeSpanKind      = Challenge_GetTimeSpanKind( challengeFlav )
				bool isEventChallenge = (timeSpanKind == eChallengeTimeSpanKind.EVENT)

				bool lastTierIsInfinite = Challenge_LastTierIsInfinite( challengeFlav )
				bool isPinned           = Challenge_IsPinned( challengeFlav )
				bool isEventMain
				if ( isEventChallenge )
				{
					ItemFlavor event                         = Challenge_GetSource( challengeFlav )
					BuffetEventModesAndChallengesData bemacd = BuffetEvent_GetModesAndChallengesData( event )
					isEventMain = bemacd.mainChallengeFlav == challengeFlav
				}

				int tierCount = Challenge_GetTierCount( challengeFlav )
				int startTier = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + index + "].tierMatchStart" )

				int currentTier = Challenge_GetCurrentTier( player, challengeFlav )
				if ( currentTier == tierCount )
					currentTier -= 1                                                      

				PlayerChallengesState pcs = GetPlayerChallengesState( player )
				ChallengeState cs         = pcs.challengeStateMap[ challengeFlav ]

				                                                                                                        
				int statMarker      = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )
				int startProgress   = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + index + "].progressMatchStart" )
                     
				bool useAlt			= expect bool( player.GetPersistentVar( "postGameChallengesProgress[" + index + "].useAlt" ) )
          
				int currentProgress = 0

                     
				array<string> statRefs = Challenge_GetStatRefs( challengeFlav, currentTier, useAlt )
         
                                                                                
          
				foreach ( string statRef in statRefs )
				{
					StatEntry entry = GetStatEntryByRef( statRef )
					currentProgress += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
				}

				if ( lastTierIsInfinite && startTier == (tierCount - 1) )
				{
					                                 
					if ( (statMarker <= startProgress) )
					{
						                                                   
						startProgress   = startProgress - statMarker
						currentProgress = currentProgress - statMarker
					}
					else
					{
						                                                                                                            
                       
						int _tierGoalProgress = Challenge_GetGoalVal( challengeFlav, startTier, useAlt )
           
                                                                              
            
						int _usedProgress     = statMarker - startProgress
						int _tiersCompleted   = (_usedProgress / _tierGoalProgress) + 1
						_usedProgress   = _usedProgress % _tierGoalProgress
						startProgress   = _tierGoalProgress - _usedProgress
						currentProgress = currentProgress - statMarker + (_tierGoalProgress * _tiersCompleted)
					}
				}
				else
				{
					                                                                            
					startProgress   = startProgress - statMarker
					currentProgress = currentProgress - statMarker
				}
				int ogStartProgress = startProgress                                                                            

				bool isSingleMatch = Challenge_IsSingleMatch( challengeFlav, startTier )
				if ( Challenge_IsSingleMatch( challengeFlav, startTier ) )
				{
					                                                                                 
					if ( startProgress < 0 )
						continue
				}

				int remainingProgress = currentProgress - startProgress
				                                 
				if ( remainingProgress <= 0 )
					continue                                                 

				ChallengeProgressData PreviousData
				bool shouldGroup

				while( remainingProgress > 0 )
				{
					                                                         
                      
					int tierGoalProgress = Challenge_GetGoalVal( challengeFlav, startTier, useAlt )
          
                                                                            
           
					bool tierCompleted   = startProgress + remainingProgress >= tierGoalProgress
					int usedProgress     = tierCompleted ? tierGoalProgress - startProgress : currentProgress - startProgress
					int endProgress      = startProgress + usedProgress

					var tierData                 = Challenge_GetTierDataBlock( challengeFlav, startTier )
					bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

					                                      
					ChallengeProgressData challengeProgress
					challengeProgress.challengeFlav    = challengeFlav
					challengeProgress.challengeGUID    = guid
					challengeProgress.tier             = startTier
					challengeProgress.startProgress    = displaySecondsAsMinutes ? ConvertSecondsToMinutes( ogStartProgress ) : ogStartProgress
					challengeProgress.endProgress      = displaySecondsAsMinutes ? ConvertSecondsToMinutes( endProgress ) : endProgress
					challengeProgress.goalProgress     = displaySecondsAsMinutes ? ConvertSecondsToMinutes( tierGoalProgress ): tierGoalProgress
					challengeProgress.isTierCompleted  = tierCompleted
					challengeProgress.isEventChallenge = isEventChallenge
					challengeProgress.isEventMain      = isEventMain
					challengeProgress.isPinned         = isPinned
                      
					challengeProgress.isAlt            = useAlt
           

					                            
					if ( shouldGroup )
					{
						                                                                                                                
						Assert( PreviousData.challengeGUID != 0 )
						PreviousData.groupArray.append( challengeProgress )
					}
					else
					{
						progressDataArray.append( challengeProgress )
						PreviousData = challengeProgress
					}

					bool lastTier = startTier == tierCount - 1
					if ( Challenge_ShouldStartAtZero( challengeFlav, startTier ) && lastTierIsInfinite && lastTier )
					{
						currentProgress = currentProgress - endProgress
						startProgress   = 0
					}
					else
					{
						startProgress = endProgress
					}

					remainingProgress = remainingProgress - usedProgress                                                                
					if ( lastTier )
					{
						if ( !lastTierIsInfinite )
							remainingProgress = 0                                                               
						else
							ogStartProgress = 0                                                                 
					}

					startTier++
					if ( startTier == tierCount )                                                         
						startTier -= 1

					shouldGroup = (remainingProgress > 0)
				}
			}
		}
	}

	progressDataArray.sort( PostMatchChallengeSort )

	#if DEV
		printt( "#CHALLENGE POST MATCH DATA" )
		if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
			RefreshCachedSeasonInfo()

		ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
		if ( activeBattlePass != null )
		{
			expect ItemFlavor( activeBattlePass )
			if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
			{
				ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )
				if ( starChallenge != null )
				{
					expect ItemFlavor( starChallenge )
					if ( DoesPlayerHaveChallenge( player, starChallenge ) )
					{
						int currentLevel = GetPlayerBattlePassLevel( player, activeBattlePass, false )
						int prevLevel    = GetPlayerBattlePassLevel( player, activeBattlePass, true )
						int tier         = Challenge_GetCurrentTier( player, starChallenge )
						int progress     = Challenge_GetProgressValue( player, starChallenge, tier )
						int prevProgress = GetStarChallengeProgressStartLastMatch( player, activeBattlePass )
						printt( "\tprev BP level", prevLevel )
						printt( "\tnew BP level", currentLevel )
						printt( "\tprev star count", prevProgress )
						printt( "\tnew star count", progress )
						printt( "\tstar tier", tier )
					}
				}
			}
		}


		printt( "#CHALLENGE POST MATCH SORT ORDER" )
		printt( "\ttier    start   end     goal    done    event   main    challenge" )
		printt( "\t---------------------------------------------------------" )

		foreach ( ChallengeProgressData progressData in progressDataArray )
		{
			if ( !DoesPlayerHaveChallenge( player, progressData.challengeFlav ) )
			{
				Warning( "Tried to check progress on challenge player doesn't have: " + ItemFlavor_GetHumanReadableRef( progressData.challengeFlav ) )
				continue
			}

			printt( "    " + AddPadding( string( progressData.tier ) ) +
			AddPadding( string( progressData.startProgress ) ) +
			AddPadding( string( progressData.endProgress ) ) +
			AddPadding( string( progressData.goalProgress ) ) +
			AddPadding( string( progressData.isTierCompleted ) ) +
			AddPadding( string( progressData.isEventChallenge ) ) +
			AddPadding( string( progressData.isEventMain ) ) +
			ItemFlavor_GetHumanReadableRef( progressData.challengeFlav ) )

			foreach ( int index, ChallengeProgressData groupedProgressData in progressData.groupArray )
			{
				printt( index + 1, "  " + AddPadding( string( groupedProgressData.tier ) ) +
				AddPadding( string( groupedProgressData.startProgress ) ) +
				AddPadding( string( groupedProgressData.endProgress ) ) +
				AddPadding( string( groupedProgressData.goalProgress ) ) +
				AddPadding( string( groupedProgressData.isTierCompleted ) ) +
				AddPadding( string( groupedProgressData.isEventChallenge ) ) +
				AddPadding( string( groupedProgressData.isEventMain ) ) +
				ItemFlavor_GetHumanReadableRef( groupedProgressData.challengeFlav ) )
			}
		}
	#endif

	return progressDataArray
}
#endif

#if UI
int function GetRowsInChallengeProgressDataArray( array<ChallengeProgressData> progressDataArray )
{
	int rowCount
	foreach ( ChallengeProgressData progressData in progressDataArray )
	{
		rowCount++
		foreach ( int index, ChallengeProgressData groupedProgressData in progressData.groupArray )
		{
			rowCount++
		}
	}
	return rowCount
}
#endif

#if UI
int function PostMatchChallengeSort( ChallengeProgressData a, ChallengeProgressData b )
{
	                               
	                                
	                                         

	                                             
	if ( !a.isEventChallenge && b.isEventChallenge )
		return 1
	else if ( a.isEventChallenge && !b.isEventChallenge )
		return -1

	                                                           
	if ( a.isEventMain && !b.isEventMain )
		return 1
	else if ( !a.isEventMain && b.isEventMain )
		return -1

	                                                          
	if ( a.isPinned && !b.isPinned )
		return -1
	else if ( !a.isPinned && b.isPinned )
		return 1

	                                                
	if ( !a.isTierCompleted && b.isTierCompleted )
		return 1
	else if ( a.isTierCompleted && !b.isTierCompleted )
		return -1

	                                                             
	if ( a.groupArray.len() != 0 && b.groupArray.len() == 0 )
		return 1
	else if ( a.groupArray.len() == 0 && b.groupArray.len() != 0 )
		return -1

	                        
	                                                                           
	                                                                           
	                                            
	  	        
	                                                 
	  	         

	                       
	if ( ( ( a.goalProgress - a.startProgress ) != 0 ) && ( ( b.goalProgress - b.startProgress ) != 0 ) )
	{
		float a_ProgressFrac = float( a.endProgress - a.startProgress ) / float( a.goalProgress - a.startProgress )
		float b_ProgressFrac = float( b.endProgress - b.startProgress ) / float( b.goalProgress - b.startProgress )
		if ( a_ProgressFrac < b_ProgressFrac )
			return 1
		else if ( a_ProgressFrac > b_ProgressFrac )
			return -1
	}

	                        
	return 0
}

#endif

#if UI
int function ConvertSecondsToMinutes( int seconds )
{
	return int(float( seconds ) / 60.0)
}
#endif


#if DEV
string function AddPadding( string str, int minWidth = 8 )
{
	int len = str.len()
	while ( len < minWidth )
	{
		str = str + " "
		len++
	}
	return str
}
#endif

#if SERVER || CLIENT || UI
int function Challenge_GetCurrentTier( entity player, ItemFlavor flavor )
{
	#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
	#endif
	                                                             
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( flavor in pcs.challengeStateMap, "Called Challenge_GetCurrentTier for challenge " + ItemFlavor_GetHumanReadableRef( flavor ) + " but it was not assigned to the player " + string(player) )

	                            
	if ( !Challenge_IsAssigned( player, flavor ) )
	{
		                                                                                                                                                                                     
		return 0
	}

	ChallengeState cs = pcs.challengeStateMap[flavor]
	return player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
}
#endif

#if SERVER || CLIENT || UI
bool function Challenge_IsAssigned( entity player, ItemFlavor flavor )
{
	                                                             
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}
#endif


#if SERVER || CLIENT || UI
bool function Challenge_IsComplete( entity player, ItemFlavor flavor )
{
	int currentTier = Challenge_GetCurrentTier( player, flavor )
	int tierCount   = Challenge_GetTierCount( flavor )
	Assert( currentTier <= tierCount, "Player has a higher current tier than should be possible for Challenge "+ItemFlavor_GetHumanReadableRef( flavor ) )
	return (currentTier == tierCount)
}
#endif


#if SERVER || CLIENT || UI
int function Challenge_GetTierCount( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	var settingsBlock = ItemFlavor_GetSettingsBlock( flavor )
	return GetSettingsArraySize( GetSettingsBlockArray( settingsBlock, "tiers" ) )
}
#endif


#if SERVER || CLIENT || UI
int function Challenge_GetTimeSpanKind( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "timeSpan" )
	Assert( key in eChallengeTimeSpanKind, format( "Challenge %s has invalid time span kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeTimeSpanKind[key]
}
#endif


#if SERVER || CLIENT || UI
bool function Challenge_IsSingleMatch( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "matchRequirement" ) == "inSingleMatch"
}
#endif


#if SERVER || CLIENT || UI
bool function Challenge_IsStreak( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "matchRequirement" ) == "requiresStreak"
}
#endif


#if SERVER || CLIENT || UI
array<ItemFlavor> function Challenge_GetCharacterItemFlavors( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierBlock = Challenge_GetTierDataBlock( flavor, tier )

	array<ItemFlavor> characters = []
	var charactersArray          = GetSettingsBlockArray( tierBlock, "characters" )
	foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
	{
		asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
		if ( IsValidItemFlavorSettingsAsset( characterAsset ) )
			characters.append( GetItemFlavorByAsset( characterAsset ) )
	}

	return characters
}
#endif


#if SERVER || CLIENT || UI
int function Challenge_GetGoalVal( ItemFlavor flavor, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	if ( fileLevel.hasPlaylistChallengeOverrides )
	{
                   
		int override = getAlt ? GetCurrentPlaylistVarInt( format( "%s_goal_alt_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 ) :
			GetCurrentPlaylistVarInt( format( "%s_goal_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 )
       
                                                                                                                 
        
		if ( override > -1 )
			return override
	}

	var tierData = Challenge_GetTierDataBlock( flavor, tier )
                  
	if ( getAlt )
		return GetSettingsBlockInt( tierData, "goalValAlt" )
       

	return GetSettingsBlockInt( tierData, "goalVal" )
}
#endif

#if CLIENT || UI
int function Challenge_GetGoalDisplayVal( ItemFlavor flavor, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

                  
	int val = Challenge_GetGoalVal( flavor, tier, getAlt )
      
                                               
       

	var tierData                 = Challenge_GetTierDataBlock( flavor, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}
#endif

#if SERVER || CLIENT || UI
string function Challenge_GetGRXRewardSequenceRef( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "grxRewardSequenceRef" )
}
#endif


#if SERVER || CLIENT || UI
int function Challenge_GetBPStarsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int points = Voucher_GetEffectBattlepassStars( rewardFlav )
		if ( points <= 0 )
			continue

		total += points * rewards.quantities[rewardIdx]
	}
	return total
}
#endif

#if SERVER || CLIENT || UI
int function Challenge_GetBattlepassLevelsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int levels = Voucher_GetEffectBattlepassLevels( rewardFlav )
		if ( levels <= 0 )
			continue

		total += levels * rewards.quantities[rewardIdx]
	}
	return total
}
#endif


#if SERVER || CLIENT || UI
ItemFlavorBag function Challenge_GetRewards( ItemFlavor challengeFlav, int tier )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, tier )

	ItemFlavorBag rewards
	foreach ( int rewardIdx, var rewardData in IterateSettingsArray( GetSettingsBlockArray( tierData, "rewards" ) ) )
	{
		asset rewardAsset = GetSettingsBlockAsset( rewardData, "flavor" )
		if ( !IsValidItemFlavorSettingsAsset( rewardAsset ) )
		{
			Warning( "Skipping item reward #%d of challenge '%s' because the asset is not a valid item flavor: '%s'", rewardIdx, ItemFlavor_GetHumanReadableRef( challengeFlav ), string(rewardAsset) )
			continue
		}

		rewards.flavors.append( GetItemFlavorByAsset( rewardAsset ) )
		rewards.quantities.append( GetSettingsBlockInt( rewardData, "quantity" ) )
	}
	return rewards
}
#endif


#if SERVER || CLIENT || UI
bool function Challenge_LastTierIsInfinite( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "lastTierIsInfinite" )
}
#endif


#if UI
bool function Challenge_IsPinned( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "pinned" )
}
#endif

#if UI
bool function Challenge_ShouldExcludeFromPostMatchSummary( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "excludeFromPostMatchSummary" )
}
#endif


#if SERVER || CLIENT || UI
int function Challenge_GetWeekNumber( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsInt( ItemFlavor_GetAsset( flavor ), "weekNumber" )
}
#endif


#if SERVER || CLIENT || UI
int function Challenge_GetProgressValue( entity player, ItemFlavor challengeFlav, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
	#endif

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( challengeFlav in pcs.challengeStateMap, "Called Challenge_GetActiveTier for challenge " + ItemFlavor_GetHumanReadableRef( challengeFlav ) + " but it was not assigned to the player " + player )

	                            
	if ( !Challenge_IsAssigned( player, challengeFlav ) )
	{
		                                                                                                                                                                                     
		return 0
	}

	ChallengeState cs = pcs.challengeStateMap[challengeFlav]

                  
	int goalVal = Challenge_GetGoalVal( challengeFlav, tier, getAlt )
      
                                                          
       

	int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )

	                                                                                                             
	if ( tier < currentTier )
		return goalVal

	                                                     
	if ( tier > currentTier )
		return 0

	int current            = 0
                  
	array<string> statRefs = Challenge_GetStatRefs( challengeFlav, tier, getAlt )
      
                                                                      
       
	foreach ( string statRef in statRefs )
	{
		Assert( IsValidStatEntryRef( statRef ) )
		StatEntry entry = GetStatEntryByRef( statRef )
		Assert( entry.type == eStatType.INT )
		current += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
	}

                  
	int marker = getAlt ? player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarkerAlt" ) :
		player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )
      
                                                                                                
       

	                   
	  	        

	int progress = current - marker

	if ( progress < 0 )
		return 0

	if ( progress > goalVal )
		return goalVal

	return progress
}
#endif

#if UI
int function GetStarChallengeProgressStartLastMatch( entity player, ItemFlavor activeBattlePass )
{
	if ( player == null )
		player = GetLocalClientPlayer()

	ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )
	Assert( starChallenge != null )
	expect ItemFlavor( starChallenge )

	Assert( ItemFlavor_GetType( starChallenge ) == eItemType.challenge )
	Assert( Challenge_GetTierCount( starChallenge ) == 1, "Recurring BP Recurring Star Challenge should only have a single tier" )

	int tier = 0                              

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( starChallenge in pcs.challengeStateMap, "The BP Recurring Star Challenge was not assigned to the player " + player )
	ChallengeState cs = pcs.challengeStateMap[starChallenge]

	int goalVal = Challenge_GetGoalVal( starChallenge, tier )

	int previous           = 0
	array<string> statRefs = Challenge_GetStatRefs( starChallenge, tier )
	foreach ( string statRef in statRefs )
	{
		Assert( IsValidStatEntryRef( statRef ) )
		StatEntry entry = GetStatEntryByRef( statRef )
		Assert( entry.type == eStatType.INT )
		previous += GetStat_Int( player, entry, eStatGetWhen.START_OF_PREVIOUS_MATCH )
	}

	int marker = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )
	while ( marker > previous )
	{
		                                                                                                           
		marker -= goalVal
	}

	int progress = previous - marker
	Assert( progress >= 0 )

	return progress
}
#endif

#if CLIENT || UI
int function Challenge_GetProgressDisplayValue( entity player, ItemFlavor challengeFlav, int tier )
{
	int val = Challenge_GetProgressValue( player, challengeFlav, tier )

	var tierData                 = Challenge_GetTierDataBlock( challengeFlav, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}
#endif

#if SERVER || CLIENT || UI
ItemFlavor function Challenge_GetSource( ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	return fileLevel.challengeSourceMap[challengeFlav]
}
#endif


#if SERVER || CLIENT || UI
var function Challenge_GetTierDataBlock( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var settingsBlock      = ItemFlavor_GetSettingsBlock( flavor )
	var tierDataBlockArray = GetSettingsBlockArray( settingsBlock, "tiers" )

	return GetSettingsArrayElem( tierDataBlockArray, tier )
}
#endif


#if SERVER || CLIENT || UI
array<string> function Challenge_GetStatRefs( ItemFlavor flavor, int tier, bool getAlt = false )
{
	array<string> statRefs  = []

	if ( ItemFlavor_ChallengesHaveMetaData() )
	{
		Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

		table<string, string> metaData = ItemFlavor_GetMetaData( flavor )
		int tierCount = int(metaData[ CHALLENGE_TIER_COUNT ])

		Assert( tier >= 0 && tier < tierCount )

		int statCount = int(metaData[ format( CHALLENGE_TIER_STAT_COUNT, tier ) ])

		for ( int i = 0; i < statCount; i++ )
		{
                    
			if ( getAlt )
				statRefs.append( metaData[ format( CHALLENGE_TIER_STAT_ALT_REF, tier, i ) ] )
			else
         
				statRefs.append( metaData[ format( CHALLENGE_TIER_STAT_REF, tier, i ) ] )
		}
	}
	else
	{
		Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
		Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

		var tierData = Challenge_GetTierDataBlock( flavor, tier )

                   
		string specifiedStatRef = getAlt ? GetSettingsBlockString( tierData, "statRefAlt" ) : GetSettingsBlockString( tierData, "statRef" )
       
                                                                         
        

		if ( specifiedStatRef.find( "%char%" ) > -1 )
		{
			array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( flavor, tier )
			Assert( characterFlavors.len() > 0, format( "Challenge %s tier %i uses char stat ref but doesn't have a character flavor associated with it", ItemFlavor_GetHumanReadableRef( flavor ), tier ) )
			foreach ( ItemFlavor character in characterFlavors )
			{
				statRefs.append( StringReplace( specifiedStatRef, "%char%", ItemFlavor_GetGUIDString( character ) ) )
			}
		}
		else
		{
			statRefs.append( specifiedStatRef )
		}
	}

	return statRefs
}
#endif

#if SERVER || CLIENT || UI
int function Challenge_GetDifficulty( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "difficulty" )
	Assert( key in eChallegeDifficulty, format( "Challenge %s has invalid difficulty kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallegeDifficulty[key]
}
#endif

#if SERVER || CLIENT || UI
int function Challenge_GetGameMode( ItemFlavor flavor, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

                  
	string key = getAlt ? GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "modeAlt" ) :
		GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "mode" )
      
                                                                              
       

	Assert( key in eChallengeGameMode, format( "Challenge %s has invalid mode kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeGameMode[key]
}
#endif

#if SERVER || CLIENT || UI
string function Challenge_GetGameModeTag( int key )
{
	if ( key in GAME_MODE_TAG )
		return GAME_MODE_TAG[ key ]

	return ""
}
#endif

#if SERVER || CLIENT || UI
vector function Challenge_GetGameModeTagColor( int key )
{
	if ( key in GAME_MODE_TAG_COLOR )
		return GAME_MODE_TAG_COLOR[ key ]

	return < 0, 0, 0 >
}
#endif

#if SERVER || CLIENT || UI
bool function Challenge_ShouldStartAtZero( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "startAtZero"
}
#endif


#if SERVER || CLIENT || UI
bool function Challenge_ShouldAddProgressFromPrevTier( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "addProgressFromPrevTier"
}
#endif


#if SERVER || CLIENT || UI
bool function Challenge_IsPremium( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isPremium" )
}
#endif

                 
#if SERVER || CLIENT || UI
bool function Challenge_IsEitherOr( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isEitherOr" )
}
#endif
      


#if UI
ChallengeGroupData function CreateChallengeGroup( entity player, string nameString, array<ItemFlavor> challenges, int timeSpanKind )
{
	ChallengeGroupData group
	group.groupName  = nameString
	group.challenges = challenges
	if ( player != null )
		group.completedChallenges = GetCompletedChallengeCount( player, challenges )
	group.timeSpanKind = timeSpanKind
	return group
}
#endif


#if SERVER || CLIENT || UI
int function GetCompletedChallengeCount( entity player, array<ItemFlavor> challenges )
{
	int count = 0

	foreach ( ItemFlavor challenge in challenges )
	{
		int maxTier = Challenge_GetTierCount( challenge ) - 1
		Assert( maxTier >= 0 )

		                                                                                                                       
		if ( maxTier < 0 )
			continue

                   
		if ( IsChallengeTierComplete( player, challenge, maxTier ) || ( Challenge_IsEitherOr( challenge ) && IsChallengeTierComplete( player, challenge, maxTier, true ) ) )
       
                                                              
        
			count++
	}

	return count
}
#endif


#if SERVER
                                                          
 
	                
	 
		                                                                                       
	 
	    
	 
		                                         
	 
 

                                                                                    
                                                       
 
	                                         
	                                            
	                               

	        

	                                                                                       
 
#endif


void function ChallengeDbg( entity player, string label, ... )
{
	table stackInfos = expect table(getstackinfos( 2 ))
	string str       = format( "[ChallengeDbg %s %s %s %d %s] %s",
		expect string(stackInfos.src),
		SERVER ? "SV" : CLIENT ? "CL" : UI ? "UI" : "??",
		expect string(stackInfos.func),
		expect int(stackInfos.line),
		string(player),
		label
	)
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
	{
		if ( argIdx > 0 )
			str += "; "

		string key = expect string(vargv[argIdx + 0])
		var val    = vargv[argIdx + 1]
		str += key
		str += "= "
		str += string(val)
	}
	str += "\n"
	print( str )
	SpamLog( str )
}

bool function IsEventCategory( int challengeCategory )
{
	switch ( challengeCategory )
	{
		case eChallengeCategory.EVENT_00:
		case eChallengeCategory.EVENT_01:
		case eChallengeCategory.EVENT_02:
		case eChallengeCategory.EVENT_03:
			return true
	}

	return false
}

bool function IsStoryCategory( int challengeCategory )
{
	switch ( challengeCategory )
	{
		case eChallengeCategory.STORY_00:
		case eChallengeCategory.STORY_01:
		case eChallengeCategory.STORY_02:
		case eChallengeCategory.STORY_03:
			return true
	}

	return false
}

ItemFlavor ornull function GetActiveBuffetEventForCategory( int t, int currCat )
{
	return GetActiveBuffetEventForIndex( t, currCat - eChallengeCategory.EVENT_00 )
}

ItemFlavor ornull function GetActiveStoryEventForCategory( int t, int currCat )
{
	return GetActiveStoryEventForIndex( t, currCat - eChallengeCategory.STORY_00 )
}

void function RefreshCachedSeasonInfo()
{
	fileLevel.currentSeason.calEventOrNull = GetActiveSeason( GetUnixTimestamp() )
	fileLevel.currentSeason.battlePassOrNull = GetActiveBattlePass()
	if ( fileLevel.currentSeason.calEventOrNull != null )
		fileLevel.currentSeason.expirationTimestamp = CalEvent_GetFinishUnixTime( expect ItemFlavor( fileLevel.currentSeason.calEventOrNull ) )
}

                 
                                 
#if SERVER || CLIENT || UI
array<int> function Challenge_EitherOr_GetGoalVals( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> goalVals = [ 0, 0 ]

	goalVals[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetGoalVal( flavor, 0 )
	goalVals[ ALT_CHALLENGE_INDEX ] = Challenge_GetGoalVal( flavor, 0, true )

	return goalVals
}
#endif

#if SERVER || CLIENT || UI
array<int> function Challenge_EitherOr_GetProgressValues( entity player, ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> progressValues = [ 0, 0 ]

	progressValues[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetProgressValue( player, flavor, 0 )
	progressValues[ ALT_CHALLENGE_INDEX ] = Challenge_GetProgressValue( player, flavor, 0, true )

	return progressValues
}
#endif

#if SERVER || CLIENT || UI
array< array<string> > function Challenge_EitherOr_GetStatRefs( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )
	array<string> empty = []
	array< array<string> > statRefs = [ empty, empty ]

	statRefs[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetStatRefs( flavor, 0 )
	statRefs[ ALT_CHALLENGE_INDEX ] = Challenge_GetStatRefs( flavor, 0, true )

	return statRefs
}
#endif

#if SERVER || CLIENT || UI
array<int> function Challenge_EitherOr_GetGameModes( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> gameModes = [ 0, 0 ]

	gameModes[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetGameMode( flavor )
	gameModes[ ALT_CHALLENGE_INDEX ] = Challenge_GetGameMode( flavor, true )

	return gameModes
}
#endif

#if CLIENT || UI
array<string> function Challenge_EitherOr_GetDescriptions( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<string> descriptions = [ "", "" ]

	descriptions[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetDescription( flavor, 0 )
	descriptions[ ALT_CHALLENGE_INDEX ] = Challenge_GetDescription( flavor, 0, true )

	return descriptions
}
#endif
      