  

#if SERVER
                                    
#endif


#if CLIENT
global function CLLootBoxCeremony_Init
global function UIToClient_LootCeremony_SetMenuHandles
global function UIToClient_EnterLootCeremony
global function UIToClient_AdditionalLootTick_Sequence
global function UIToClient_LootCeremonyExit
global function UIToClient_RewardPlacard_Hover
global function UIToClient_RewardInspectActivate
global function UIToClient_RewardInspectNavBack
global function UIToClient_TrackButtonOnClick
global function UIToClient_RewardEquipOnClick
global function UIToClient_RewardEquipOnClickWithIndex
global function UIToClient_RewardEquipToWheelOnClick
global function UIToClient_RewardEquipToWheelOnClickWithIndex
global function UIToClient_OnGRXPackOpeningResultsAvailable
global function UIToClient_SkipAnimation

global function UIToClient_SpecialItemPresentation
global function UIToClient_SpecialItemPresentationExit

global function IsLootCeremonyActive
global function IsSpecialItemPresentationModeActive

global function GetLootCeremonyFlashType
#endif


#if CLIENT && DEV
global function DEV_ShouldShowCustomLootRewards
global function DEV_SetCustomLootRewardsToDisplay
#endif


#if UI
global function InitLootBoxMenu
global function OnLobbyOpenLootBoxMenu_ButtonPress

global function ClientToUI_UpdateSpecialItemPresentationPurchaseButton
global function ClientToUI_EquipButtonShowDialog
global function ClientToUI_EquipToWheelButtonShowDialog
global function ClientToUI_SetLootHasBeenPresented
global function ClientToUI_UpdateStoreButtonVisibility
global function ClientToUI_SetInspectModeIsActive
global function ClientToUI_ClearInspectModeIsActive
global function ClientToUI_PlayLootCeremonySound
global function ClientToUI_StopLootCeremonySound
global function ClientToUI_LootCeremonyMarkItemAsNoLongerNew
global function ClientToUI_TrackMythicChallenge

global function LootCeremony_UpdateOpenAdditionalButton

global function InspectItemTypePresentationSupported
global function SetStoreItemPresentationModeActive
global function SetBattlePassItemPresentationModeActive
global function SetTreasurePackItemPresentationModeActive
global function SetGenericItemPresentationModeActiveWithNavBack
global function SetCollectionEventItemPresentationModeActive
global function SetChallengeRewardPresentationModeActive
global function GetNextLootBox
#endif

#if (CLIENT || UI)
global function IsItemEquipped
global function GetCurrentlyEquippedItemNameForItemTypeSlot
global function GetCurrentlyEquippedItemRarityForItemTypeSlot
global function EquipButton_GetItemLoadoutEntries
#endif

#if SERVER || CLIENT
const float CAMERA_FOV = 35.5

const asset TICK_MODEL_DEFAULT = $"mdl/robots/drone_frag/drone_frag_loot.rmdl"
const asset TICK_FX_HOLO_BEAM_BASE = $"P_loot_triad_beam"
const asset TICK_FX_HOLO_BEAM_TIER1 = $"P_loot_triad_beam_reveal_T1"
const asset TICK_FX_HOLO_BEAM_TIER2 = $"P_loot_triad_beam_reveal_T2"
const asset TICK_FX_HOLO_BEAM_TIER3 = $"P_loot_triad_beam_reveal_T3"
const asset TICK_FX_HOLO_BEAM_TIER4 = $"P_loot_triad_beam_reveal_T4"
const asset TICK_FX_HOLO_BEAM_TIER5 = $"P_loot_triad_beam_reveal_T4"
const asset TICK_FX_RARITY_IDLE = $"P_loot_tick_beam_idle_flash"
const asset TICK_FX_RARITY_BEAM_TIER1 = $"P_loot_tick_rarity_beam_T1"
const asset TICK_FX_RARITY_BEAM_TIER2 = $"P_loot_tick_rarity_beam_T2"
const asset TICK_FX_RARITY_BEAM_TIER3 = $"P_loot_tick_rarity_beam_T3"
const asset TICK_FX_RARITY_BEAM_TIER4 = $"P_loot_tick_rarity_beam_T4"
const asset TICK_FX_RARITY_BEAM_TIER5 = $"P_loot_tick_rarity_beam_T4"
const asset TICK_FX_RARITY_FLASH_TIER1 = $"P_loot_tick_rarity_body_T1"
const asset TICK_FX_RARITY_FLASH_TIER2 = $"P_loot_tick_rarity_body_T2"
const asset TICK_FX_RARITY_FLASH_TIER3 = $"P_loot_tick_rarity_body_T3"
const asset TICK_FX_RARITY_FLASH_TIER4 = $"P_loot_tick_rarity_body_T4"
const asset TICK_FX_RARITY_FLASH_TIER5 = $"P_loot_tick_rarity_body_T4"
const asset TICK_FX_HEAD_CHARGE = $"P_loot_tick_head_charge"
const asset TICK_FX_JUMP_JET = $"P_loot_tick_jump_jet"
const string ATTACHNAME_LEFT = "FX_L_EYE"
const string ATTACHNAME_CENTER = "FX_R_EYE"                                                           
const string ATTACHNAME_RIGHT = "FX_C_EYE"          
const array<string> TICK_LOOT_ATTACHMENTS = [ ATTACHNAME_LEFT, ATTACHNAME_CENTER, ATTACHNAME_RIGHT ]
const array<string> INSPECT_BUTTONS = [ "RewardLeftButton", "RewardCenterButton", "RewardRightButton" ]

global const asset CURRENCY_MODEL_COMMON = $"mdl/currency/crafting/currency_crafting_common.rmdl"
global const asset CURRENCY_MODEL_RARE = $"mdl/currency/crafting/currency_crafting_rare.rmdl"
global const asset CURRENCY_MODEL_EPIC = $"mdl/currency/crafting/currency_crafting_epic.rmdl"
global const asset CURRENCY_MODEL_LEGENDARY = $"mdl/currency/crafting/currency_crafting_legendary.rmdl"
const asset QUIP_BG_MODEL = $"mdl/menu/loot_ceremony_quip_bg.rmdl"
const asset STAT_TRACKER_BG_MODEL = $"mdl/menu/loot_ceremony_stat_tracker_bg.rmdl"
const asset LOADSCREEN_BG_MODEL = $"mdl/menu/generic_1920_1080_bg.rmdl"

const asset FINISHER_SWAP_FX = $"P_menu_finisher_swap"

const string SOUND_DEPLOY_ZOOM = "LootCeremony_Tick_Deploy_Zoom"
const string SOUND_LIGHT_FLASH = "LootCeremony_Tick_LightFlash"
const string SOUND_BEAM_SWEETEN_TIER1 = "LootCeremony_Tick_Deploy_BeamSweetener_Rare"
const string SOUND_BEAM_SWEETEN_TIER2 = "LootCeremony_Tick_Deploy_BeamSweetener_Epic"
const string SOUND_BEAM_SWEETEN_TIER3 = "LootCeremony_Tick_Deploy_BeamSweetener_Legendary"
const string SOUND_BEAM_SWEETEN_TIER4 = "LootCeremony_Tick_Deploy_BeamSweetener_Heirloom"
const string SOUND_HOLOGRAM_FIRST_APPEAR = "LootCeremony_LootHologram_FirstAppear"
const string SOUND_HOLOGRAM_LOOP = "LootCeremony_Inspect_HologramLoop"
const string SOUND_HOLOGRAM_APPEAR_TIER0 = "LootCeremony_LootHologram_Appear_Common"
const string SOUND_HOLOGRAM_APPEAR_TIER1 = "LootCeremony_LootHologram_Appear_Rare"
const string SOUND_HOLOGRAM_APPEAR_TIER2 = "LootCeremony_LootHologram_Appear_Epic"
const string SOUND_HOLOGRAM_APPEAR_TIER3 = "LootCeremony_LootHologram_Appear_Legendary"
const string SOUND_HOLOGRAM_APPEAR_TIER4 = "LootCeremony_LootHologram_Appear_Heirloom"
const string SOUND_INSPECT_ZOOM_IN = "LootCeremony_Inspect_ZoomIn"
const string SOUND_INSPECT_ZOOM_OUT = "LootCeremony_Inspect_ZoomOut"
const string SOUND_EQUIP = "UI_Menu_Equip_Generic"
const string SOUND_HOLOGRAM_PREAPPEAR_TIER3 = "LootCeremony_LootHologram_PreAppear_Legendary"
const string SOUND_HOLOGRAM_PREAPPEAR_TIER4 = "LootCeremony_LootHologram_PreAppear_Legendary"
const string SOUND_HOLOGRAM_APPEAR_RESETVIEW = "LootCeremony_LootHologram_Appear_ResetView"

const int FINAL_TIER = 3
#endif


#if CLIENT
struct ItemPresentationData
{
	ItemFlavor& item
	int         quantity = 1
	string      attachment
	int         rarity
}
#endif


#if CLIENT
struct DummyInspectButtonData
{
	var  button
	bool shouldShow
}
#endif


#if CLIENT
struct GladiatorCardData
{
	NestedGladiatorCardHandle& handle
	var                        rui
	var                        topo = null
}
#endif


#if UI
struct FileForeverStruct
{
	table signalDummy

	var menu
	var inspectMenu
	var equipButton
	var equipToWheelButton
	var purchaseButton
	var trackChallengeButton
	var mouseClickElem
	var inspectVideoPanel
	var storeButton
	var lootBoxOpenButton
	var inspectRewardButton1
	var inspectRewardButton2
	var inspectRewardButton3
	var skipAnimButton
	var blackFlash
}
FileForeverStruct& fileForever
#endif


enum eCeremonyPresentationMode
{
	APEX_PACK,
	STORE_ITEM,
	BATTLE_PASS,
}


struct FileLevelStruct
{
	#if SERVER
	#endif

	#if CLIENT
		table  signalDummy

		var                           menu
		var                           inspectMenu
		var                           equipButton
		var							  trackChallengeButton
		var                           equipToWheelButton
		var                           purchaseButton
		ItemFlavor&                   equipButtonItemFlavor
		ItemFlavor& 				  trackButtonItemFlavor
		var                           mouseClickElem
		var                           inspectVideoPanel
		array<DummyInspectButtonData> dummyInspectButtons
		var                           skipAnimButton
		bool                          menuActive = false
		bool                          inspectMenuIsNavigatingBack = false

		entity lootTickMover
		entity lootTickModel
		entity cameraMover
		entity cameraEnt

		table<string, var>            rewardPlacards = { RewardLeftButton = null, RewardCenterButton = null, RewardRightButton = null }
		array<entity>				  characterSkinModels
		bool						  inspectModeActive

		array< ItemPresentationData > itemPresentationDatas

		bool specialItemPresentationModeActive = false

		int presentationMode = eCeremonyPresentationMode.APEX_PACK

		      
		ItemFlavor& currentPackFlav
		bool        grxRewardsReceived = false

		     
		array<int> rarityBeamFXHandles
		bool       tickRandomFlashFXStarted = false

		array<PakHandle> pakHandles
	#endif

	#if CLIENT && DEV
		bool           debugShowCustomRewards = false
		array< asset > debugCustomRewardAssets = [
			$"settings/itemflav/character_skin/wraith/legendary_01.rpak",
			$"settings/itemflav/gcard_stance/wraith/epic_05.rpak",
			$"settings/itemflav/weapon_skin/hemlok/rare_04.rpak"
		]
	#endif

	#if UI
		bool						heirloomShards = false

		ItemFlavor ornull       	forceParticularPackFlav = null
		bool                    	lootHasBeenPresented = false
		bool                    	considerFocusOpenButton = false
		bool                    	inspectModeActive = false
		bool                    	specialItemPresentationModeActive = false
		GRXScriptOffer ornull   	storeItemPresentationModeOffer
		ItemFlavor&             	specialItemPresentationModeItemFlav
		int                     	specialItemPresentationModeItemQty
		int                     	specialItemPresentationModeItemBadgeTier
		ItemFlavor ornull       	storeItemPresentationModeItemPrereq = null
		string                  	specialItemFormattedPrice = ""
		bool ornull             	specialItemOverrideOwned = null
		bool                    	specialItemHideEquipButton = false
		bool                    	specialItemHidePurchaseButton = false
		string                  	specialItemPriceHeader = ""
		bool                    	specialItemLockPurchaseButton = false
		string ornull           	specialItemPackName = null
		asset ornull            	specialItemPackImg = null
		PurchaseDialogConfig ornull	specialPurchaseDialogConfig = null
		void functionref()			onNavigatingBackFunc = null
	#endif
}
FileLevelStruct& fileLevel

                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                                           
                                                                                        
                                                                                        
                                                                                        
                                                                                        
                                                                                        
                                                                                        
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if SERVER
                                    
 
	                                   
	                                                                                                  
		                                                
		                     
			                        
	   

	                                      
	                                    
	                                    
	                                         
	                              
	                                      
	                                    

	                                                
	                                                 
	                                                 
	                                                 
	                                                 
	                                                 
	                                             
	                                                   
	                                                   
	                                                   
	                                                   
	                                                   
	                                                    
	                                                    
	                                                    
	                                                    
	                                                    
	                                             
	                                          
	                                          
 
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                                    
                                                                                 
                                                                                 
                                                                                 
                                                                                 
                                                                                 
                                                                                 
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if CLIENT
void function CLLootBoxCeremony_Init()
{
	RegisterSignal( "LootCeremonyExit" )
	RegisterSignal( "LootCeremonyAnimSeqStart" )
	RegisterSignal( "LootCeremonyInspectModeStart" )
	RegisterSignal( "LootCeremonyInspectModeStartComplete" )
	RegisterSignal( "LootCeremonyInspectModeEnd" )
	RegisterSignal( "LootCeremonyInspectModeEndComplete" )
	RegisterSignal( "LootCeremonyInspectCompleteOrBackout" )
	RegisterSignal( "LootCeremonyInspectTimeCompleteOrBackout" )
	RegisterSignal( "LootCeremonyInspectVideoCompleteOrBackout" )
	RegisterSignal( "LootCeremonyTimeComplete" )
	RegisterSignal( "LootCeremonyVideoComplete" )
	RegisterSignal( "TickAnimStartDisplayLoot" )
	RegisterSignal( "TickAnimStartDeployment" )
	RegisterSignal( "TickAnimSkip" )
	RegisterSignal( "LootCeremonyAnimShowLootOrSkip" )
	RegisterSignal( "LootCeremonyTickCancelAnim" )

	LootCeremonyLightingRigPreCache()

	AddCallback_FullUpdate( LootCeremonyOnFullUpdate )
	AddCallback_EntitiesDidLoad( EntitiesDidLoad )

	AddGlobalAnimEventTokenize( "loot_tick_rarity_random_flash_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_beam_start_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_beam_stop_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_flash_start_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_play_sound", OnLootTickAnimEvent )
}
#endif


#if CLIENT
void function EntitiesDidLoad()
{
	entity targetAnimRef = GetEntByScriptName( "target_loot_ceremony_ref" )
	fileLevel.lootTickMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", targetAnimRef.GetOrigin(), targetAnimRef.GetAngles() )
	fileLevel.lootTickModel = CreatePropDynamic( TICK_MODEL_DEFAULT, fileLevel.lootTickMover.GetOrigin(), fileLevel.lootTickMover.GetAngles() )

	                                                                                  
	table< string, table< string, vector > > tickAttachmentOriginsAngles
	Attachment camResult = fileLevel.lootTickModel.Anim_GetAttachmentAtTime( "loot_ceremony_tick_triads_idle", "CAMERA", 0 )
	foreach ( string attachment in TICK_LOOT_ATTACHMENTS )
	{
		tickAttachmentOriginsAngles[attachment] <- {}

		Attachment attachResult = fileLevel.lootTickModel.Anim_GetAttachmentAtTime( "loot_ceremony_tick_triads_idle", attachment, 0 )
		vector pos              = attachResult.position
		vector angles           = VectorToAngles( FlattenVec( camResult.position - pos ) )

		tickAttachmentOriginsAngles[ attachment ]["origin"] <- pos
		tickAttachmentOriginsAngles[ attachment ]["angles"] <- angles
	}
	InitLootCeremonyLightingRigs( tickAttachmentOriginsAngles )


	fileLevel.lootTickModel.SetParent( fileLevel.lootTickMover )
	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal_idle", fileLevel.lootTickMover )
	HideEntityAndChildren( fileLevel.lootTickModel )

	fileLevel.cameraMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", targetAnimRef.GetOrigin(), targetAnimRef.GetAngles() )
	fileLevel.cameraEnt = CreateClientSidePointCamera( targetAnimRef.GetOrigin(), targetAnimRef.GetAngles(), CAMERA_FOV )
	fileLevel.cameraEnt.SetParent( fileLevel.cameraMover, "REF" )
	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
}
#endif


#if CLIENT
void function UIToClient_LootCeremony_SetMenuHandles( var menu )
{
	fileLevel.menu = menu
	fileLevel.inspectMenu = Hud_GetChild( menu, "InspectBar" )
	fileLevel.equipButton = Hud_GetChild( menu, "InspectEquipButton" )
	fileLevel.trackChallengeButton = Hud_GetChild( menu, "TrackChallengeButton" )
	fileLevel.equipToWheelButton = Hud_GetChild( menu, "InspectEquipToWheelButton" )
	fileLevel.mouseClickElem = Hud_GetChild( menu, "ModelRotateMouseCapture" )
	fileLevel.inspectVideoPanel = Hud_GetChild( menu, "InspectVideoPanel" )

	fileLevel.dummyInspectButtons.clear()

	DummyInspectButtonData inspectButton1
	inspectButton1.button = Hud_GetChild( menu, "RewardLeftButton" )
	inspectButton1.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton1 )

	DummyInspectButtonData inspectButton2
	inspectButton2.button = Hud_GetChild( menu, "RewardCenterButton" )
	inspectButton2.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton2 )

	DummyInspectButtonData inspectButton3
	inspectButton3.button = Hud_GetChild( menu, "RewardRightButton" )
	inspectButton3.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton3 )

	fileLevel.skipAnimButton = Hud_GetChild( menu, "SkipAnimationButton" )
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                                      
                                                                                     
                                                                                    
                                                                                   
                                                                                    
                                                                                     
                                                                                      
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if CLIENT
void function UIToClient_OnGRXPackOpeningResultsAvailable()
{
	                                  
	if ( !IsLootCeremonyActive() )
		return

	ItemFlavorBag bag = GRX_GetMostRecentPackOpeningResults()

	                 
	int error = GRX_INVENTORYERROR_NONE
	if ( bag.associatedError != -1 )
		error = bag.associatedError
	GRXPackOpened_ErrorHandling( error )

	                              
	#if DEV
		if ( fileLevel.debugShowCustomRewards )
		{
			array< ItemFlavor > debugItems
			foreach ( asset itemAsset in fileLevel.debugCustomRewardAssets )
				debugItems.append( GetItemFlavorByAsset( itemAsset ) )

			bag.flavors = debugItems
		}
	#endif

	fileLevel.itemPresentationDatas.clear()

	bool hasCurrency                      = false
	bool hasNonCurrency                   = false
	table<ItemFlavor, int> currencyCounts = {}
	foreach ( int bagEntryIdx, ItemFlavor bagEntryFlav in bag.flavors )
	{
		if ( ItemFlavor_GetType( bagEntryFlav ) == eItemType.account_currency )
		{
			hasCurrency = true
			if ( !(bagEntryFlav in currencyCounts) )
				currencyCounts[bagEntryFlav] <- 0
			currencyCounts[bagEntryFlav] += bag.quantities[bagEntryIdx]
		}
		else
		{
			hasNonCurrency = true
		}
	}

	bool hasJustCurrency = hasCurrency && hasNonCurrency == false && currencyCounts.len() == 1
	if ( hasJustCurrency )
	{
		                                                                              
		                                                                               
		                                                                                                        
		   

		ItemFlavor currencyFlav
		int currencyQty
		foreach ( ItemFlavor flav, int qty in currencyCounts )
		{ ; currencyFlav = flav; currencyQty = qty; break; }

		int middleQty = 0
		int leftQty   = 0
		int rightQty  = 0
		if ( currencyQty % 3 == 0 )
		{
			                                           
			middleQty = currencyQty / 3
			leftQty   = middleQty
			rightQty  = middleQty
		}
		else if ( ( currencyQty - 100 ) % 3 == 0 )
		{
			                                                               
			middleQty = ( currencyQty - 100 ) / 3 + 100
			leftQty   = ( currencyQty - 100 ) / 3
			rightQty  = leftQty
		}
		else
		{
			                                                            
			                                                                             
			middleQty = currencyQty / 3
			leftQty   = middleQty
			rightQty  = middleQty
		}
		                                                                                             
		middleQty += currencyQty - middleQty - leftQty - rightQty

		ItemPresentationData wtfLeft
		wtfLeft.item = currencyFlav
		wtfLeft.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfLeft.attachment = TICK_LOOT_ATTACHMENTS[0]
		wtfLeft.quantity = leftQty
		fileLevel.itemPresentationDatas.append( wtfLeft )

		ItemPresentationData wtfMiddle
		wtfMiddle.item = currencyFlav
		wtfMiddle.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfMiddle.attachment = TICK_LOOT_ATTACHMENTS[1]
		wtfMiddle.quantity = middleQty
		fileLevel.itemPresentationDatas.append( wtfMiddle )

		ItemPresentationData wtfRight
		wtfRight.item = currencyFlav
		wtfRight.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfRight.attachment = TICK_LOOT_ATTACHMENTS[2]
		wtfRight.quantity = rightQty
		fileLevel.itemPresentationDatas.append( wtfRight )
	}
	else if ( GRXPack_IsExpectedToContainSingleItemWithCurrency( fileLevel.currentPackFlav ) )
	{
		ItemFlavor ornull theSingleItemFlav = null
		ItemFlavor ornull theCurrencyFlav   = null
		int theCurrencyQty                  = 0
		foreach ( int bagEntryIdx, ItemFlavor bagEntryFlav in bag.flavors )
		{
			int bagEntryQty = bag.quantities[bagEntryIdx]
			if ( ItemFlavor_GetType( bagEntryFlav ) == eItemType.account_currency )
			{
				Assert( theCurrencyFlav == null || theCurrencyFlav == bagEntryFlav )
				theCurrencyFlav = bagEntryFlav
				theCurrencyQty += bagEntryQty
			}
			else
			{
				                                                                    
				                                                                               
				Assert( ItemFlavor_GetType( bagEntryFlav ) == eItemType.character_skin
				|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.weapon_skin
				|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.gladiator_card_stance
				|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.music_pack )

				                                                
				Assert( theSingleItemFlav == null )
				theSingleItemFlav = bagEntryFlav
			}
		}

		Assert( theSingleItemFlav != null )
		Assert( theCurrencyFlav != null )
		Assert( theCurrencyQty > 0 )

		if ( !IsEven( theCurrencyQty ) )
			Warning( "Pack %s gave an odd amount of currency but we expected an even amount: %d", ItemFlavor_GetHumanReadableRef( fileLevel.currentPackFlav ), theCurrencyQty )

		int leftCurrencyAmount  = theCurrencyQty / 2
		int rightCurrencyAmount = theCurrencyQty - leftCurrencyAmount

		ItemPresentationData leftCurrencyIPD
		leftCurrencyIPD.item = expect ItemFlavor(theCurrencyFlav)
		leftCurrencyIPD.rarity = ItemFlavor_GetQuality( leftCurrencyIPD.item )
		leftCurrencyIPD.attachment = TICK_LOOT_ATTACHMENTS[0]
		leftCurrencyIPD.quantity = leftCurrencyAmount
		fileLevel.itemPresentationDatas.append( leftCurrencyIPD )

		ItemPresentationData theSingleItemIPD
		theSingleItemIPD.item = expect ItemFlavor(theSingleItemFlav)
		theSingleItemIPD.rarity = ItemFlavor_GetQuality( theSingleItemIPD.item )
		theSingleItemIPD.attachment = TICK_LOOT_ATTACHMENTS[1]
		fileLevel.itemPresentationDatas.append( theSingleItemIPD )

		ItemPresentationData rightCurrencyIPD
		rightCurrencyIPD.item = expect ItemFlavor(theCurrencyFlav)
		rightCurrencyIPD.rarity = ItemFlavor_GetQuality( rightCurrencyIPD.item )
		rightCurrencyIPD.attachment = TICK_LOOT_ATTACHMENTS[2]
		rightCurrencyIPD.quantity = rightCurrencyAmount
		fileLevel.itemPresentationDatas.append( rightCurrencyIPD )
	}
	else if ( bag.flavors.len() == 1 && Mythics_IsItemFlavorMythicSkin( bag.flavors[0] ) )
	{
		array<ItemFlavor> mythicSkins = Mythics_GetAllSkinsFromBase( bag.flavors[0] )

		Assert( FINAL_TIER == mythicSkins.len() )

		                                                                                         
		Remote_ServerCallFunction( "ClientCallback_UpdateMythicChallenges" )

		for ( int i = 0; i < mythicSkins.len(); i++ )
		{
			int attachmentIndex = i

			if ( i == 0 )
				attachmentIndex = 1
			else if ( i == 1 )
				attachmentIndex = 0

			ItemPresentationData data
			data.item = mythicSkins[i]
			data.rarity = eRarityTier.HEIRLOOM                                                             
			data.attachment = TICK_LOOT_ATTACHMENTS[ attachmentIndex ]

			fileLevel.itemPresentationDatas.append( data )
		}
	}
	else
	{
		for ( int i = 0; i < bag.quantities.len(); i++ )
			Assert( bag.quantities[i] == 1, "Quantity is not 1 for loot ceremony item flavor: " + ItemFlavor_GetHumanReadableRef( bag.flavors[i] ) )

		array<ItemFlavor> filteredAndSortedItemFlavors = FilterAndSortPackResults( bag.flavors )

		for ( int i = 0; i < filteredAndSortedItemFlavors.len(); i++ )
		{
			ItemFlavor flavor = filteredAndSortedItemFlavors[i]

			ItemPresentationData data
			data.item = flavor
			data.rarity = ItemFlavor_HasQuality( flavor ) ? ItemFlavor_GetQuality( flavor ) : 0
			data.attachment = TICK_LOOT_ATTACHMENTS[i]

			fileLevel.itemPresentationDatas.append( data )
		}
	}

	                              
	fileLevel.grxRewardsReceived = true
}
#endif


#if CLIENT
array<ItemFlavor> function FilterAndSortPackResults( array<ItemFlavor> resultList )
{
	                                                            

	array<ItemFlavor> out = []
	ItemFlavor ornull packTheme = null
	int packThemeType

	                                                                                     
	bool isThematicCharacterPack = false                               
	bool isThematicItemTypePack = false                       
	bool isThematicWeaponCategoryPack = false                

	                                                                        
	foreach ( ItemFlavor result in resultList )
	{
		if ( ItemFlavor_GetType( result ) == eItemType.account_pack )
			continue

		out.append( result )
	}

	out.randomize()

	if ( ItemFlavor_GetAccountPackType( fileLevel.currentPackFlav ) == eAccountPackType.THEMATIC )
	{
		asset themeAsset = GetGlobalSettingsAsset( ItemFlavor_GetAsset( fileLevel.currentPackFlav ), "themeFlavor" )
		if ( IsValidItemFlavorSettingsAsset( themeAsset ) )
		{
			packTheme = GetItemFlavorByAsset( themeAsset )

			if ( ItemFlavor_GetType( expect ItemFlavor( packTheme ) ) == eItemType.character )
			{
				isThematicCharacterPack = true
				packThemeType = eItemType.character
			}
			else if ( ItemFlavor_GetType( expect ItemFlavor( packTheme ) ) == eItemType.weapon_category )
			{
				isThematicWeaponCategoryPack = true
				packThemeType = eItemType.weapon_category
			}
			else
			{
				isThematicItemTypePack = true
				packThemeType = ItemFlavor_GetType( expect ItemFlavor( packTheme ) )                                                                                      
			}
		}
	}

	                                                                                                                 
	out.sort( int function( ItemFlavor a, ItemFlavor b ) : ( isThematicCharacterPack, isThematicItemTypePack, isThematicWeaponCategoryPack, packTheme, packThemeType ) {
		bool aIsMeleeSkin = (ItemFlavor_GetType( a ) == eItemType.melee_skin)
		bool bIsMeleeSkin = (ItemFlavor_GetType( b ) == eItemType.melee_skin)
		if ( aIsMeleeSkin )
			return -1
		if ( bIsMeleeSkin )
			return 1

		if ( ItemFlavor_GetSourceIcon( a ) != $"" )
			return -1

		if ( ItemFlavor_GetSourceIcon( b ) != $"" )
			return 1

		                                                                                                                                  
		if ( isThematicCharacterPack )
		{
			if ( packTheme == GetItemFlavorAssociatedCharacterOrWeapon( a ) && ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
			return -1

			if ( packTheme == GetItemFlavorAssociatedCharacterOrWeapon( b ) && ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
			return 1
		}
		else if ( isThematicWeaponCategoryPack )
		{
			if ( ItemFlavor_GetType( a ) == eItemType.weapon_skin )
			{
				if ( packTheme == WeaponItemFlavor_GetCategory( expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( a ) ) ) && ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
					return -1
			}

			if ( ItemFlavor_GetType( b ) == eItemType.weapon_skin )
			{
				if ( packTheme == WeaponItemFlavor_GetCategory( expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( b ) ) ) && ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
					return 1
			}
		}
		else if ( isThematicItemTypePack )
		{
			if ( packThemeType == ItemFlavor_GetType( a ) && ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
				return -1

			if ( packThemeType == ItemFlavor_GetType( b ) && ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
				return 1
		}

		return 0
	} )

	                                                                  
	bool centerMeleeSkin         = ( out.len() >= 2 && ( ItemFlavor_GetType( out[0] ) == eItemType.melee_skin || ItemFlavor_GetSourceIcon( out[0] ) != $"" ) )
	bool centerCharacterThematic = ( out.len() >= 2 && isThematicCharacterPack && packTheme == GetItemFlavorAssociatedCharacterOrWeapon( out[0] ) && ItemFlavor_GetQuality( out[0] ) >= eRarityTier.RARE )
	bool centerItemTypeThematic  = ( out.len() >= 2 && isThematicItemTypePack && packThemeType == ItemFlavor_GetType( out[0] ) && ItemFlavor_GetQuality( out[0] ) >= eRarityTier.RARE )

	if ( centerMeleeSkin || centerCharacterThematic || centerItemTypeThematic )
	{
		ItemFlavor temp = out[0]
		out[0] = out[1]
		out[1] = temp
	}

	                                             
	if ( out.len() > TICK_LOOT_ATTACHMENTS.len() )
		out.resize( TICK_LOOT_ATTACHMENTS.len() )

	return out
}
#endif


#if CLIENT
bool function BagIsHeirloom( array<ItemFlavor> flavors )
{
	if ( flavors.len() == 0 )
		return false
	if ( !ItemFlavor_HasQuality( flavors[0] ) )
		return false
	if ( ItemFlavor_GetQuality( flavors[0] ) != eRarityTier.HEIRLOOM )
		return false

	return true
}
#endif


#if CLIENT
void function GRXPackOpened_ErrorHandling( int packError )
{
	if ( packError == GRX_INVENTORYERROR_NONE )
		return

	string message
	string warningText

	if ( packError == GRX_INVENTORYERROR_UNKNOWNITEM )
	{
		message = "#GRX_ERROR_MESSAGE_UNKNOWNITEM"
		warningText = "Loot Box had an error: UNKNOWNITEM"
	}
	else if ( packError == GRX_INVENTORYERROR_BACKEND )
	{
		message = "#GRX_ERROR_MESSAGE_BACKEND"
		warningText = "Loot Box had an error: BACKEND"
	}
	else
	{
		message = "#GRX_ERROR_MESSAGE_GENERIC"
		warningText = "Loot Box had an error: " + packError
	}

	RunUIScript( "ShowGRXErrorDialogue", message )

	#if DEV
		Warning( warningText )
	#endif
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                       
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                       
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if CLIENT
void function EnableFakeInspectButtons()
{
	foreach ( DummyInspectButtonData buttonData in fileLevel.dummyInspectButtons )
	{
		if ( buttonData.shouldShow )
		{
			Hud_SetEnabled( buttonData.button, true )
			Hud_SetVisible( buttonData.button, true )
		}
	}
}
#endif


#if CLIENT
void function DisableFakeInspectButtons()
{
	foreach ( DummyInspectButtonData buttonData in fileLevel.dummyInspectButtons )
	{
		Hud_SetEnabled( buttonData.button, false )
		Hud_SetVisible( buttonData.button, false )
	}
}
#endif


#if CLIENT
void function UIToClient_SkipAnimation()
{
	                                                   
}
#endif


#if CLIENT
void function UIToClient_SpecialItemPresentation( SettingsAssetGUID itemFlavorGUID, int itemQty, int badgeDataInteger )
{
	thread UIToClient_SpecialItemPresentation_Threaded( itemFlavorGUID, itemQty, badgeDataInteger )
}
#endif

#if CLIENT
void function UIToClient_SpecialItemPresentation_Threaded( SettingsAssetGUID itemFlavorGUID, int itemQty, int badgeDataInteger )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )

	fileLevel.specialItemPresentationModeActive = true

	                       
	DisableFakeInspectButtons()
	DisableInspectMenu()
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	                                
	LootCeremonySceneLightsUpdateShadows( true )

	if ( !IsValid( fileLevel.cameraMover.GetParent() ) )
		fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

	GetLocalClientPlayer().SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )

	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )

	wait 0.25                     

	                                          
	ItemFlavor item     = GetItemFlavorByGUID( itemFlavorGUID )
	int itemType        = ItemFlavor_GetType( item )
	string attachment   = TICK_LOOT_ATTACHMENTS[1]
	int attachIDEye     = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachIDEye )
	vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )
	int displayIndex    = TICK_LOOT_ATTACHMENTS.find( attachment )

	int rarity = 0
	if ( ItemFlavor_HasQuality( item ) )
		rarity = ItemFlavor_GetQuality( item )

	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	                                                                                        
	fileLevel.itemPresentationDatas.clear()
	ItemPresentationData data
	data.item = item
	data.quantity = itemQty
	                                          
	data.attachment = attachment
	data.rarity = rarity
	fileLevel.itemPresentationDatas.append( data )

	                        
	InspectMenu_ZoomIn( Hud_GetChild( fileLevel.menu, "RewardCenterButton" ), true )

	                  
	thread ShowRewardBasedOnItemType( itemType, item, attachOrigin, attachAngles, rarity, itemQty, badgeDataInteger, displayIndex, attachment )

	        
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_FIRST_APPEAR )
	                                                                        
	RunUIScript( "ClientToUI_UpdateSpecialItemPresentationPurchaseButton" )
	              
	thread ShowRewards_FX( attachIDEye, rarity, rarityColor, displayIndex )

	EnableInspectMenu()
}
#endif


#if CLIENT
void function UIToClient_SpecialItemPresentationExit()
{
	Signal( fileLevel.signalDummy, "LootCeremonyExit" )

	fileLevel.specialItemPresentationModeActive = false

	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	if ( IsValid( GetLocalClientPlayer() ) )
		GetLocalClientPlayer().ClearMenuCameraEntity()

	                                                                        
	ClearInspectMenuDetails()
	LootCeremonySceneLightsUpdateShadows( false )
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if CLIENT
void function UIToClient_EnterLootCeremony( int packFlavGUID )
{
	ItemFlavor packFlav = GetItemFlavorByGUID( packFlavGUID )

	fileLevel.menuActive = true
	LootCeremonySceneLightsUpdateShadows( true )

	Chroma_LootCeremonyStart()

	ShowEntityAndChildren( fileLevel.lootTickModel )
	thread TickAnimationSequence( packFlav, true )
}
#endif


#if CLIENT
void function UIToClient_AdditionalLootTick_Sequence( int packFlavGUID )
{
	ItemFlavor packFlav = GetItemFlavorByGUID( packFlavGUID )

	Chroma_LootCeremonyStart()

	thread TickAnimationSequence( packFlav, false )
}
#endif


#if CLIENT
void function TickAnimationSequence( ItemFlavor packFlav, bool firstTime )
{
	Signal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	           
	fileLevel.currentPackFlav = packFlav
	fileLevel.grxRewardsReceived = false
	DisableFakeInspectButtons()
	DisableInspectMenu()
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	             
	fileLevel.lootTickModel.SetModel( GRXPack_GetTickModel( packFlav ) )
	fileLevel.lootTickModel.SetSkin( fileLevel.lootTickModel.GetSkinIndexByName( GRXPack_GetTickModelSkin( packFlav ) ) )

	string deployAnim = GetTickDeploymentAnim()

	OnThreadEnd(
		function() : ()
		{
			Signal( fileLevel.lootTickModel, "LootCeremonyTickCancelAnim" )

			                                                                        

			if ( !IsLootCeremonyActive() )
			{
				thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal_idle", fileLevel.lootTickMover )
				HideEntityAndChildren( fileLevel.lootTickModel )
			}
			else
			{
				RunUIScript( "PlayCustomUIMusic", "" )
			}
		}
	)

	if ( !IsValid( fileLevel.cameraMover.GetParent() ) )
		fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

	GetLocalClientPlayer().SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )

	if ( firstTime )
		wait 0.25                     

	RunUIScript( "PlayCustomUIMusic", LOOT_CEREMONY_MUSIC_P1 )

	                         
	PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal", fileLevel.lootTickMover )
	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_idle", fileLevel.lootTickMover )

	                                                                                                                     
	wait 0.5

	                                  
	while( !fileLevel.grxRewardsReceived )
		WaitFrame()

	                         
	Hud_SetEnabled( fileLevel.skipAnimButton, true )
	Hud_SetVisible( fileLevel.skipAnimButton, true )

	                           
	Signal( fileLevel.lootTickModel, "TickAnimStartDeployment" )

	        
	RunUIScript( "PlayCustomUIMusic", LOOT_CEREMONY_MUSIC_P2 )
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_DEPLOY_ZOOM )

	                            
	thread PlayAnim( fileLevel.lootTickModel, deployAnim, fileLevel.lootTickMover )
	thread WaitForTickAnimCompleteAndSignalDisplayLoot( fileLevel.lootTickModel, deployAnim )

	                                                                                                          
	bool animReachedDisplayEvent = false
	array<string> signalsToWait  = ["TickAnimStartDisplayLoot", "TickAnimSkip", "LootCeremonyTickCancelAnim"]
	string resultSignal          = GetWaitMultipleSignal_Entity( fileLevel.lootTickModel, signalsToWait, "LootCeremonyAnimShowLootOrSkip" )

	if ( resultSignal == "TickAnimStartDisplayLoot" )
		animReachedDisplayEvent = true

	                                                         
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	                  
	if ( animReachedDisplayEvent )
	{
		thread LootCeremonySequenceShowRewards()
		WaittillAnimDone( fileLevel.lootTickModel )
		thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )
	}
	else
	{
		LootCeremony_RarityBeamFX_Stop( true )
		thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )
		thread LootCeremonySequenceShowRewards()
	}

	WaitForever()
}
#endif


#if CLIENT
string function GetTickDeploymentAnim()
{
	string deployAnim
	int randInt = RandomInt( 100 )

	if ( randInt > 95 )
	{
		                    
		deployAnim = "loot_ceremony_tick_deployment"
	}
	else
	{
		array<string> anims = [ "loot_ceremony_tick_deployment_fast_walk", "loot_ceremony_tick_deployment_hop", "loot_ceremony_tick_deployment_jump", "loot_ceremony_tick_deployment_walk"  ]
		deployAnim = anims.getrandom()
	}

	printt( "Loot Ceremony deployment animation: " + deployAnim )
	return deployAnim
}
#endif


#if CLIENT
void function WaitForTickAnimCompleteAndSignalDisplayLoot( entity tickModel, string tickAnim )
{
	                                                                                                
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	Wait( tickModel.GetSequenceDuration( tickAnim ) )

	Signal( fileLevel.lootTickModel, "TickAnimStartDisplayLoot" )
}
#endif


#if CLIENT
void function UIToClient_LootCeremonyExit()
{
	fileLevel.menuActive = false

	Signal( fileLevel.signalDummy, "LootCeremonyExit" )

	if ( IsValid( GetLocalClientPlayer() ) )
		GetLocalClientPlayer().ClearMenuCameraEntity()

	LootCeremonySceneLightsUpdateShadows( false )

	RunUIScript( "CancelCustomUIMusic" )

	                                      
	LootCeremony_RarityBeamFX_Stop( true )

	Chroma_Lobby()
}
#endif


#if CLIENT
void function LootCeremonyOnFullUpdate()
{
	if ( !IsLootCeremonyActive() && !IsSpecialItemPresentationModeActive() )
		return

	printt( "#################" )
	printf( "%s() ", FUNC_NAME() )
	printt( "#################" )

	entity localClientPlayer = GetLocalClientPlayer()
	if ( IsValid( localClientPlayer ) && IsValid( fileLevel.cameraEnt ) )
		localClientPlayer.SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )
}
#endif


#if CLIENT
bool function IsLootCeremonyActive()
{
	return fileLevel.menuActive
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                      
                     
                    
                   
                    
                     
                      
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if CLIENT
void function OnLootTickAnimEvent( entity ent, array<string> tokens )
{
	switch ( tokens[0] )
	{
		case "loot_tick_rarity_random_flash_fx":
		{
			thread LootCeremony_RandomFlashFX_Thread( ent )
			break
		}

		case "loot_tick_rarity_beam_start_fx":
		{
			LootCeremony_RarityBeamFX( ent, tokens[1] )
			break
		}

		case "loot_tick_rarity_beam_stop_fx":
		{
			LootCeremony_RarityBeamFX_Stop()
			break
		}

		case "loot_tick_rarity_flash_start_fx":
		{
			LootCeremony_RarityFlashFX( ent, tokens[1], tokens[2] )
			break
		}

		case "loot_tick_play_sound":
		{
			LootCeremony_PlayLootTickSound( ent, tokens[1] )
			break
		}

		default: Assert( false )
	}
}
#endif


#if CLIENT
void function LootCeremony_RandomFlashFX_Thread( entity tickModel )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.lootTickModel, "TickAnimStartDeployment" )

	if ( fileLevel.tickRandomFlashFXStarted )
		return

	fileLevel.tickRandomFlashFXStarted = true

	OnThreadEnd(
		function() : ()
		{
			fileLevel.tickRandomFlashFXStarted = false
		}
	)

	int attachID = tickModel.LookupAttachment( "FX_C_EYE" )

	while( true )
	{
		int rarity  = 0
		int randInt = RandomInt( 1000 )

		if ( randInt > 995 )
			rarity = 4
		if ( randInt > 970 )
			rarity = 3
		else if ( randInt > 900 )
			rarity = 2
		else if ( randInt > 600 )
			rarity = 1

		vector rarityColor = GetFXRarityColorForUnlockable( rarity )

		int fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_IDLE ), FX_PATTACH_POINT_FOLLOW, attachID )
		EffectSetControlPointVector( fxIndex, 1, rarityColor )

		RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_LIGHT_FLASH )

		Wait( RandomFloatRange( 0.2, 0.4 ) )
	}
}
#endif


#if CLIENT
void function LootCeremony_RarityBeamFX( entity tickModel, string fxAttachment )
{
	bool attachmentHasItem = false

	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == fxAttachment )
		{
			attachmentHasItem = true
			break
		}
	}

	if ( !attachmentHasItem )
		return

	int rarity         = GetItemRarityFromAttachment( fxAttachment )
	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	Chroma_LootCeremonyBeam( rarity )

	int attachID = tickModel.LookupAttachment( fxAttachment )
	int fxIndex
	switch ( rarity )
	{
		case 0:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER1 ), FX_PATTACH_POINT_FOLLOW, attachID )
			break

		case 1:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER2 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER1 )
			break

		case 2:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER3 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER2 )
			break

		case 3:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER4 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER3 )
			break

		case 4:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER5 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER4 )
			break

		default:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER1 ), FX_PATTACH_POINT_FOLLOW, attachID )
			break
	}

	EffectSetControlPointVector( fxIndex, 1, rarityColor )

	fileLevel.rarityBeamFXHandles.append( fxIndex )
}
#endif


#if CLIENT
void function LootCeremony_RarityBeamFX_Stop( bool stopImmediately = false )
{
	foreach ( int fxID in fileLevel.rarityBeamFXHandles )
	{
		if ( EffectDoesExist( fxID ) )
		{
			if ( stopImmediately )
				EffectStop( fxID, true, false )
			else
				EffectStop( fxID, false, true )
		}
	}

	fileLevel.rarityBeamFXHandles.clear()
}
#endif


#if CLIENT
void function LootCeremony_RarityFlashFX( entity tickModel, string attachmentHead, string attachmentEye )
{
	int rarity         = GetItemRarityFromAttachment( attachmentEye )
	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	int attachID  = tickModel.LookupAttachment( attachmentHead )
	vector origin = tickModel.GetAttachmentOrigin( attachID )
	vector angles = tickModel.GetAttachmentAngles( attachID )

	Chroma_LootCeremonyFlash( rarity )

	int fxIndex
	switch ( rarity )
	{
		case 0:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER1 ), origin, angles )
			break

		case 1:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER2 ), origin, angles )
			break

		case 2:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER3 ), origin, angles )
			break

		case 3:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER4 ), origin, angles )
			break

		default:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER1 ), origin, angles )
			break
	}

	EffectSetControlPointVector( fxIndex, 1, rarityColor )
}
#endif


#if CLIENT
void function LootCeremony_PlayLootTickSound( entity tickModel, string soundKindRef )
{
	string soundAlias = GRXPack_GetTickSoundAlias( fileLevel.currentPackFlav, eGRXPackTickSoundKind[soundKindRef] )
	if ( soundAlias != "" )
		EmitSoundOnEntity( tickModel, soundAlias )
}
#endif


#if CLIENT
int function GetItemRarityFromAttachment( string compareAttachment )
{
	int rarity = 0

	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == compareAttachment )
			return data.rarity
	}

	return rarity
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                       
                                                                        
                                                                  
                                                                       
                                                                        
                                                                        
                                                                       
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


const float REWARDS_DELAY_TIER5 = 1.1
const float REWARDS_DELAY_TIER4 = 1.0
const float REWARDS_DELAY_TIER3 = 0.4
const float REWARDS_DELAY_TIER1 = 0.2


#if CLIENT
void function LootCeremonySequenceShowRewards()
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                  
	bool heirloomShards = false
	for ( int i = 0; i < fileLevel.itemPresentationDatas.len(); i++ )
	{
		ItemPresentationData data = fileLevel.itemPresentationDatas[i]
		ItemFlavor item           = data.item
		int quantity              = data.quantity
		int badgeDataInteger      = -1

		                               
		string attachment   = data.attachment
		int attachIDEye     = fileLevel.lootTickModel.LookupAttachment( attachment )
		vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachIDEye )
		vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

		int displayIndex = TICK_LOOT_ATTACHMENTS.find( attachment )

		              
		int rarity         = data.rarity
		vector rarityColor = GetFXRarityColorForUnlockable( rarity )

		            
		int itemType = ItemFlavor_GetType( item )

		                               
		if ( rarity == 4 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_PREAPPEAR_TIER4 )

			wait REWARDS_DELAY_TIER5
		}
		else if ( rarity == 3 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_PREAPPEAR_TIER3 )

			wait REWARDS_DELAY_TIER4
		}
		else if ( i > 0 )
		{
			if ( rarity == 2 || rarity == 1 )
				wait REWARDS_DELAY_TIER3
			else
				wait REWARDS_DELAY_TIER1
		}


		ShowRewardBasedOnItemType( itemType, item, attachOrigin, attachAngles, rarity, quantity, badgeDataInteger, displayIndex, attachment )

		                     
		thread ShowRewards_Placard( item, attachOrigin, attachAngles, rarity, displayIndex )
		thread ShowRewards_FX( attachIDEye, rarity, rarityColor, displayIndex )

		if ( i == 0 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_FIRST_APPEAR )
			                                                                        
		}

		switch ( rarity )
		{
			case 0:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER0 )
				break

			case 1:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER1 )
				break

			case 2:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER2 )
				break

			case 3:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER3 )
				break

			case 4:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER4 )
				break
		}

		if ( item == GetItemFlavorByAsset( $"settings/itemflav/currency_bundle/heirloom.rpak" ) )
			heirloomShards = true
	}

	                
	RunUIScript( "ClientToUI_SetLootHasBeenPresented", heirloomShards )
	RunUIScript( "ClientToUI_UpdateStoreButtonVisibility" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	thread MythicUpdateAllEffects( true )

	                                      
	for ( int i = 0; i < TICK_LOOT_ATTACHMENTS.len(); i++ )
	{
		if ( i < fileLevel.itemPresentationDatas.len() )
			fileLevel.dummyInspectButtons[i].shouldShow = true
		else
			fileLevel.dummyInspectButtons[i].shouldShow = false
	}
	EnableFakeInspectButtons()
}
#endif


#if CLIENT
void function ShowRewardBasedOnItemType( int itemType, ItemFlavor item, vector attachOrigin, vector attachAngles, int rarity, int quantity, int badgeDataInteger, int displayIndex, string attachment )
{
	switch ( itemType )
	{
		case eItemType.account_currency:
		case eItemType.account_currency_bundle:
			thread ShowRewards_Currency( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.account_pack:
			thread ShowRewards_LootTick( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.character_skin:
			thread ShowRewards_CharacterSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.character_execution:
			thread ShowRewards_Execution( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.emote_icon:
			thread ShowRewards_EmoteIcon( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.weapon_skin:
			thread ShowRewards_WeaponSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.weapon_charm:
			thread ShowRewards_WeaponCharm( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.gladiator_card_stance:
		case eItemType.gladiator_card_frame:
			thread ShowRewards_GladiatorCard( item, itemType, attachOrigin, attachAngles, displayIndex, rarity )
			break

		case eItemType.gladiator_card_intro_quip:
		case eItemType.gladiator_card_kill_quip:
			thread ShowRewards_Quip( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.gladiator_card_stat_tracker:
			thread ShowRewards_StatTracker( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.gladiator_card_badge:
			thread ShowRewards_Badge( item, badgeDataInteger, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.melee_skin:
			thread ShowRewards_MeleeSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.music_pack:
			thread ShowRewards_MusicPack( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.loadscreen:
			thread ShowRewards_Loadscreen( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.skydive_emote:
			thread ShowRewards_SkydiveEmote( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.character_emote:
			thread ShowRewards_CharacterEmote( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.voucher:
			thread ShowRewards_Voucher( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

                
                         
                                                                                       
        
                      

		default:
			Warning( "Loot Ceremony reward item type not supported: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
			thread ShowRewards_PLACEHOLDER( item, attachOrigin, attachAngles, rarity, displayIndex )
			break
	}
}
#endif          


const float MODEL_ROTATE_SPEED = 15.0
const float CURRENCY_Z_OFFSET = 26.0


#if CLIENT
void function ShowRewards_Currency( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                        
	origin += <0, 0, CURRENCY_Z_OFFSET>

	asset modelAsset = $"mdl/dev/empty_model.rmdl"
	float modelScale = 1.0
	bool shouldSpin  = true
	if ( ItemFlavor_GetType( item ) == eItemType.account_currency )
	{
		                                                                                                                                                         

		if ( GRXCurrency_GetPreviewModel( item ) != $"" )
			modelAsset = GRXCurrency_GetPreviewModel( item )
		modelScale = 0.7
		shouldSpin = GetCurrentPlaylistVarBool( "loot_ceremony_currency_spins", true )
	}
	else
	{
		asset itemAsset = ItemFlavor_GetAsset( item )
		                                                                                                                                                
		Assert( itemAsset == $"settings/itemflav/currency_bundle/crafting_common.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/crafting_rare.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/crafting_epic.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/crafting_legendary.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/heirloom.rpak" )

		switch ( rarity )
		{
			case eRarityTier.COMMON:
				modelAsset = CURRENCY_MODEL_COMMON
				break

			case eRarityTier.RARE:
				modelAsset = CURRENCY_MODEL_RARE
				break

			case eRarityTier.EPIC:
				modelAsset = CURRENCY_MODEL_EPIC
				break

			case eRarityTier.LEGENDARY:
				modelAsset = CURRENCY_MODEL_LEGENDARY
				break

			case eRarityTier.HEIRLOOM:
				ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
				modelAsset = GRXCurrency_GetPreviewModel( currencyFlav )
				break

			default: Assert( false )
		}
	}

	                               

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( modelScale )

	if ( shouldSpin )
		moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( modelEnt, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.account_currency_bundle )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}
#endif


#if CLIENT
const float LOOT_TICK_Z_OFFSET = 15.0
void function ShowRewards_LootTick( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                        
	origin += <0, 0, LOOT_TICK_Z_OFFSET>

	asset modelAsset = GRXPack_GetTickModel( item )

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )
	modelEnt.SetSkin( modelEnt.GetSkinIndexByName( GRXPack_GetTickModelSkin( item ) ) )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( 0.5 )

	moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( modelEnt, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.account_currency_bundle )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}
#endif


const float CHARACTER_SKIN_Z_OFFSET = 4.0
const float CHARACTER_SKIN_SCALE = 0.7


#if CLIENT
void function ShowRewards_CharacterSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                        
	origin += <0, 0, CHARACTER_SKIN_Z_OFFSET>

	entity mover          = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity characterModel = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )
	CharacterSkin_Apply( characterModel, item )
	characterModel.MakeSafeForUIScriptHack()
	mover.MakeSafeForUIScriptHack()
	characterModel.SetParent( mover )

	thread PlayAnim( characterModel, "ACT_MP_MENU_LOOT_CEREMONY_IDLE", mover )

	       
	characterModel.SetModelScale( CHARACTER_SKIN_SCALE )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( characterModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_skin )

	if ( Mythics_IsItemFlavorMythicSkin( item ) && displayIndex != 1 )
		fileLevel.characterSkinModels.append( characterModel )

	OnThreadEnd(
		function() : ( mover, characterModel, attachment )
		{
			characterModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, characterModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, characterModel, mover, angles, 360.0 )
}
#endif


const float EXECUTION_Z_OFFSET = 12.0
const vector EXECUTION_LOCAL_ANGLES = <0, 15, 0>
const float EXECUTION_SCALE = 0.4


#if CLIENT
void function ShowRewards_Execution( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                     
	ItemFlavor attackerCharacter = CharacterExecution_GetCharacterFlavor( item )
	ItemFlavor characterSkin     = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterSkin( attackerCharacter ) )

	asset attackerAnimSeq = CharacterExecution_GetAttackerPreviewAnimSeq( item )
	asset victimAnimSeq   = CharacterExecution_GetVictimPreviewAnimSeq( item )

	               
	origin += <0, 0, EXECUTION_Z_OFFSET>
	vector startAngles   = AnglesCompose( angles, EXECUTION_LOCAL_ANGLES )
	entity mover         = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, startAngles )
	entity attackerModel = CreateClientSidePropDynamic( origin, startAngles, $"mdl/dev/empty_model.rmdl" )
	entity victimModel   = CreateClientSidePropDynamic( origin, startAngles, $"mdl/dev/empty_model.rmdl" )

	CharacterSkin_Apply( attackerModel, characterSkin )
	victimModel.SetModel( $"mdl/humans/class/medium/dummy_v20_base_w.rmdl" )

	          
	bool attackerHasSequence = attackerModel.Anim_HasSequence( attackerAnimSeq )
	bool victimHasSequence   = victimModel.Anim_HasSequence( victimAnimSeq )

	if ( !attackerHasSequence || !victimHasSequence )
	{
		asset attackerPlayerSettings = CharacterClass_GetSetFile( attackerCharacter )
		string attackerRigWeight     = GetGlobalSettingsString( attackerPlayerSettings, "bodyModelRigWeight" )
		string attackerAnim          = "mp_pt_execution_" + attackerRigWeight + "_attacker_loot"

		attackerModel.Anim_Play( attackerAnim )
		victimModel.Anim_Play( "mp_pt_execution_default_victim_loot" )
		Warning( "Couldn't find menu idles for execution reward: " + DEV_DescItemFlavor( item ) + ". Using fallback anims." )
		if ( !attackerHasSequence )
			Warning( "ATTACKER could not find sequence: " + attackerAnimSeq )
		if ( !victimHasSequence )
			Warning( "VICTIM could not find sequence: " + victimAnimSeq )
	}
	else
	{
		attackerModel.Anim_Play( attackerAnimSeq )
		victimModel.Anim_Play( victimAnimSeq )
	}

	mover.MakeSafeForUIScriptHack()

	attackerModel.MakeSafeForUIScriptHack()
	attackerModel.SetParent( mover )

	victimModel.MakeSafeForUIScriptHack()
	victimModel.SetParent( mover )

	       
	attackerModel.SetModelScale( EXECUTION_SCALE )
	victimModel.SetModelScale( EXECUTION_SCALE )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( attackerModel, flashType, flashColor )
	thread FlashMenuModel( victimModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_execution )

	OnThreadEnd(
		function() : ( mover, attackerModel, victimModel, attachment )
		{
			attackerModel.Destroy()
			victimModel.Destroy()
			mover.Destroy()

			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Execution( item, rarity, attackerModel, victimModel, mover )
	else
		InspectMenuFunctionality_Execution( item, displayIndex, rarity, attackerModel, victimModel, mover, startAngles )
}
#endif


const float WEAPON_SKIN_Z_OFFSET = 28.0
const vector WEAPON_SKIN_LOCAL_ANGLES = <10, -90, 0>




#if CLIENT

const float HOLOSPRAY_Z_OFFSET = 16.0

void function ShowRewards_EmoteIcon( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	entity mover
	entity spray
	if ( !IsSpecialItemPresentationModeActive() )
	{
	#if NX_PROG
		origin += <0, 0, HOLOSPRAY_Z_OFFSET + 5>
	#else
		origin += <0, 0, HOLOSPRAY_Z_OFFSET>
	#endif

		                
		mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
		mover.SetDoDestroyCallback( true )

		spray = CreateClientSideEmoteIconModel( item, origin, angles )
		spray.SetParent( mover )
		spray.SetModelScale( 0.4 )
	}
	else
	{
		origin -= <0, 0, HOLOSPRAY_Z_OFFSET> * 2

		asset EMOTE_ICON_BASE_MODEL = HOLO_SPRAY_BASE

		mover = CreateClientsideScriptMover( EMOTE_ICON_BASE_MODEL, origin, angles )
		mover.MakeSafeForUIScriptHack()
		mover.SetDoDestroyCallback( true )

		spray = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )

		thread CreateClientSideEmoteIcon( mover, ItemFlavor_GetGUID( item ), Time(), true )
	}


	               
	                                                  
	                                                              
	                                                             
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, spray, attachment )
		{
			spray.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, spray, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, spray, mover, angles, 360.0 )

	WaitForever()
}


void function ShowRewards_WeaponSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_SKIN_Z_OFFSET>

	                
	ItemFlavor weaponFlavor = WeaponSkin_GetWeaponFlavor( item )
	entity mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity weaponModel      = CreateClientSidePropDynamic( origin, AnglesCompose( angles, WEAPON_SKIN_LOCAL_ANGLES ), $"mdl/dev/empty_model.rmdl" )
	WeaponCosmetics_Apply( weaponModel, item, null )

	bool isReactive = WeaponSkin_DoesReactToKills( item )
	if ( isReactive )
		MenuWeaponModel_ApplyReactiveSkinBodyGroup( item, weaponFlavor, weaponModel )
	else
		ShowDefaultBodygroupsOnFakeWeapon( weaponModel, WeaponItemFlavor_GetClassname( weaponFlavor ) )

	MenuWeaponModel_ClearReactiveEffects( weaponModel )
	if ( isReactive )
		MenuWeaponModel_StartReactiveEffects( weaponModel, item )

	mover.MakeSafeForUIScriptHack()
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )
	weaponModel.Anim_SetPaused( true )
	weaponModel.SetModelScale( WeaponItemFlavor_GetLootCeremonyScale( weaponFlavor ) )
	weaponModel.SetParent( mover )

	         
	string attachmentName = "MENU_ROTATE"
	vector originOffset   = GetAttachmentOriginOffset( weaponModel, attachmentName, WEAPON_SKIN_LOCAL_ANGLES )

	weaponModel.SetLocalOrigin( originOffset )
	weaponModel.SetLocalAngles( WEAPON_SKIN_LOCAL_ANGLES )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( weaponModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, angles, 360.0 )
}
#endif          


const float WEAPON_CHARM_Z_OFFSET = 32.0
const vector WEAPON_CHARM_LOCAL_ANGLES = <-5, -40, 0>
const float WEAPON_CHARM_BASE_SCALE = 1.0
const float WEAPON_CHARM_EXTRA_SCALE = 1.34


#if CLIENT
void function ShowRewards_WeaponCharm( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_CHARM_Z_OFFSET>

	vector moverStartAngles = <0, fileLevel.cameraMover.GetAngles().y + 90, 0>
	entity mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, moverStartAngles )
	mover.MakeSafeForUIScriptHack()

	entity weaponModel = CreateClientSidePropDynamic( origin, <0, 0, 0>, $"mdl/dev/empty_model.rmdl" )
	weaponModel.SetModel( $"mdl/weapons/r97/ptpov_r97.rmdl" )
	weaponModel.SetSkin( weaponModel.GetSkinIndexByName( "charm_preview_black" ) )
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )
	weaponModel.Anim_SetPaused( true )
	weaponModel.SetModelScale( WEAPON_CHARM_BASE_SCALE )
	weaponModel.SetParent( mover )
	ShowDefaultBodygroupsOnFakeWeapon( weaponModel, "mp_weapon_r97" )

	weaponModel.SetLocalOrigin( GetAttachmentOriginOffset( weaponModel, "CHARM", WEAPON_CHARM_LOCAL_ANGLES ) )
	weaponModel.SetLocalAngles( WEAPON_CHARM_LOCAL_ANGLES )

	WeaponCosmetics_Apply( weaponModel, null, item )

	entity charmEnt = GetCharmForWeaponEntity( weaponModel )
	charmEnt.SetModelScale( WEAPON_CHARM_BASE_SCALE * WEAPON_CHARM_EXTRA_SCALE )

	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( weaponModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, charmEnt, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			if ( IsValid( charmEnt ) )
				charmEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 50.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, moverStartAngles, 50.0 )
}
#endif

#if CLIENT
void function ShowRewards_MeleeSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_SKIN_Z_OFFSET>

	vector extraRotation = MeleeSkin_GetMenuModelRotation( item )
	entity mover         = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity weaponModel   = CreateClientSidePropDynamic( origin, AnglesCompose( angles, extraRotation ), $"mdl/dev/empty_model.rmdl" )

	asset modelAsset = MeleeSkin_GetMenuModel( item )
	weaponModel.SetModel( modelAsset )

	mover.MakeSafeForUIScriptHack()
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )

	asset animSeq = MeleeSkin_GetMenuAnimSeq( item )
	if ( animSeq != $"" )
		weaponModel.Anim_Play( animSeq )

	weaponModel.SetModelScale( WeaponItemFlavor_GetLootCeremonyScale( item ) )
	weaponModel.SetParent( mover )

	         
	string attachmentName = "MENU_ROTATE"
	vector originOffset   = GetAttachmentOriginOffset( weaponModel, attachmentName, extraRotation )

	weaponModel.SetLocalOrigin( originOffset )
	weaponModel.SetLocalAngles( extraRotation )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( weaponModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, angles, 360.0 )
}
#endif


#if CLIENT
int function GetLootCeremonyFlashType( ItemFlavor item )
{
	Assert( ItemFlavor_HasQuality( item ) )

	int rarity = ItemFlavor_GetQuality( item )
	if ( rarity >= eRarityTier.LEGENDARY )
		return eMenuModelFlashType.LOOT_CEREMONY_HIGH_RARITY

	return eMenuModelFlashType.LOOT_CEREMONY_LOW_RARITY
}
#endif


const float GLADIATOR_CARD_WIDTH = 528.0
const float GLADIATOR_CARD_HEIGHT = 912.0
const float GLADIATOR_CARD_Z_OFFSET = 2.0


#if CLIENT
void function ShowRewards_GladiatorCard( ItemFlavor item, int itemType, vector origin, vector angles, int displayIndex, int rarity )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	GladiatorCardData gCardData = ShowRewards_GladiatorCard_Create( item, itemType, true, rarity, origin, angles )

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_GladiatorCard( item, itemType, rarity, gCardData )
	else
		InspectMenuFunctionality_GladiatorCard( item, itemType, origin, angles, displayIndex, rarity, gCardData )
}
#endif


#if CLIENT
GladiatorCardData function ShowRewards_GladiatorCard_Create( ItemFlavor item, int itemType, bool firstTime, int rarity, vector origin, vector angles )
{
	entity player    = GetLocalClientPlayer()
	vector ruiOrigin = origin + <0, 0, GLADIATOR_CARD_Z_OFFSET>
	vector ruiAngles = AnglesCompose( angles, <0, 180, 0> )
	float width      = GLADIATOR_CARD_WIDTH / 16.0
	float height     = GLADIATOR_CARD_HEIGHT / 16.0
	var topo         = CreateRUITopology_Worldspace( ruiOrigin + <0, 0, height * 0.5>, ruiAngles, width, height )
	var parentRui    = RuiCreate( $"ui/loot_ceremony_glad_card.rpak", topo, RUI_DRAW_WORLD, 0 )

	int gcardPresentation
	if ( itemType == eItemType.gladiator_card_frame )
		gcardPresentation = eGladCardPresentation.FRONT_FRAME_ONLY
	else
		gcardPresentation = eGladCardPresentation.FRONT_STANCE_ONLY

	NestedGladiatorCardHandle nestedGCHandleFront = CreateNestedGladiatorCard( parentRui, "card", eGladCardDisplaySituation.MENU_LOOT_CEREMONY_ANIMATED, gcardPresentation )
	ChangeNestedGladiatorCardOwner( nestedGCHandleFront, ToEHI( player ) )

	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
		if ( character == null )
			character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )

		expect ItemFlavor( character )

		SetNestedGladiatorCardOverrideCharacter( nestedGCHandleFront, character )
		SetNestedGladiatorCardOverrideFrame( nestedGCHandleFront, item )
	}
	else
	{
		ItemFlavor character = GladiatorCardStance_GetCharacterFlavor( item )
		SetNestedGladiatorCardOverrideCharacter( nestedGCHandleFront, character )
		SetNestedGladiatorCardOverrideStance( nestedGCHandleFront, item )

		ItemFlavor characterDefaultFrame = GetDefaultItemFlavorForLoadoutSlot( EHI_null, Loadout_GladiatorCardFrame( character ) )
		SetNestedGladiatorCardOverrideFrame( nestedGCHandleFront, characterDefaultFrame )                          
	}

	GladiatorCardData gCardData
	gCardData.handle = nestedGCHandleFront
	gCardData.rui = parentRui
	gCardData.topo = topo

	RuiSetBool( parentRui, "firstTime", firstTime )
	RuiSetInt( parentRui, "rarity", rarity )

	return gCardData
}
#endif


#if CLIENT
void function ShowRewards_GladiatorCard_Destroy( GladiatorCardData gCardData )
{
	CleanupNestedGladiatorCard( gCardData.handle )
	RuiDestroyIfAlive( gCardData.rui )

	if ( gCardData.topo != null )
	{
		RuiTopology_Destroy( gCardData.topo )
		gCardData.topo = null
	}
}
#endif


const float RUI_QUIP_WIDTH = 390.0
const float RUI_QUIP_HEIGHT = 208.0
const float RUI_QUIP_Z_OFFSET = 24.0


#if CLIENT
void function ShowRewards_Quip( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	const float QUIP_RUI_SCALE_DIVIDE_BY = 16.0

	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                                        
	vector placardOrigin = origin + <0, 0, RUI_QUIP_Z_OFFSET>
	float width          = RUI_QUIP_WIDTH / QUIP_RUI_SCALE_DIVIDE_BY
	float height         = RUI_QUIP_HEIGHT / QUIP_RUI_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, QUIP_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / QUIP_RUI_SCALE_DIVIDE_BY )

	var topoQuip = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )

	                            
	var ruiQuip
	ItemFlavor quipCharacter
	string labelText

	if ( ItemFlavor_GetType( item ) == eItemType.gladiator_card_intro_quip )
	{
		ruiQuip = RuiCreate( $"ui/loot_reward_intro_quip.rpak", topoQuip, RUI_DRAW_WORLD, 0 )
		quipCharacter = CharacterIntroQuip_GetCharacterFlavor( item )
		labelText = "#LOOT_QUIP_INTRO"
	}
	else
	{
		ruiQuip = RuiCreate( $"ui/loot_reward_kill_quip.rpak", topoQuip, RUI_DRAW_WORLD, 0 )
		quipCharacter = CharacterKillQuip_GetCharacterFlavor( item )
		labelText = "#LOOT_QUIP_Kill"
	}

	RuiSetBool( ruiQuip, "isVisible", true )
	RuiSetInt( ruiQuip, "rarity", rarity )
	RuiSetImage( ruiQuip, "portraitImage", CharacterClass_GetGalleryPortrait( quipCharacter ) )
	RuiSetString( ruiQuip, "quipTypeText", labelText )
	RuiTrackFloat( ruiQuip, "level", null, RUI_TRACK_SOUND_METER, 0 )

	OnThreadEnd(
		function() : ( ruiQuip, topoQuip, bgModel )
		{
			RuiDestroyIfAlive( ruiQuip )
			RuiTopology_Destroy( topoQuip )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Quip( item, rarity, ruiQuip )
	else
		InspectMenuFunctionality_Quip( item, displayIndex, rarity, ruiQuip, bgModel )
}
#endif


#if CLIENT
void function ShowRewards_MusicPack( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	const float QUIP_RUI_SCALE_DIVIDE_BY = 16.0

	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                                        
	vector placardOrigin = origin + <0, 0, RUI_QUIP_Z_OFFSET>
	float width          = RUI_QUIP_WIDTH / QUIP_RUI_SCALE_DIVIDE_BY
	float height         = RUI_QUIP_HEIGHT / QUIP_RUI_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, QUIP_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / QUIP_RUI_SCALE_DIVIDE_BY )

	var topo = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )

	                            
	var rui = RuiCreate( $"ui/loot_reward_intro_quip.rpak", topo, RUI_DRAW_WORLD, 0 )

	RuiSetBool( rui, "isVisible", true )
	RuiSetInt( rui, "rarity", rarity )
	RuiSetImage( rui, "portraitImage", MusicPack_GetPortraitImage( item ) )
	RuiSetFloat( rui, "portraitBlend", MusicPack_GetPortraitBlend( item ) )
	RuiSetString( rui, "quipTypeText", "#MUSIC_PACK" )
	RuiTrackFloat( rui, "level", null, RUI_TRACK_SOUND_METER, 0 )

	OnThreadEnd(
		function() : ( rui, topo, bgModel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_MusicPack( item, rarity, rui )
	else
		InspectMenuFunctionality_MusicPack( item, displayIndex, rarity, rui, bgModel )
}
#endif


const float STAT_TRACKER_WIDTH = 594.0
const float STAT_TRACKER_HEIGHT = 230.0
const float STAT_TRACKER_Z_OFFSET = 27.0
const float STAT_TRACKER_SCALE_DIVIDE_BY = 24.0


#if CLIENT
void function ShowRewards_StatTracker( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                                        
	vector placardOrigin = origin + <0, 0, STAT_TRACKER_Z_OFFSET>
	float width          = STAT_TRACKER_WIDTH / STAT_TRACKER_SCALE_DIVIDE_BY
	float height         = STAT_TRACKER_HEIGHT / STAT_TRACKER_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoStatTracker = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiStatTracker  = RuiCreate( $"ui/loot_ceremony_stat_tracker.rpak", topoStatTracker, RUI_DRAW_WORLD, 0 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, STAT_TRACKER_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / STAT_TRACKER_SCALE_DIVIDE_BY )

	ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
	if ( character == null )                                  
		character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( character )

	RuiSetBool( ruiStatTracker, "isVisible", true )
	UpdateRuiWithStatTrackerData( ruiStatTracker, "tracker", LocalClientEHI(), character, -1, item, null, true )
	RuiSetColorAlpha( ruiStatTracker, "trackerColor0", GladiatorCardStatTracker_GetColor0( item ), 1.0 )

	OnThreadEnd(
		function() : ( ruiStatTracker, topoStatTracker, bgModel )
		{
			RuiDestroyIfAlive( ruiStatTracker )
			RuiTopology_Destroy( topoStatTracker )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiStatTracker, "#STAT_TRACKER_DESCRIPTION" )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiStatTracker, bgModel, "#STAT_TRACKER_DESCRIPTION" )
}
#endif



const float BADGE_Z_OFFSET = 20.0


#if CLIENT
void function ShowRewards_Badge( ItemFlavor item, int badgeDataInteger, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )


	const float BATTLEPASS_BADGE_WIDTH = 500.0
	const float BATTLEPASS_BADGE_HEIGHT = 500.0
	const float BATTLEPASS_BADGE_SCALE = 0.06

	                                        
	vector placardOrigin = origin + <0, 0, BADGE_Z_OFFSET>
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	float width  = BATTLEPASS_BADGE_WIDTH * BATTLEPASS_BADGE_SCALE
	float height = BATTLEPASS_BADGE_HEIGHT * BATTLEPASS_BADGE_SCALE

	var topoBadge = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiBadge  = RuiCreate( $"ui/world_space_badge.rpak", topoBadge, RUI_DRAW_VIEW_MODEL, 0 )
	RuiSetFloat( ruiBadge, "bloomScale", 0.2 )

	entity bgModel = null                                                                                                      
	                                   
	                                                      

	RuiSetBool( ruiBadge, "isVisible", true )

	int ornull overrideDataIntegerOrNull      = badgeDataInteger >= 0 ? badgeDataInteger : null
	bool TEMP_showOneTierHigherThanIsUnlocked = true

	CreateNestedGladiatorCardBadge( ruiBadge, "badge", LocalClientEHI(), item, -1, null, overrideDataIntegerOrNull, TEMP_showOneTierHigherThanIsUnlocked )

	OnThreadEnd(
		function() : ( ruiBadge, topoBadge, bgModel )
		{
			RuiDestroyIfAlive( ruiBadge )
			RuiTopology_Destroy( topoBadge )
			if ( IsValid( bgModel ) )
				bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiBadge, ItemFlavor_GetShortDescription( item ) )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiBadge, bgModel, ItemFlavor_GetShortDescription( item ) )
}
#endif


#if CLIENT
const float RUI_LOADSCREEN_WIDTH = 800.0
const float RUI_LOADSCREEN_HEIGHT = 450.0
const float RUI_LOADSCREEN_Z_OFFSET = 30

void function ShowRewards_Loadscreen( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                      
	vector placardOrigin = origin + <0, 0, RUI_LOADSCREEN_Z_OFFSET>
	float width          = RUI_LOADSCREEN_WIDTH / 16.0
	float height         = RUI_LOADSCREEN_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	                                                                                        
	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/world_space_loadscreen.rpak", topo, RUI_DRAW_WORLD, 0 )

	if ( IsSpecialItemPresentationModeActive() )
		PopulateInspectMenuDetails( item, rarity, 1, "", "" )                                                       
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )

	RuiSetImage( rui, "loadscreenImage", $"" )

	OnThreadEnd(
		function() : ( rui, topo )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )

			                                 
			foreach ( handle in fileLevel.pakHandles )
			{
				if ( handle.isAvailable )
					ReleasePakFile( handle )
			}
		}
	)

	WaitFrame()                                                                 

	                     
	string rpak         = Loadscreen_GetRPakName( item )
	PakHandle pakHandle = RequestPakFile( rpak )
	fileLevel.pakHandles.append( pakHandle )

	if ( !pakHandle.isAvailable )
		WaitSignal( pakHandle, "PakFileLoaded" )

	RuiSetImage( rui, "loadscreenImage", Loadscreen_GetLoadscreenImageAsset( item ) )

	WaitForever()
}
#endif


#if CLIENT
const float RUI_SKYDIVE_EMOTE_WIDTH = 800.0
const float RUI_SKYDIVE_EMOTE_HEIGHT = 450.0
const float RUI_SKYDIVE_EMOTE_Z_OFFSET = 30

void function ShowRewards_SkydiveEmote( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                      
	vector placardOrigin = origin + <0, 0, RUI_SKYDIVE_EMOTE_Z_OFFSET>
	float width          = RUI_SKYDIVE_EMOTE_WIDTH / 16.0
	float height         = RUI_SKYDIVE_EMOTE_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/finisher_video.rpak", topo, RUI_DRAW_VIEW_MODEL, 0 )

	int videoChannel = ReserveVideoChannel()
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, SkydiveEmote_GetVideo( item ), true, 0.0 )

	OnThreadEnd(
		function() : ( rui, topo, videoChannel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			ReleaseVideoChannel( videoChannel )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, rui )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )
}
#endif


#if CLIENT
void function ShowRewards_CharacterEmote( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                        
	origin += <0, 0, CHARACTER_SKIN_Z_OFFSET>

	ItemFlavor ornull char = CharacterQuip_GetCharacterFlavor( item )

	if ( char == null )
		char = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( char )

	ItemFlavor skin = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterSkin( char ) )

	           
	if ( ItemFlavor_GetHumanReadableRef(item) == "character_emote_caustic_epic_rakestep" )
	{
		angles += < 0, 50, 0 >
	}

	entity mover          = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity characterModel = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )

	CharacterSkin_Apply( characterModel, skin )
	characterModel.MakeSafeForUIScriptHack()
	mover.MakeSafeForUIScriptHack()
	characterModel.SetParent( mover )

	thread ModelPerformEmote( characterModel, item, mover, false )

	       
	characterModel.SetModelScale( CHARACTER_SKIN_SCALE )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( characterModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_skin )

	OnThreadEnd(
		function() : ( mover, characterModel, attachment )
		{
			characterModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, characterModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, characterModel, mover, angles, 360.0 )
}
#endif


#if CLIENT
const float VOUCHER_Z_OFFSET = 31.0

void function ShowRewards_Voucher( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                        
	origin += <0, 0, VOUCHER_Z_OFFSET>

	asset modelAsset = Voucher_GetModel( item )

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( 0.75 )

	moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	               
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( modelEnt, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.voucher )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}
#endif


#if CLIENT
                
                                                                                                                
 
                                             
                                                       
                                                               

                     

                                                                                          
                                

                                                                                        
                                      
                                       
                                

                                                        
                                                                
                             
                            
                                                                                            

             
                                      
   
                         
                  
   
  

                 
                         

                                             
                                                                                                  
     
                                                                                                             
 
                      
#endif


#if CLIENT
const float RUI_PLACEHOLDER_WIDTH = 450.0
const float RUI_PLACEHOLDER_HEIGHT = 200.0
const float RUI_PLACEHOLDER_Z_OFFSET = 25

void function ShowRewards_PLACEHOLDER( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                      
	vector placardOrigin = origin + <0, 0, RUI_PLACEHOLDER_Z_OFFSET>
	float width          = RUI_PLACEHOLDER_WIDTH / 16.0
	float height         = RUI_PLACEHOLDER_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoPlaceholder = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var ruiPlaceholder  = RuiCreate( $"ui/loot_reward_temp.rpak", topoPlaceholder, RUI_DRAW_WORLD, 0 )

	RuiSetString( ruiPlaceholder, "bodyText", Localize( ItemFlavor_GetLongName( item ) ) )

	OnThreadEnd(
		function() : ( ruiPlaceholder, topoPlaceholder )
		{
			RuiDestroyIfAlive( ruiPlaceholder )
			RuiTopology_Destroy( topoPlaceholder )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiPlaceholder )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiPlaceholder )
}
#endif


const float RUI_PLACARD_WIDTH 			= 550.0
const float RUI_PLACARD_HEIGHT 			= 256.0
const float RUI_PLACARD_Z_OFFSET		= 7.0
const float RUI_PLACARD_FORWARD_OFFSET 	= 32.0
const bool  RUI_PLACARD_DEBUG 			= false
const int   MYTHIC_RARITY_INDEX 		= eRarityTier.HEIRLOOM + 1                                                                                  

#if CLIENT
void function ShowRewards_Placard( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	                      
	vector placardOrigin = origin + (AnglesToForward( angles ) * RUI_PLACARD_FORWARD_OFFSET) + <0, 0, RUI_PLACARD_Z_OFFSET>
	float width          = RUI_PLACARD_WIDTH / 18.0
	float height         = RUI_PLACARD_HEIGHT / 18.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoPlacard = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	int ruiDrawMode = ItemFlavor_GetHumanReadableRef(item) == "character_emote_caustic_epic_rakestep" ? RUI_DRAW_VIEW_MODEL : RUI_DRAW_WORLD
	var ruiPlacard  = RuiCreate( $"ui/loot_placard.rpak", topoPlacard, ruiDrawMode, 1 )

	if ( ItemFlavor_GetType( item ) == eItemType.account_currency )
	{
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetShortName( item ) )
	}
	else if ( ItemFlavor_GetType( item ) == eItemType.account_currency_bundle )
	{
		ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetShortName( currencyFlav ) )
	}
	else if ( Mythics_IsItemFlavorMythicSkin( item ) )
	{
		int tierIndex = Mythics_GetSkinTierIntForSkin( item )

		RuiSetString( ruiPlacard, "nameText", Localize( "#TIER", tierIndex ) )
		rarity = MYTHIC_RARITY_INDEX

		if ( tierIndex == 3 )
			RuiSetString( ruiPlacard, "additionalText", "+" + Localize( "#itemtype_character_execution_NAME" ) )

		if ( tierIndex > 1 )
			RuiSetBool( ruiPlacard, "isLocked", true )
	}
	else
	{
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetTypeName( item ) )
	}
	RuiSetInt( ruiPlacard, "rarity", rarity )

	fileLevel.rewardPlacards[ INSPECT_BUTTONS[displayIndex] ] = ruiPlacard

	OnThreadEnd(
		function() : ( ruiPlacard, topoPlacard, displayIndex )
		{
			RuiDestroyIfAlive( ruiPlacard )
			RuiTopology_Destroy( topoPlacard )

			fileLevel.rewardPlacards[INSPECT_BUTTONS[displayIndex]] = null
		}
	)

	while( true )
	{
		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		RuiSetBool( ruiPlacard, "visible", false )

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( ruiPlacard, "visible", true )
	}
}
#endif


#if CLIENT
void function UIToClient_RewardPlacard_Hover( var menuButton, bool isHovered )
{
	var rui = RewardPlacard_GetRuiFromMenuButton( menuButton )

	if ( IsValid( rui ) )
		RuiSetBool( rui, "isHovered", isHovered )

	MythicSetButtonModelFade( menuButton, !isHovered )
}
#endif

#if CLIENT
void function MythicUpdateAllEffects( bool enable )
{
	WaitFrame()
	if ( fileLevel.characterSkinModels.len() < 2 )
		return

	if ( !enable )
	{
		thread MythicModelClear( fileLevel.characterSkinModels[0] )
		thread MythicModelClear( fileLevel.characterSkinModels[1] )
	}
	else
	{
		thread MythicModelFade( fileLevel.characterSkinModels[0] )
		thread MythicModelFade( fileLevel.characterSkinModels[1] )
	}
}

void function MythicSetButtonModelFade( var menuButton, bool fade )
{
	if ( fileLevel.characterSkinModels.len() < 2 || Hud_GetHudName( menuButton ) == INSPECT_BUTTONS[1] )
		return

	entity model

	if ( Hud_GetHudName( menuButton ) == INSPECT_BUTTONS[0] )
		model = fileLevel.characterSkinModels[0]
	else if ( Hud_GetHudName( menuButton ) == INSPECT_BUTTONS[2] )
		model = fileLevel.characterSkinModels[1]

	if( !IsValid( model ) )
		return

	if( fade && !fileLevel.inspectModeActive )
		thread MythicModelFade( model )
	else
		thread MythicModelClear( model )
}

void function MythicModelFade( entity model )
{
	WaitFrame()

	if( !IsValid( model ) )
		return

	array<entity> hierachy = GetEntityAndImmediateChildren( model )
	foreach ( entity childEnt in hierachy )
	{
		childEnt.Highlight_ResetFlags()
		childEnt.Highlight_SetCurrentContext( HIGHLIGHT_CONTEXT_NEUTRAL )
		int highlightState = childEnt.Highlight_GetState( HIGHLIGHT_CONTEXT_NEUTRAL )
		childEnt.Highlight_SetFunctions( HIGHLIGHT_CONTEXT_NEUTRAL, HIGHLIGHT_FILL_LOBBY_IN_MATCH, true, 0, 1, highlightState, false )
		childEnt.Highlight_SetParam( HIGHLIGHT_CONTEXT_NEUTRAL, 0, <0.01, 0.01, 0.01> )
		childEnt.Highlight_SetParam( HIGHLIGHT_CONTEXT_NEUTRAL, 1, <400.0, 100.0, 100.0> )
		childEnt.Highlight_SetFadeInTime( 1 )
		childEnt.Highlight_SetFadeOutTime( 999999 )
		childEnt.Highlight_StartOn()
		childEnt.Highlight_SetLifeTime( 99999999 )
	}
}

void function MythicModelClear( entity model )
{
	WaitFrame()

	if( !IsValid( model ) )
		return
	array<entity> hierachy = GetEntityAndImmediateChildren( model )
	foreach ( entity childEnt in hierachy )
	{
		int highlightState = childEnt.Highlight_GetState( HIGHLIGHT_CONTEXT_NEUTRAL )
		childEnt.Highlight_SetFunctions( HIGHLIGHT_CONTEXT_NEUTRAL, 0, true, HIGHLIGHT_OUTLINE_NONE, 1.0, highlightState, false )
	}
}
#endif

#if CLIENT
var function RewardPlacard_GetRuiFromMenuButton( var menuButton )
{
	string menuButtonName = Hud_GetHudName( menuButton )

	return fileLevel.rewardPlacards[menuButtonName]
}
#endif


#if CLIENT
void function ShowInspect_FX( int animAttachID, int rarity, vector rarityColor )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	    
	asset particleAssetRarity
	switch ( rarity )
	{
		case 0:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER1
			break

		case 1:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER2
			break

		case 2:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER3
			break

		case 3:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER4
			break

		case 4:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER5
			break

		default:
			Assert( 0, "Couldn't find particle beam asset based on rarity: " + rarity )
	}

	int fxIndexRarity = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( particleAssetRarity ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexRarity, 1, rarityColor )

	int fxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexBeam, 1, rarityColor )

	table<string, int> fxTrackerBeam = { fxID = fxIndexBeam }

	OnThreadEnd(
		function() : ( fxIndexRarity, fxTrackerBeam )
		{
			if ( EffectDoesExist( fxIndexRarity ) )
				EffectStop( fxIndexRarity, true, false )

			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
	)

	WaitForever()
}

void function ShowRewards_FX( int animAttachID, int rarity, vector rarityColor, int displayIndex )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	Chroma_LootCeremonyReward( displayIndex, rarity )

	    
	asset particleAssetRarity
	switch ( rarity )
	{
		case 0:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER1
			break

		case 1:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER2
			break

		case 2:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER3
			break

		case 3:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER4
			break

		case 4:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER5
			break

		default:
			Assert( 0, "Couldn't find particle beam asset based on rarity: " + rarity )
	}

	int fxIndexRarity = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( particleAssetRarity ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexRarity, 1, rarityColor )

	int fxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexBeam, 1, rarityColor )

	table<string, int> fxTrackerBeam = { fxID = fxIndexBeam }

	if ( IsSpecialItemPresentationModeActive() )
	{
		OnThreadEnd(
			function() : ( fxIndexRarity, fxTrackerBeam )
			{
				if ( EffectDoesExist( fxIndexRarity ) )
					EffectStop( fxIndexRarity, true, false )

				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
		)

		WaitForever()
	}
	else
		InspectMenuFunctionality_FXBeams( displayIndex, fxIndexRarity, fxTrackerBeam, animAttachID, rarityColor )
}
#endif


#if CLIENT && DEV
void function DEV_ShouldShowCustomLootRewards( bool shouldShow )
{
	fileLevel.debugShowCustomRewards = shouldShow
}
#endif

#if CLIENT && DEV
void function DEV_SetCustomLootRewardsToDisplay( string itemRef0 = "", string itemRef1 = "", string itemRef2 = "" )
{
	DEV_ShouldShowCustomLootRewards( true )

	array<string> flavorRefs = [itemRef0, itemRef1, itemRef2]
	array<asset> flavorAssets

	foreach ( string ref in  flavorRefs )
	{
		if ( ref == "" )
			continue

		ItemFlavor flavor = GetItemFlavorByHumanReadableRef( ref )
		asset flavorAsset = ItemFlavor_GetAsset( flavor )
		flavorAssets.append( flavorAsset )
	}

	fileLevel.debugCustomRewardAssets = flavorAssets
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                               
                                                            
                                                            
                                                            
                                                            
                                                            
                                                            
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


const float INSPECT_ZOOM_TIME = 0.25


#if CLIENT
void function UIToClient_RewardInspectActivate( var menuButton )
{
	thread UIToClient_RewardInspectActivate_Threaded( menuButton )
}
#endif


#if CLIENT
void function UIToClient_RewardInspectActivate_Threaded( var menuButton )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	table<string, bool> success = { result = false }

	                     
	RunUIScript( "ClientToUI_SetInspectModeIsActive" )
	RunUIScript( "ClientToUI_UpdateStoreButtonVisibility" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	DisableFakeInspectButtons()

	fileLevel.inspectModeActive = true
	thread MythicUpdateAllEffects( false )

	               
	string menuButtonName = Hud_GetHudName( menuButton )
	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeStart", { inspectButton = menuButtonName } )

	          
	InspectMenu_ZoomIn( menuButton )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_INSPECT_ZOOM_IN )

	OnThreadEnd(
		function() : ( success )
		{
			if ( success[ "result" ] == false )
			{
				if ( !IsLootCeremonyActive() )
				{
					fileLevel.cameraMover.NonPhysicsStop()
					fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

					DisableInspectMenu()
				}
			}
		}
	)

	wait INSPECT_ZOOM_TIME

	EnableInspectMenu()
	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeStartComplete" )

	success[ "result" ] = true
}
#endif


#if CLIENT
void function InspectMenu_ZoomIn( var menuButton, bool instantZoom = false )
{
	table<string, vector> zoomOrgAngles = RewardInspect_GetCameraOrgAnglesFromMenuButton( menuButton )

	InspectMenu_SetZoom( zoomOrgAngles[ "origin" ], zoomOrgAngles[ "angles" ], instantZoom )
}

void function InspectMenu_SetZoom( vector zoomOrigin, vector zoomAngles, bool instantZoom = false )
{
	fileLevel.cameraMover.ClearParent()

	if ( instantZoom )
	{
		fileLevel.cameraMover.SetOrigin( zoomOrigin )
		fileLevel.cameraMover.SetAngles( zoomAngles )
	}
	else
	{
		fileLevel.cameraMover.NonPhysicsMoveTo( zoomOrigin, INSPECT_ZOOM_TIME, 0, 0.1 )
		fileLevel.cameraMover.NonPhysicsRotateTo( zoomAngles, INSPECT_ZOOM_TIME, 0, 0.1 )
	}
}
#endif


#if CLIENT
void function UIToClient_RewardInspectNavBack()
{
	thread UIToClient_RewardInspectNavBack_Threaded()
}
#endif


#if CLIENT
void function UIToClient_TrackButtonOnClick()
{
	if ( Hud_IsLocked( fileLevel.trackChallengeButton ) )
	{
		RunUIScript( "ClientToUI_PlayLootCeremonySound", "menu_deny" )
		return
	}

	RunUIScript( "ClientToUI_TrackMythicChallenge", ItemFlavor_GetGUID( fileLevel.trackButtonItemFlavor) )
}

void function UIToClient_RewardEquipOnClick()
{
	#if DEV
		if ( fileLevel.debugShowCustomRewards )
		{
			Warning( "Trying to equip a reward you may not actually own. You should disable custom rewards." )
		}
	#endif

	if ( Hud_IsLocked( fileLevel.equipButton ) )
	{
		RunUIScript( "ClientToUI_PlayLootCeremonySound", "menu_deny" )
		return
	}

	RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )

	int itemType              = ItemFlavor_GetType( fileLevel.equipButtonItemFlavor )
	array<LoadoutEntry> entry = EquipButton_GetItemLoadoutEntries( fileLevel.equipButtonItemFlavor, false )

	if ( entry.len() == 1 )
	{
		UIToClient_RewardEquipOnClickWithIndex( 0 )
	}
	else
	{
		RunUIScript( "ClientToUI_EquipButtonShowDialog", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
	}
}

void function UIToClient_RewardEquipOnClickWithIndex( int index )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( fileLevel.equipButtonItemFlavor, false )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RequestSetItemFlavorLoadoutSlot_WithDuplicatePrevention( LocalClientEHI(), entries, fileLevel.equipButtonItemFlavor, index )
	PIN_Customization( null, fileLevel.equipButtonItemFlavor, "equip", index )

	Hud_SetLocked( fileLevel.equipButton, true )
	var rui = Hud_GetRui( fileLevel.equipButton )
	RuiSetString( rui, "buttonText", "#EQUIPPED_LOOT_REWARD" )
	RuiSetString( rui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( ItemFlavor_GetLongName( fileLevel.equipButtonItemFlavor ) ) ) )

	int rarity = 0
	if ( ItemFlavor_HasQuality( fileLevel.equipButtonItemFlavor ) )
		rarity = ItemFlavor_GetQuality( fileLevel.equipButtonItemFlavor )

	RuiSetInt( rui, "descTextRarity", rarity )
}

void function UIToClient_RewardEquipToWheelOnClick()
{
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
	RunUIScript( "ClientToUI_EquipToWheelButtonShowDialog", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
}

void function UIToClient_RewardEquipToWheelOnClickWithIndex( int index )
{
	int itemType                = ItemFlavor_GetType( fileLevel.equipButtonItemFlavor )
	ItemFlavor character        = expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( fileLevel.equipButtonItemFlavor ) )
	array<LoadoutEntry> entries = []
	int numSlots
	LoadoutEntry functionref( ItemFlavor, int ) getEntryFunc

	                                                                                                                                 
	                                                                                                                       

	if ( itemType == eItemType.skydive_emote )
	{
		numSlots     = NUM_SKYDIVE_EMOTE_SLOTS
		getEntryFunc = Loadout_SkydiveEmote
	}
	else
	{
		numSlots     = MAX_QUIPS_EQUIPPED
		getEntryFunc = Loadout_CharacterQuip
	}

	for ( int i = 0; i < numSlots; i++ )
	{
		LoadoutEntry entry = getEntryFunc( character, i )
		if ( LoadoutSlot_IsReady( LocalClientEHI(), entry ) )
			entries.append( entry )
	}

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RequestSetItemFlavorLoadoutSlot_WithDuplicatePrevention( LocalClientEHI(), entries, fileLevel.equipButtonItemFlavor, index )
	PIN_Customization( null, fileLevel.equipButtonItemFlavor, "equip", index )
}
#endif


#if CLIENT || UI
array<LoadoutEntry> function EquipButton_GetItemLoadoutEntries( ItemFlavor item, bool statTrackerFindExistingEntry = false )
{
	int itemType = ItemFlavor_GetType( item )
	array<LoadoutEntry> entry

	switch ( itemType )
	{
		case eItemType.character_skin:
			entry = [ Loadout_CharacterSkin( CharacterSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.weapon_skin:
			entry = [ Loadout_WeaponSkin( WeaponSkin_GetWeaponFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_frame:
			ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
			if ( character == null )                                  
				character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			expect ItemFlavor( character )

			entry = [ Loadout_GladiatorCardFrame( character ) ]
			break

		case eItemType.gladiator_card_stance:
			entry = [ Loadout_GladiatorCardStance( GladiatorCardStance_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.character_execution:
			entry = [ Loadout_CharacterExecution( CharacterExecution_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_intro_quip:
			entry = [ Loadout_CharacterIntroQuip( CharacterIntroQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_kill_quip:
			entry = [ Loadout_CharacterKillQuip( CharacterKillQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_stat_tracker:
			if ( statTrackerFindExistingEntry )
			{
				entry = [ PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( item, statTrackerFindExistingEntry ) ]
			}
			else
			{
				ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
				if ( character == null )                                  
					character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

				expect ItemFlavor( character )

				for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
				{
					LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
					if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
						entry.append( trackerSlot )
				}
			}
			break

		case eItemType.melee_skin:
			entry = [ Loadout_MeleeSkin( MeleeSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_badge:
			ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

			for ( int badgeIndex = 0; badgeIndex < GLADIATOR_CARDS_NUM_BADGES; badgeIndex++ )
			{
				LoadoutEntry badgeSlot = Loadout_GladiatorCardStatTracker( character, badgeIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), badgeSlot ) )
					entry.append( badgeSlot )
			}
			break

		case eItemType.music_pack:
			entry = [ Loadout_MusicPack() ]
			break

		case eItemType.loadscreen:
			entry = [ Loadout_Loadscreen() ]
			break

		case eItemType.skydive_emote:
			ItemFlavor character = SkydiveEmote_GetCharacterFlavor( item )

			for ( int emoteIndex = 0; emoteIndex < NUM_SKYDIVE_EMOTE_SLOTS; emoteIndex++ )
			{
				LoadoutEntry emoteSlot = Loadout_SkydiveEmote( character, emoteIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), emoteSlot ) )
					entry.append( emoteSlot )
			}
			break

		case eItemType.emote_icon:
		case eItemType.character_emote:
			ItemFlavor ornull character = CharacterQuip_GetCharacterFlavor( item )
			if ( character == null )                                  
				character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			expect ItemFlavor( character )

			for ( int emoteIndex = 0; emoteIndex < MAX_QUIPS_EQUIPPED; emoteIndex++ )
			{
				LoadoutEntry emoteSlot = Loadout_CharacterQuip( character, emoteIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), emoteSlot ) )
					entry.append( emoteSlot )
			}
			break

                
                         
          
        
                      

		default:
			Assert( 0, "Loot Ceremony equip button does not support reward type: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
	}

	return entry
}
#endif


#if CLIENT || UI
LoadoutEntry function PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( ItemFlavor item, bool findExistingEntry )
{
	ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
	if ( character == null )                                  
		character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( character )

	for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
	{
		LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
		ItemFlavor flavor        = LoadoutSlot_GetItemFlavor( LocalClientEHI(), trackerSlot )

		if ( findExistingEntry )
		{
			if ( flavor == item )
				return trackerSlot
		}
		else if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
		{
			if ( GladiatorCardTracker_IsTheEmpty( flavor ) )
				return trackerSlot
		}
	}

	LoadoutEntry fallback = Loadout_GladiatorCardStatTracker( character, (GLADIATOR_CARDS_NUM_TRACKERS - 1) )
	return fallback
}
#endif


#if CLIENT
void function UIToClient_RewardInspectNavBack_Threaded()
{
	if ( fileLevel.inspectMenuIsNavigatingBack )
		return

	fileLevel.inspectMenuIsNavigatingBack = true

	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	table<string, bool> success = { result = false }

	DisableInspectMenu()

	                       
	int attachID        = fileLevel.lootTickModel.LookupAttachment( "CAMERA" )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = fileLevel.lootTickModel.GetAttachmentAngles( attachID )

	fileLevel.cameraMover.NonPhysicsMoveTo( attachOrigin, INSPECT_ZOOM_TIME, 0, 0.1 )
	fileLevel.cameraMover.NonPhysicsRotateTo( attachAngles, INSPECT_ZOOM_TIME, 0, 0.1 )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_INSPECT_ZOOM_OUT )

	OnThreadEnd(
		function() : ( success )
		{
			if ( success[ "result" ] == false )
			{
				if ( !IsLootCeremonyActive() )
				{
					fileLevel.cameraMover.NonPhysicsStop()
					fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
					fileLevel.inspectMenuIsNavigatingBack = false
				}
			}
		}
	)

	wait INSPECT_ZOOM_TIME

	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	RunUIScript( "ClientToUI_ClearInspectModeIsActive" )
	RunUIScript( "ClientToUI_UpdateStoreButtonVisibility" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	EnableFakeInspectButtons()
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_RESETVIEW )
	fileLevel.inspectModeActive = false
	thread MythicUpdateAllEffects( true )

	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

	fileLevel.inspectMenuIsNavigatingBack = false
	success[ "result" ] = true
}
#endif


#if CLIENT
void function EnableInspectMenu()
{
	Hud_SetEnabled( fileLevel.inspectMenu, true )
	Hud_SetVisible( fileLevel.inspectMenu, true )
	RuiSetBool( Hud_GetRui( fileLevel.inspectMenu ), "isVisible", true )

	                                                                           
	                                                       

	Hud_SetEnabled( fileLevel.mouseClickElem, true )
	Hud_SetVisible( fileLevel.mouseClickElem, true )
}
#endif


#if CLIENT
void function DisableInspectMenu()
{
	Hud_SetEnabled( fileLevel.inspectMenu, false )
	Hud_SetVisible( fileLevel.inspectMenu, false )
	RuiSetBool( Hud_GetRui( fileLevel.inspectMenu ), "isVisible", false )

	Hud_SetEnabled( fileLevel.equipButton, false )
	Hud_SetVisible( fileLevel.equipButton, false )

	Hud_SetEnabled( fileLevel.trackChallengeButton, false )
	Hud_SetVisible( fileLevel.trackChallengeButton, false )

	Hud_SetVisible( fileLevel.equipToWheelButton, false )

	Hud_SetEnabled( fileLevel.mouseClickElem, false )
	Hud_SetVisible( fileLevel.mouseClickElem, false )

	Hud_SetEnabled( fileLevel.inspectVideoPanel, false )
	Hud_SetVisible( fileLevel.inspectVideoPanel, false )
}
#endif


const float INSPECT_FORWARD_OFFSET = 136.0
const float INSPECT_FORWARD_OFFSET_WEAPON = 100.0
const float INSPECT_FORWARD_OFFSET_CHARM = 45.0
const float INSPECT_FORWARD_OFFSET_EXECUTION = 100.0
const float INSPECT_FORWARD_OFFSET_CURRENCY = 100.0

const float INSPECT_RIGHT_OFFSET = -24.0
const float INSPECT_RIGHT_OFFSET_WEAPON = -18.0
const float INSPECT_RIGHT_OFFSET_CHARM = -7.5
const float INSPECT_RIGHT_OFFSET_EXECUTION = -20.0
const float INSPECT_RIGHT_OFFSET_CURRENCY = -20.0

const float INSPECT_UP_OFFSET = 30.0
const float INSPECT_UP_OFFSET_EXECUTION = 28.0
const float INSPECT_UP_OFFSET_CHARM = 30.0


#if CLIENT
table<string, vector> function RewardInspect_GetCameraOrgAnglesFromMenuButton( var menuButton )
{
	string menuButtonName = Hud_GetHudName( menuButton )
	int menuButtonIndex   = INSPECT_BUTTONS.find( menuButtonName )
	string attachment     = TICK_LOOT_ATTACHMENTS[menuButtonIndex]

	int itemType
	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == attachment )
		{
			itemType = ItemFlavor_GetType( data.item )
			break
		}
	}

	return RewardInspect_GetCameraOrgAngles( attachment, itemType )
}

table<string, vector> function RewardInspect_GetCameraOrgAngles( string attachment, int itemType )
{
	float forwardOffset
	float rightOffset
	float upOffset
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_WEAPON
		rightOffset = INSPECT_RIGHT_OFFSET_WEAPON
		upOffset = INSPECT_UP_OFFSET
	}
	else if ( itemType == eItemType.weapon_charm )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CHARM
		rightOffset = INSPECT_RIGHT_OFFSET_CHARM
		upOffset = INSPECT_UP_OFFSET_CHARM
	}
	else if ( itemType == eItemType.character_execution )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_EXECUTION
		rightOffset = INSPECT_RIGHT_OFFSET_EXECUTION
		upOffset = INSPECT_UP_OFFSET_EXECUTION
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CURRENCY
		rightOffset = INSPECT_RIGHT_OFFSET_CURRENCY
		upOffset = INSPECT_UP_OFFSET
	}
	else
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = INSPECT_RIGHT_OFFSET
		upOffset = INSPECT_UP_OFFSET
	}

	int attachID        = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

	vector offsetRight   = (AnglesToRight( attachAngles ) * rightOffset)
	vector offsetForward = (AnglesToForward( attachAngles ) * forwardOffset)
	vector zoomOrigin    = attachOrigin + offsetRight + offsetForward + <0, 0, upOffset>

	table<string, vector> zoomOrgAngles = {
		origin = zoomOrigin,
		angles = VectorToAngles( FlattenVec( attachOrigin - fileLevel.cameraMover.GetOrigin() ) )
	}

	return zoomOrgAngles
}

table<string, vector> function Inspect_GetCameraOrgAngles( string attachment, int itemType )
{
	float forwardOffset
	float rightOffset
	float upOffset
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = 26
	}
	else if ( itemType == eItemType.character_execution )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = 18
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CURRENCY
		rightOffset = 0
		upOffset = INSPECT_UP_OFFSET
	}
	else if ( itemType == eItemType.character_skin )
	{
		forwardOffset = 212
		rightOffset = 0
		upOffset = 20
	}
	else
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = INSPECT_UP_OFFSET
	}

	int attachID        = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

	vector offsetRight   = (AnglesToRight( attachAngles ) * rightOffset)
	vector offsetForward = (AnglesToForward( attachAngles ) * forwardOffset)
	vector zoomOrigin    = attachOrigin + offsetRight + offsetForward + <0, 0, upOffset>

	table<string, vector> zoomOrgAngles = {
		origin = zoomOrigin,
		angles = VectorToAngles( FlattenVec( attachOrigin - fileLevel.cameraMover.GetOrigin() ) )
	}

	return zoomOrgAngles
}
#endif


#if CLIENT
bool function ShouldShowControlHintsForItemType( int itemType )
{
	switch( itemType )
	{
		case eItemType.account_currency_bundle:
		case eItemType.character_skin:
		case eItemType.weapon_skin:
		case eItemType.melee_skin:
		case eItemType.character_execution:
		case eItemType.weapon_charm:
			return true
	}

	return false
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_WeaponSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( WeaponSkin_GetWeaponFlavor( item ) ) )
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_MeleeSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( MeleeSkin_GetCharacterFlavor( item ) ) )
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_CharacterSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( CharacterSkin_GetCharacterFlavor( item ) ) )
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails_CharacterEmote( ItemFlavor item, int rarity, int quantity )
{
	ItemFlavor ornull char = CharacterQuip_GetCharacterFlavor( item )

	if ( char == null )
		PopulateInspectMenuDetails( item, rarity, 1 )
	else
	{
		expect ItemFlavor( char )
		PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( char ) )
	}
}
#endif


#if CLIENT
void function PopulateInspectMenuDetails( ItemFlavor item, int rarity, int quantity, string miscString = "", string descString = "" )
{
	int itemType = ItemFlavor_GetType( item )

	var rui             = Hud_GetRui( fileLevel.inspectMenu )
	string itemTypeName = ItemFlavor_GetTypeName( item )
	string itemName     = "?"
	RuiSetInt( rui, "mythicTier", -1 )

	if ( itemType == eItemType.gladiator_card_stat_tracker )
	{
		itemName = Localize( ItemFlavor_GetShortName( item ) )
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
		itemTypeName = ItemFlavor_GetShortName( currencyFlav )
		itemName = Localize( "#CURRENCY_AMOUNT", string( ItemFlavor_GetIcon( currencyFlav ) ), GRXCurrencyBundle_GetValue( item ) )
	}
	else if ( itemType == eItemType.account_currency )
	{
		itemTypeName = ItemFlavor_GetShortName( item )
		itemName = Localize( "#CURRENCY_AMOUNT", string( ItemFlavor_GetIcon( item ) ), quantity )
	}
	else if ( itemType == eItemType.account_pack )
	{
		itemName = Localize( ItemFlavor_GetLongName( item ) )
		if ( quantity != 1 )
			itemName += " x" + quantity
	}
	else if ( itemType == eItemType.voucher )
	{
		itemTypeName = ItemFlavor_GetLongName( item )
		itemName = ""
	}
	else if ( Mythics_IsItemFlavorMythicSkin( item ) )
	{
		int mythicTier = Mythics_GetSkinTierIntForSkin( item )
		RuiSetInt( rui, "mythicTier", mythicTier )
		itemName = Localize( ItemFlavor_GetLongName( item ) )
		itemTypeName = Localize( "#MYTHIC_SKIN" )
	}
	else
	{
		itemName = Localize( ItemFlavor_GetLongName( item ) )
	}

	if ( itemType == eItemType.gladiator_card_badge || itemType == eItemType.gladiator_card_stat_tracker )
	{
		descString = ""
	}

	RuiSetString( rui, "itemType", itemTypeName )
	RuiSetString( rui, "itemName", itemName )
	RuiSetInt( rui, "rarity", rarity )
	RuiSetString( rui, "miscText", miscString )
	RuiSetString( rui, "descText", descString )
	RuiSetBool( rui, "showControlsHints", ShouldShowControlHintsForItemType( itemType ) )

	                                                     
	RuiSetFloat( rui, "descTextPositionScalar", ((itemType == eItemType.gladiator_card_stat_tracker) ? 1.0 : 0.0) )


	                                              
	if ( itemType != eItemType.account_currency_bundle )
		RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( item ) )

	               
	fileLevel.equipButtonItemFlavor = item
	var equipButtonRui = Hud_GetRui( fileLevel.equipButton )

	                        
	if ( Mythics_IsItemFlavorMythicSkin( item ) )
	{
		var trackButtonRui = Hud_GetRui( fileLevel.trackChallengeButton )

		ItemFlavor challenge = Mythics_GetChallengeForSkin( item )
		bool isChallengeTracked = IsFavoriteChallenge( challenge )
		RuiSetString( trackButtonRui, "buttonText", isChallengeTracked ?  "#CHALLENGE_TRACKED" : "#CHALLENGE_TRACK" )
		RuiSetBool( trackButtonRui, "isChallengeTracked", isChallengeTracked )
		fileLevel.trackButtonItemFlavor = item
		Hud_SetVisible( fileLevel.trackChallengeButton, true )
		Hud_SetEnabled( fileLevel.trackChallengeButton, true )
	}
	else
	{

		Hud_SetVisible( fileLevel.trackChallengeButton, false )
	}

	Hud_SetVisible( fileLevel.equipToWheelButton, false )

	array<int> hideItemList = [
		eItemType.weapon_charm,
		eItemType.skydive_emote,
		eItemType.account_pack,
		eItemType.account_currency,
		eItemType.account_currency_bundle,
		eItemType.voucher,
		eItemType.emote_icon,
		eItemType.character_emote,
                
                    
                      
	]

	bool hasValidCharacterOrWeapon = ( GetItemFlavorAssociatedCharacterOrWeapon( item ) != null )                                                                      

	if ( hideItemList.contains(itemType) )
	{
		Hud_SetVisible( fileLevel.equipButton, false )
		Hud_SetEnabled( fileLevel.equipButton, false )

		if ( ItemFlavor_CanEquipToWheel( item ) )
		{
			bool isOwned = GRX_IsItemOwnedByPlayer( item, GetLocalClientPlayer() )
			if ( isOwned && hasValidCharacterOrWeapon )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, true )
				Hud_SetLocked( fileLevel.equipToWheelButton, false )

				var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
				string equipTip = ItemFlavor_GetType( item ) == eItemType.skydive_emote ? "#EQUIP_SKYDIVE_WHEEL_REWARD" : "#EQUIP_WHEEL_LOOT_REWARD"
				RuiSetString( equipWheelButtonRui, "buttonText", equipTip )
				RuiSetString( equipWheelButtonRui, "descText", "" )
			}
			else if ( isOwned && ! hasValidCharacterOrWeapon )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, false )
				Hud_SetLocked( fileLevel.equipToWheelButton, true )

				var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
				RuiSetString( equipWheelButtonRui, "buttonText", "#UNLOCKED" )
				RuiSetString( equipWheelButtonRui, "descText", "#EQUIP_IN_LEGENDS_MENU" )
			}
		}
	}
	else if ( IsItemEquipped( item ) )
	{
		Hud_SetVisible( fileLevel.equipButton, true )

		if ( ItemFlavor_CanEquipToWheel( item ) && hasValidCharacterOrWeapon )
		{
			Hud_SetVisible( fileLevel.equipToWheelButton, true )
			Hud_SetEnabled( fileLevel.equipToWheelButton, true )
			Hud_SetLocked( fileLevel.equipToWheelButton, false )

			var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
			string equipTip = ItemFlavor_GetType( item ) == eItemType.skydive_emote ? "#EQUIP_SKYDIVE_WHEEL_REWARD" : "#EQUIP_WHEEL_LOOT_REWARD"
			RuiSetString( equipWheelButtonRui, "buttonText", equipTip )
			RuiSetString( equipWheelButtonRui, "descText", "" )
		}

		Hud_SetEnabled( fileLevel.equipButton, true )
		Hud_SetLocked( fileLevel.equipButton, true )

		RuiSetString( equipButtonRui, "buttonText", "#EQUIPPED_LOOT_REWARD" )
		RuiSetString( equipButtonRui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( ItemFlavor_GetLongName( item ) ) ) )
		RuiSetInt( equipButtonRui, "descTextRarity", rarity )
	}
	else
	{
		RuiSetString( equipButtonRui, "buttonText", "#EQUIP_LOOT_REWARD" )
		RuiSetString( equipButtonRui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( GetCurrentlyEquippedItemNameForItemTypeSlot( item ) ) ) )
		RuiSetInt( equipButtonRui, "descTextRarity", GetCurrentlyEquippedItemRarityForItemTypeSlot( item ) )

		if ( !Hud_IsVisible( Hud_GetChild( fileLevel.menu, "InspectPurchaseButton" ) ) )
		{
			Hud_SetVisible( fileLevel.equipButton, true )

			if ( ItemFlavor_CanEquipToWheel( item ) && hasValidCharacterOrWeapon )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, true )
				Hud_SetLocked( fileLevel.equipToWheelButton, false )

				var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
				string equipTip = ItemFlavor_GetType( item ) == eItemType.skydive_emote ? "#EQUIP_SKYDIVE_WHEEL_REWARD" : "#EQUIP_WHEEL_LOOT_REWARD"
				RuiSetString( equipWheelButtonRui, "buttonText", equipTip )
				RuiSetString( equipWheelButtonRui, "descText", "" )
			}

			Hud_SetEnabled( fileLevel.equipButton, true )
			Hud_SetLocked( fileLevel.equipButton, false )

			if( Mythics_IsItemFlavorMythicSkin( item ) && Mythics_GetSkinTierIntForSkin( item ) > 1)
			{
				Hud_SetLocked( fileLevel.equipButton, true )
				RuiSetString( equipButtonRui, "buttonText", "#EQUIP_LOCKED")
				RuiSetString( equipButtonRui, "descText", "#CHALLENGE_MYTHIC_LOCKED_ICON")
			}
		}
	}
}
#endif


#if CLIENT || UI
bool function IsItemEquipped( ItemFlavor item )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item, true )
	foreach ( entry in entries )
	{
		if ( item == LoadoutSlot_GetItemFlavor( LocalClientEHI(), entry ) )
			return true
	}

	return false
}
#endif


#if CLIENT || UI
string function GetCurrentlyEquippedItemNameForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )
	return ItemFlavor_GetLongName( equippedItem )
}
#endif


#if CLIENT || UI
int function GetCurrentlyEquippedItemRarityForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )

	if ( ItemFlavor_HasQuality( equippedItem ) )
		return ItemFlavor_GetQuality( equippedItem )

	return -1
}
#endif


#if CLIENT
void function ClearInspectMenuDetails()
{
	var rui = Hud_GetRui( fileLevel.inspectMenu )
	RuiSetString( rui, "itemType", "#UNKNOWN_LOOT_REWARD" )
	RuiSetString( rui, "itemName", "#UNKNOWN_LOOT_REWARD" )
	RuiSetString( rui, "miscText", "" )
	RuiSetInt( rui, "rarity", 0 )
}
#endif


#if CLIENT
void function InspectMenuFunctionality_Model( ItemFlavor item, int displayIndex, int rarity, int quantity, entity model, entity mover, vector startAngles, float maxYaw )
{
	int itemType = ItemFlavor_GetType( item )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			HideEntityAndChildren( model )
			mover.NonPhysicsStop()
		}
		else
		{
			                                                                                       
			if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
			{
				HideEntityAndChildren( model )
				mover.NonPhysicsStop()
			}

			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
				{
					if ( itemType == eItemType.weapon_skin )
						PopulateInspectMenuDetails_WeaponSkin( item, rarity, quantity )
					else if ( itemType == eItemType.melee_skin )
						PopulateInspectMenuDetails_MeleeSkin( item, rarity, quantity )

					mover.SetAngles( startAngles )
					mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
					ShowEntityAndChildren( model )

					vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
					thread FlashMenuModel( model, eMenuModelFlashType.LOOT_CEREMONY_QUICK, flashColor )
				}
				else if ( itemType == eItemType.character_skin )
				{
					PopulateInspectMenuDetails_CharacterSkin( item, rarity, 1 )
				}
				else if ( itemType == eItemType.account_currency_bundle )
				{
					PopulateInspectMenuDetails( item, rarity, quantity, "", "#CURRENCY_CRAFTING_DESCRIPTION" )
				}
				else if ( itemType == eItemType.account_currency )
				{
					PopulateInspectMenuDetails( item, rarity, quantity, "", ItemFlavor_GetLongDescription( item ) )
				}
				else if ( itemType == eItemType.character_emote )
				{
					PopulateInspectMenuDetails_CharacterEmote( item, rarity, 1 )
				}
				else
				{
					PopulateInspectMenuDetails( item, rarity, 1 )
				}

				waitthread TurntableModelController( model, mover, itemType, null, maxYaw )
			}
			else
			{
				HideEntityAndChildren( model )
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		mover.SetAngles( startAngles )

		if ( itemType == eItemType.character_emote )
		{
			model.Anim_Stop()
			thread ModelPerformEmote( model, item, mover, false )
		}

		ShowEntityAndChildren( model )

		vector flashColor    = ItemFlavor_GetQualityColor( item ) / 255
		bool includeChildren = true
		bool depthDiscard = false
                  
                                                                 
                        
		thread FlashMenuModel( model, eMenuModelFlashType.LOOT_CEREMONY_QUICK, flashColor, includeChildren, depthDiscard )

		if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin || itemType == eItemType.account_currency_bundle )
			mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_Model( ItemFlavor item, int rarity, int quantity, vector angles, entity mover, entity model, float maxYaw )
{
	int itemType = ItemFlavor_GetType( item )

	if ( itemType == eItemType.weapon_skin )
	{
		PopulateInspectMenuDetails_WeaponSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.melee_skin )
	{
		PopulateInspectMenuDetails_MeleeSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.character_skin )
	{
		PopulateInspectMenuDetails_CharacterSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		PopulateInspectMenuDetails( item, rarity, quantity, "", "#CURRENCY_CRAFTING_DESCRIPTION" )
	}
	else if ( itemType == eItemType.account_currency )
	{
		PopulateInspectMenuDetails( item, rarity, quantity, "", ItemFlavor_GetLongDescription( item ) )
	}
	else
	{
		PopulateInspectMenuDetails( item, rarity, quantity )
	}

	waitthread TurntableModelController( model, mover, itemType, null, maxYaw )
}
#endif


const float EXECUTION_START_VIDEO_DELAY = 0.25
const float EXECUTION_START_TURNTABLE_DELAY = 0.15


#if CLIENT
void function InspectMenuFunctionality_Execution( ItemFlavor item, int displayIndex, int rarity, entity attackerModel, entity victimModel, entity mover, vector startAngles )
{
	int itemType         = ItemFlavor_GetType( item )
	var rui              = Hud_GetRui( fileLevel.inspectVideoPanel )
	string characterName = ItemFlavor_GetShortName( CharacterExecution_GetCharacterFlavor( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			HideEntityAndChildren( attackerModel )
			HideEntityAndChildren( victimModel )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, characterName )

				int attachIDAttacker = attackerModel.LookupAttachment( "ORIGIN" )
				int attachIDVictim   = victimModel.LookupAttachment( "ORIGIN" )
				int fxIndexAttacker  = StartParticleEffectOnEntity( attackerModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDAttacker )
				int fxIndexVictim    = StartParticleEffectOnEntity( victimModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDVictim )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( EXECUTION_START_VIDEO_DELAY )

				HideEntityAndChildren( attackerModel )
				HideEntityAndChildren( victimModel )

				if ( delayCompleted )
				{
					Hud_SetVisible( fileLevel.inspectVideoPanel, true )
					Hud_SetEnabled( fileLevel.inspectVideoPanel, true )

					int videoChannel = ReserveVideoChannel( ExecutionVideoOnFinished )
					RuiSetInt( rui, "channel", videoChannel )
					StartVideoOnChannel( videoChannel, CharacterExecution_GetExecutionVideo( item ), false, 0.0 )

					bool videoCompleted = WaitForInspectVideoCompleteOrBackout()

					Hud_SetVisible( fileLevel.inspectVideoPanel, false )
					Hud_SetEnabled( fileLevel.inspectVideoPanel, false )

					ReleaseVideoChannel( videoChannel )

					if ( videoCompleted )
					{
						bool secondDelayCompleted = WaitForInspectTimeCompleteOrBackout( EXECUTION_START_TURNTABLE_DELAY )

						if ( secondDelayCompleted )
						{
							ShowEntityAndChildren( attackerModel )
							ShowEntityAndChildren( victimModel )

							int flashType     = eMenuModelFlashType.LOOT_CEREMONY_QUICK
							vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
							thread FlashMenuModel( attackerModel, flashType, flashColor )
							thread FlashMenuModel( victimModel, flashType, flashColor )

							mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
							waitthread TurntableModelController( attackerModel, mover, itemType, victimModel )
						}
					}
				}
				else
				{
					if ( EffectDoesExist( fxIndexAttacker ) )
						EffectStop( fxIndexAttacker, true, false )

					if ( EffectDoesExist( fxIndexVictim ) )
						EffectStop( fxIndexVictim, true, false )
				}
			}
			else
			{
				HideEntityAndChildren( attackerModel )
				HideEntityAndChildren( victimModel )
			}

			ClearInspectMenuDetails()
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		mover.NonPhysicsStop()
		mover.SetAngles( startAngles )
		ShowEntityAndChildren( attackerModel )
		ShowEntityAndChildren( victimModel )

		int flashType     = eMenuModelFlashType.LOOT_CEREMONY_QUICK
		vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
		thread FlashMenuModel( attackerModel, flashType, flashColor )
		thread FlashMenuModel( victimModel, flashType, flashColor )
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_Execution( ItemFlavor item, int rarity, entity attackerModel, entity victimModel, entity mover )
{
	int itemType         = ItemFlavor_GetType( item )
	var rui              = Hud_GetRui( fileLevel.inspectVideoPanel )
	string characterName = ItemFlavor_GetShortName( CharacterExecution_GetCharacterFlavor( item ) )

	PopulateInspectMenuDetails( item, rarity, 1, characterName )

	wait 1

	int attachIDAttacker = attackerModel.LookupAttachment( "ORIGIN" )
	int attachIDVictim   = victimModel.LookupAttachment( "ORIGIN" )
	int fxIndexAttacker  = StartParticleEffectOnEntity( attackerModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDAttacker )
	int fxIndexVictim    = StartParticleEffectOnEntity( victimModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDVictim )

	wait EXECUTION_START_VIDEO_DELAY

	HideEntityAndChildren( attackerModel )
	HideEntityAndChildren( victimModel )

	Hud_SetVisible( fileLevel.inspectVideoPanel, true )
	Hud_SetEnabled( fileLevel.inspectVideoPanel, true )

	int videoChannel = ReserveVideoChannel( ExecutionVideoOnFinished )
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, CharacterExecution_GetExecutionVideo( item ), false, 0.0 )

	bool videoCompleted = WaitForInspectVideoCompleteOrBackout()

	Hud_SetVisible( fileLevel.inspectVideoPanel, false )
	Hud_SetEnabled( fileLevel.inspectVideoPanel, false )

	ReleaseVideoChannel( videoChannel )

	wait EXECUTION_START_TURNTABLE_DELAY

	ShowEntityAndChildren( attackerModel )
	ShowEntityAndChildren( victimModel )

	int flashType     = eMenuModelFlashType.LOOT_CEREMONY_QUICK
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( attackerModel, flashType, flashColor )
	thread FlashMenuModel( victimModel, flashType, flashColor )

	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	waitthread TurntableModelController( attackerModel, mover, itemType, victimModel )
}
#endif


#if CLIENT
void function ExecutionVideoOnFinished( int channel )
{
	Signal( fileLevel.signalDummy, "LootCeremonyVideoComplete" )
}
#endif


#if CLIENT
void function InspectMenuFunctionality_RUI( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel = null, string descString = "" )
{
	int itemType    = ItemFlavor_GetType( item )
	string nameText = ""

	switch ( itemType )
	{
		case eItemType.gladiator_card_stat_tracker:
			if ( GladiatorCardStatTracker_GetCharacterFlavor( item ) != null )
			{
				nameText = ItemFlavor_GetShortName( expect ItemFlavor(GladiatorCardStatTracker_GetCharacterFlavor( item )))
			}
			break
	}

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		                              
		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )

			if ( IsValid( bgModel ) )
				bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText, descString )

				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				RuiSetBool( rui, "isVisible", false )

				if ( IsValid( bgModel ) )
					bgModel.Hide()

				ClearInspectMenuDetails()
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )

				if ( IsValid( bgModel ) )
					bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )

		if ( IsValid( bgModel ) )
			bgModel.Show()
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_RUI( ItemFlavor item, int rarity, var rui, string descString = "" )
{
	int itemType    = ItemFlavor_GetType( item )
	string nameText = ""

	switch ( itemType )
	{
		case eItemType.gladiator_card_stat_tracker:
			if ( GladiatorCardStatTracker_GetCharacterFlavor( item ) == null )
			{
				break
			}

			nameText = ItemFlavor_GetShortName( expect ItemFlavor( GladiatorCardStatTracker_GetCharacterFlavor( item ) ) )
			break
	}

	PopulateInspectMenuDetails( item, rarity, 1, nameText, descString )

	WaitForever()
}
#endif


const float QUIP_START_AUDIO_DELAY = 0.25


#if CLIENT
void function InspectMenuFunctionality_Quip( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText  = ""
	string quipAlias = ""
	if ( itemType == eItemType.gladiator_card_kill_quip )
	{
		quipAlias = CharacterKillQuip_GetVictimVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterKillQuip_GetCharacterFlavor( item ) )
	}
	else
	{
		quipAlias = CharacterIntroQuip_GetVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterIntroQuip_GetCharacterFlavor( item ) )
	}

	if ( quipAlias == "" )
		Warning( "Quip sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )
			bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( QUIP_START_AUDIO_DELAY )

				if ( delayCompleted )
				{
					if ( quipAlias != "" )
						RunUIScript( "ClientToUI_PlayLootCeremonySound", quipAlias )

					WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

					if ( quipAlias != "" )
						RunUIScript( "ClientToUI_StopLootCeremonySound", quipAlias )

					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
					ClearInspectMenuDetails()
				}
				else
				{
					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
				}
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
				bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )
		bgModel.Show()
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_Quip( ItemFlavor item, int rarity, var rui )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText  = ""
	string quipAlias = ""
	if ( itemType == eItemType.gladiator_card_kill_quip )
	{
		quipAlias = CharacterKillQuip_GetVictimVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterKillQuip_GetCharacterFlavor( item ) )
	}
	else
	{
		quipAlias = CharacterIntroQuip_GetVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterIntroQuip_GetCharacterFlavor( item ) )
	}

	if ( quipAlias == "" )
		Warning( "Quip sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	OnThreadEnd(
		function() : ( quipAlias )
		{
			if ( quipAlias != "" )
				RunUIScript( "ClientToUI_StopLootCeremonySound", quipAlias )
		}
	)

	PopulateInspectMenuDetails( item, rarity, 1, nameText )

	wait 0.75

	if ( quipAlias != "" )
		RunUIScript( "ClientToUI_PlayLootCeremonySound", quipAlias )

	WaitForever()
}
#endif


#if CLIENT
void function InspectMenuFunctionality_MusicPack( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel )
{
	string nameText = ItemFlavor_GetShortName( item )
	string previewAlias = MusicPack_GetPreviewMusic( item )

	if ( previewAlias == "" )
		Warning( "Music pack sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	while ( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )
			bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( QUIP_START_AUDIO_DELAY )

				if ( delayCompleted )
				{
					if ( previewAlias != "" )
						RunUIScript( "ClientToUI_PlayLootCeremonySound", previewAlias )

					WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

					if ( previewAlias != "" )
						RunUIScript( "ClientToUI_StopLootCeremonySound", previewAlias )

					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
					ClearInspectMenuDetails()
				}
				else
				{
					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
				}
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
				bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )
		bgModel.Show()
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_MusicPack( ItemFlavor item, int rarity, var rui )
{
	string nameText = ItemFlavor_GetShortName( item )
	string previewAlias = MusicPack_GetPreviewMusic( item )

	if ( previewAlias == "" )
		Warning( "Music pack sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	OnThreadEnd(
		function() : ( previewAlias )
		{
			if ( previewAlias != "" )
				RunUIScript( "ClientToUI_StopLootCeremonySound", previewAlias )
		}
	)

	PopulateInspectMenuDetails( item, rarity, 1, nameText )

	wait 0.75

	if ( previewAlias != "" )
		RunUIScript( "ClientToUI_PlayLootCeremonySound", previewAlias )

	WaitForever()
}
#endif


#if CLIENT
void function InspectMenuFunctionality_GladiatorCard( ItemFlavor item, int itemType, vector origin, vector angles, int displayIndex, int rarity, GladiatorCardData gCardData )
{
	table <string, GladiatorCardData> gCardDataTracker = { data = gCardData }
	OnThreadEnd(
		function() : ( gCardDataTracker )
		{
			ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
		}
	)

	string characterName
	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
		if ( character == null )
		{
			characterName = "#REWARD_GENERIC"
		}
		else
		{
			expect ItemFlavor( character )
			characterName = ItemFlavor_GetShortName( character )
		}
	}
	else
	{
		characterName = ItemFlavor_GetShortName( GladiatorCardStance_GetCharacterFlavor( item ) )
	}

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		                              
		if ( !activelyInspecting )
		{
			ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( !inspectComplete )
			{
				ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
			}
			else
			{
				PopulateInspectMenuDetails( item, rarity, 1, characterName )

				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )

				ClearInspectMenuDetails()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		                                  
		gCardDataTracker.data = ShowRewards_GladiatorCard_Create( item, itemType, false, rarity, origin, angles )
	}
}
#endif


#if CLIENT
void function SpecialItemPresentationView_GladiatorCard( ItemFlavor item, int itemType, int rarity, GladiatorCardData gCardData )
{
	OnThreadEnd(
		function() : ( gCardData )
		{
			ShowRewards_GladiatorCard_Destroy( gCardData )
		}
	)

	string characterName
	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
		if ( character == null )
		{
			characterName = "#REWARD_GENERIC"
		}
		else
		{
			expect ItemFlavor( character )
			characterName = ItemFlavor_GetShortName( character )
		}
	}
	else
	{
		characterName = ItemFlavor_GetShortName( GladiatorCardStance_GetCharacterFlavor( item ) )
	}

	PopulateInspectMenuDetails( item, rarity, 1, characterName )

	WaitForever()
}
#endif


#if CLIENT
void function InspectMenuFunctionality_FXBeams( int displayIndex, int fxIndexRarity, table<string, int> fxTrackerBeam, int animAttachID, vector rarityColor )
{
	OnThreadEnd(
		function() : ( fxIndexRarity, fxTrackerBeam )
		{
			if ( EffectDoesExist( fxIndexRarity ) )
				EffectStop( fxIndexRarity, true, false )

			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
	)

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton    = expect string( results.inspectButton )
		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		                            
		if ( !activelyInspecting )
		{
			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( !inspectComplete )
			{
				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
			else
			{
				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		int newFxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
		EffectSetControlPointVector( newFxIndexBeam, 1, rarityColor )
		fxTrackerBeam[ "fxID" ] = newFxIndexBeam
	}
}
#endif


const float TURNTABLE_MAX_TURN_DEGREES = 360.0
const float TURNTABLE_MAX_PITCH_DEGREES_WEAPON = 60.0


#if CLIENT
void function TurntableModelController( entity model, entity mover, int itemType, entity additionalModel = null, float maxYaw = TURNTABLE_MAX_TURN_DEGREES )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	MenuModelData modelData
	ModelData_SetMover( modelData, mover )
	ModelData_SetBaseAngles( modelData, <0, fileLevel.cameraMover.GetAngles().y + 90, 0> )
	ModelData_SetModel( modelData, model )
	float[2] delta = [0.0, 0.0]
	modelData.rotationDelta[0] = delta[0]
	modelData.rotationDelta[1] = delta[1]

	vector focalPoint = model.GetOrigin()
	float zoomMinDist = 0.0
	float zoomMaxDist = 64.0
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "MENU_ROTATE" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.weapon_charm )
	{
		focalPoint = GetCharmForWeaponEntity( model ).GetWorldSpaceCenter()
		zoomMinDist = 0.0
		zoomMaxDist = 30.0
	}
	else if ( itemType == eItemType.character_skin )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 64.0
	}
	else if ( itemType == eItemType.character_execution )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.account_pack )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		focalPoint = model.GetOrigin()
		zoomMaxDist = 38.0
	}
	else if ( itemType == eItemType.emote_icon )
	{
		zoomMaxDist = 0.0
	}

	CameraZoomData cameraData
	cameraData.mover = fileLevel.cameraMover
	vector camPos = fileLevel.cameraMover.GetOrigin()
	cameraData.startPos = camPos + (Normalize( focalPoint - camPos ) * zoomMinDist)
	cameraData.endPos = camPos + (Normalize( focalPoint - camPos ) * zoomMaxDist)
	cameraData.maxDist = Distance( cameraData.startPos, cameraData.endPos )
	cameraData.normVec = Normalize( cameraData.endPos - cameraData.startPos )

	thread CameraZoomThread( cameraData )

	OnThreadEnd(
		function() : ( model, additionalModel )
		{
			CameraZoomThreadEnd()

			HideEntityAndChildren( model )

			if ( IsValid( additionalModel ) )
				HideEntityAndChildren( additionalModel )

			ClearInspectMenuDetails()
		}
	)

	float maxPitchDegrees = 0.0
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.weapon_charm || itemType == eItemType.melee_skin )
		maxPitchDegrees = TURNTABLE_MAX_PITCH_DEGREES_WEAPON

	bool hasStopped = false

	while( true )
	{
		bool hasPlayerTurned = TurntableUpdateAnglesFromInput( modelData, maxYaw, maxPitchDegrees, !hasStopped )

		if ( !hasStopped && hasPlayerTurned )
		{
			if ( itemType != eItemType.character_skin )
				mover.NonPhysicsStop()

			hasStopped = true
		}

		WaitFrame()
	}
}
#endif


#if CLIENT
bool function WaitForInspectCompleteOrBackout()
{
	array<string> signalsToWait = ["LootCeremonyInspectModeStartComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyInspectModeStartComplete" )
		return true

	return false
}
#endif


#if CLIENT
bool function WaitForInspectTimeCompleteOrBackout( float timeToWait )
{
	thread WaitForTimeComplete( timeToWait )
	array<string> signalsToWait = ["LootCeremonyTimeComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectTimeCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyTimeComplete" )
		return true

	return false
}
#endif


#if CLIENT
bool function WaitForInspectVideoCompleteOrBackout()
{
	array<string> signalsToWait = ["LootCeremonyVideoComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectVideoCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyVideoComplete" )
		return true

	return false
}
#endif


#if CLIENT
void function WaitForTimeComplete( float timeToWait )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	wait timeToWait

	Signal( fileLevel.signalDummy, "LootCeremonyTimeComplete" )
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                 
                                              
                                              
                                              
                                              
                                              
                                              
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if UI
void function InitLootBoxMenu( var newMenuArg )
                                              
{
	var menu = GetMenu( "LootBoxOpen" )
	fileForever.menu = menu
	fileForever.blackFlash = Hud_GetChild( fileForever.menu, "BlackFlash" )

	AddMenuEventHandler( menu, eUIEvent.MENU_OPEN, OnLootBoxMenu_Open )
	AddMenuEventHandler( menu, eUIEvent.MENU_CLOSE, OnLootBoxMenu_Close )
	AddMenuEventHandler( menu, eUIEvent.MENU_NAVIGATE_BACK, OnLootBoxMenu_NavBack )

	AddMenuFooterOption( menu, LEFT, BUTTON_B, true, "#B_BUTTON_BACK", "#B_BUTTON_BACK", null, ShouldShowBackButton )

	        
	fileForever.storeButton = Hud_GetChild( menu, "StoreButton" )
	HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#STORE_MENU" ) )
	AddButtonEventHandler( fileForever.storeButton, UIE_CLICK, OnClickStoreButton )

	                       
	fileForever.lootBoxOpenButton = Hud_GetChild( fileForever.menu, "OpenLootBoxButton" )
	HudElem_SetRuiArg( fileForever.lootBoxOpenButton, "buttonText", Localize( "#OPEN_NEXT_LOOT" ) )
	HudElem_SetRuiArg( fileForever.lootBoxOpenButton, "descText", "" )
	AddButtonEventHandler( fileForever.lootBoxOpenButton, UIE_CLICK, LootBoxOpenAdditional )

	               
	fileForever.inspectMenu = Hud_GetChild( fileForever.menu, "InspectBar" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "itemType", "#UNKNOWN_LOOT_REWARD" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "itemName", "#UNKNOWN_LOOT_REWARD" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "reqsText", "" )

	fileForever.equipButton = Hud_GetChild( fileForever.menu, "InspectEquipButton" )
	HudElem_SetRuiArg( fileForever.equipButton, "buttonText", Localize( "#EQUIP_LOOT_REWARD" ) )
	AddButtonEventHandler( fileForever.equipButton, UIE_CLICK, EquipButtonOnClick )

	fileForever.trackChallengeButton = Hud_GetChild( fileForever.menu, "TrackChallengeButton" )
	AddButtonEventHandler( fileForever.trackChallengeButton, UIE_CLICK, TrackButtonOnClick )

	fileForever.equipToWheelButton = Hud_GetChild( fileForever.menu, "InspectEquipToWheelButton" )
	HudElem_SetRuiArg( fileForever.equipToWheelButton, "buttonText", Localize( "#EQUIP_WHEEL_LOOT_REWARD" ) )
	HudElem_SetRuiArg( fileForever.equipToWheelButton, "descText", "" )
	AddButtonEventHandler( fileForever.equipToWheelButton, UIE_CLICK, EquipToWheelButtonOnClick )

	fileForever.purchaseButton = Hud_GetChild( fileForever.menu, "InspectPurchaseButton" )
	HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", "" )
	AddButtonEventHandler( fileForever.purchaseButton, UIE_CLICK, PurchaseButtonOnClick )

	fileForever.mouseClickElem = Hud_GetChild( fileForever.menu, "ModelRotateMouseCapture" )
	fileForever.inspectVideoPanel = Hud_GetChild( fileForever.menu, "InspectVideoPanel" )

	                           
	array<var> inspectRewardButtonArray
	fileForever.inspectRewardButton1 = Hud_GetChild( fileForever.menu, "RewardLeftButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton1 )

	fileForever.inspectRewardButton2 = Hud_GetChild( fileForever.menu, "RewardCenterButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton2 )

	fileForever.inspectRewardButton3 = Hud_GetChild( fileForever.menu, "RewardRightButton" )
	inspectRewardButtonArray.append( fileForever.inspectRewardButton3 )

	foreach ( var button in inspectRewardButtonArray )
	{
		AddButtonEventHandler( button, UIE_CLICK, PreviewButtonOnClick )
		AddButtonEventHandler( button, UIE_GET_FOCUS, PreviewButtonOnHover )
		AddButtonEventHandler( button, UIE_LOSE_FOCUS, PreviewButtonOnLeaveHover )
	}

	                        
	fileForever.skipAnimButton = Hud_GetChild( fileForever.menu, "SkipAnimationButton" )
	AddButtonEventHandler( fileForever.skipAnimButton, UIE_CLICK, SkipAnimButtonOnClick )

	AddUICallback_OnLevelInit( OnLevelInit )
}
#endif


#if UI
void function LootCeremony_UpdateOpenAdditionalButton()
{
	bool showButton = false
	                          

	if ( HasLootBeenPresented() && !IsInspectModeActive() && !IsSpecialItemPresentationModeActive() )
	{
		if ( GRX_IsInventoryReady() )
		{
			                                             
			showButton = true
			array<ItemFlavor> specificPackFlavs = []
			if ( fileLevel.forceParticularPackFlav != null )
				specificPackFlavs.append( expect ItemFlavor( fileLevel.forceParticularPackFlav ) )
			UpdateLootBoxButton( fileForever.lootBoxOpenButton, specificPackFlavs )
		}
	}

	Hud_SetVisible( fileForever.lootBoxOpenButton, showButton )
	                                                                
	                                                              
	if ( fileLevel.considerFocusOpenButton )
	{
		fileLevel.considerFocusOpenButton = false
		if ( showButton )
			Hud_SetFocused( fileForever.lootBoxOpenButton )
	}
}
#endif


#if UI
bool function HasLootBeenPresented()
{
	return fileLevel.lootHasBeenPresented
}
#endif


#if UI
void function OnLevelInit()
{
	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )
}
#endif


#if UI
void function ClientToUI_SetLootHasBeenPresented( bool heirloomShards = false )
{
	fileLevel.lootHasBeenPresented = true
	fileLevel.considerFocusOpenButton = true
	fileLevel.heirloomShards = heirloomShards
	UpdateFooterOptions()

	if ( !heirloomShards )
	{
		HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#APEX_PACKS" ) )
		HudElem_SetRuiArg( fileForever.storeButton, "icon", ItemFlavor_GetIcon( GRX_CURRENCIES[GRX_CURRENCY_PREMIUM] ) )
	}
	else
	{
		HudElem_SetRuiArg( fileForever.storeButton, "buttonText", Localize( "#HEIRLOOM_SHOP" ) )
		HudElem_SetRuiArg( fileForever.storeButton, "icon", ItemFlavor_GetIcon( GRX_CURRENCIES[GRX_CURRENCY_HEIRLOOM] ) )
	}
}
#endif


#if UI
void function ClientToUI_UpdateStoreButtonVisibility()
{
	bool visible = HasLootBeenPresented() && !IsInspectModeActive() && !IsSpecialItemPresentationModeActive()

	Hud_SetVisible( fileForever.storeButton, visible )
	Hud_SetEnabled( fileForever.storeButton, visible )

	entity player = GetLocalClientPlayer()
	if ( GRX_IsOfferRestricted( player ) && !fileLevel.heirloomShards )
	{
		Hud_SetEnabled( fileForever.storeButton, false )
	}
}
#endif


#if UI
bool function IsInspectModeActive()
{
	return fileLevel.inspectModeActive
}
#endif


#if CLIENT || UI
bool function IsSpecialItemPresentationModeActive()
{
	return fileLevel.specialItemPresentationModeActive
}
#endif


#if UI
void function ClientToUI_SetInspectModeIsActive()
{
	fileLevel.inspectModeActive = true
}
#endif


#if UI
void function ClientToUI_ClearInspectModeIsActive()
{
	fileLevel.inspectModeActive = false
}
#endif


#if UI
void function SetStoreItemPresentationModeActive( GRXScriptOffer grxOffer )
{
	Assert( grxOffer.output.flavors.len() == 1 )

	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = grxOffer
	fileLevel.specialItemPresentationModeItemFlav = grxOffer.output.flavors[0]
	fileLevel.specialItemPresentationModeItemQty = grxOffer.output.quantities[0]
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = grxOffer.prereq
	fileLevel.specialItemFormattedPrice = GRX_GetFormattedPrice( grxOffer.prices[0], 1 )
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = "#CONFIRM_PURCHASE_WITH"
	fileLevel.specialItemLockPurchaseButton = false
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetBattlePassItemPresentationModeActive( BattlePassReward bpReward )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = bpReward.flav
	fileLevel.specialItemPresentationModeItemQty = bpReward.quantity
	fileLevel.specialItemPresentationModeItemBadgeTier = (  ItemFlavor_GetQuality(bpReward.flav) > 2 && ItemFlavor_GetType( bpReward.flav ) == eItemType.gladiator_card_badge)? BATTLEPASS_MAX_LEVEL : -1                                       
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = bpReward.isPremium ? "#BATTLE_PASS_PREMIUM_REWARD" : "#BATTLE_PASS_FREE_REWARD"
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = !(IsItemFlavorEquippable( bpReward.flav ))
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = Localize( "#BATTLE_PASS_LEVEL_REQUIRED", bpReward.level + 1 )
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetTreasurePackItemPresentationModeActive( BattlePassReward bpReward )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = bpReward.flav
	fileLevel.specialItemPresentationModeItemQty = bpReward.quantity
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = bpReward.isPremium ? "#BATTLE_PASS_PREMIUM_REWARD" : "#BATTLE_PASS_FREE_REWARD"
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = !(IsItemFlavorEquippable( bpReward.flav ))
	fileLevel.specialItemHidePurchaseButton = true
	fileLevel.specialItemPriceHeader = Localize( "#BATTLE_PASS_LEVEL_REQUIRED", bpReward.level + 1 )
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetGenericItemPresentationModeActiveWithNavBack( ItemFlavor itemFlav, string priceHeader, string subHeader, void functionref() onNavigatingBackFunc )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = itemFlav
	fileLevel.specialItemPresentationModeItemQty = 1
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = subHeader
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemPriceHeader = priceHeader
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = onNavigatingBackFunc

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetCollectionEventItemPresentationModeActive( ItemFlavor flav, GRXScriptOffer ornull grxOffer, string ornull packName, asset ornull packImg )
{
	string priceText = ""
	if ( grxOffer != null )
	{
		expect GRXScriptOffer(grxOffer)
		array<string> formattedPrices
		foreach ( ItemFlavorBag price in grxOffer.prices )
			formattedPrices.append( GRX_GetFormattedPrice( price, 1 ) )

		if ( formattedPrices.len() == 1 )
			priceText = Localize( "#STORE_PRICE_N", formattedPrices[0] )
		else if ( formattedPrices.len() == 2 )
			priceText = Localize( "#STORE_PRICE_N_N", formattedPrices[0], formattedPrices[1] )
	}

	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = grxOffer
	fileLevel.specialItemPresentationModeItemFlav = flav
	fileLevel.specialItemPresentationModeItemQty = 1
	fileLevel.specialItemPresentationModeItemBadgeTier = -1
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemFormattedPrice = priceText
	fileLevel.specialItemOverrideOwned = null
	fileLevel.specialItemHideEquipButton = false
	fileLevel.specialItemHidePurchaseButton = (grxOffer == null)
	fileLevel.specialItemPriceHeader = "#PURCHASE"
	fileLevel.specialItemLockPurchaseButton = (grxOffer == null)
	fileLevel.specialItemPackName = packName
	fileLevel.specialItemPackImg = packImg
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

void function SetChallengeRewardPresentationModeActive( ItemFlavor itemFlav, int itemQty, int badgeDataInteger, string priceHeader, string subHeader, bool isComplete )
{
	fileLevel.specialItemPresentationModeActive = true
	fileLevel.storeItemPresentationModeOffer = null
	fileLevel.specialItemPresentationModeItemFlav = itemFlav
	fileLevel.specialItemPresentationModeItemQty = itemQty
	fileLevel.specialItemPresentationModeItemBadgeTier = badgeDataInteger
	fileLevel.storeItemPresentationModeItemPrereq = null
	fileLevel.specialItemOverrideOwned = isComplete
	fileLevel.specialItemHideEquipButton = !(IsItemFlavorEquippable( itemFlav ))
	fileLevel.specialItemHidePurchaseButton = false
	fileLevel.specialItemLockPurchaseButton = true
	fileLevel.specialItemPackName = null
	fileLevel.specialItemPackImg = null
	fileLevel.specialPurchaseDialogConfig = null
	fileLevel.onNavigatingBackFunc = null

	if( Mythics_IsItemFlavorMythicSkin( itemFlav ) )
	{
		fileLevel.specialItemPriceHeader = "#EQUIP_LOCKED"
		fileLevel.specialItemFormattedPrice = "#CHALLENGE_MYTHIC_LOCKED_ICON"
	}
	else
	{
		fileLevel.specialItemPriceHeader = priceHeader
		fileLevel.specialItemFormattedPrice = subHeader
	}

	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}

#endif


#if UI
bool function InspectItemTypePresentationSupported( ItemFlavor item )
{
	switch ( ItemFlavor_GetType( item ) )
	{
		case eItemType.account_currency_bundle:
		case eItemType.account_pack:
		case eItemType.character_skin:
		case eItemType.character_execution:
		case eItemType.weapon_skin:
		case eItemType.weapon_charm:
		case eItemType.melee_skin:
		case eItemType.gladiator_card_stance:
		case eItemType.gladiator_card_frame:
		case eItemType.gladiator_card_intro_quip:
		case eItemType.gladiator_card_kill_quip:
		case eItemType.gladiator_card_stat_tracker:
		case eItemType.gladiator_card_badge:
		case eItemType.music_pack:
		case eItemType.loadscreen:
		case eItemType.skydive_emote:
		case eItemType.emote_icon:
		case eItemType.character_emote:
                
                         
                      
			return true

		case eItemType.account_currency:
			return ItemFlavor_GetAsset( item ) != $"settings/itemflav/grx_currency/crafting.rpak"            

		case eItemType.voucher:
			return Voucher_GetModel( item ) != $""
	}

	return false
}
#endif



                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                                                                            
                                                                                                      
                                                                                                      
                                                                                                          
                                                                                                      
                                                                                                      
                                                                                                            
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if UI
void function OnLobbyOpenLootBoxMenu_ButtonPress( ItemFlavor ornull forceParticularPackFlav = null )
{
	fileLevel.forceParticularPackFlav = forceParticularPackFlav
	AdvanceMenu( GetMenu( "LootBoxOpen" ) )
}
#endif


#if UI
void function OnLootBoxMenu_Open()
{
	UI_SetPresentationType( ePresentationType.INACTIVE )
	thread LootCeremonyFlashScreenBlack_Internal()

	HudElem_SetRuiArg( fileForever.inspectMenu, "moveDescDown", false )
	HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", false )
	HudElem_SetRuiArg( fileForever.inspectMenu, "packName", "" )
	HudElem_SetRuiArg( fileForever.inspectMenu, "packImg", $"", eRuiArgType.IMAGE )

	if ( IsSpecialItemPresentationModeActive() )
	{
		AddCallbackAndCallNow_OnGRXInventoryStateChanged( UpdateSpecialItemPresentationPurchaseButton )
		AddCallbackAndCallNow_OnGRXOffersRefreshed( UpdateSpecialItemPresentationPurchaseButton )

		SpecialItemPresentationSequenceUI()
		LootCeremony_UpdateOpenAdditionalButton()
	}
	else
	{
		Hud_SetVisible( fileForever.purchaseButton, false )
		Hud_SetEnabled( fileForever.purchaseButton, false )

		AddCallbackAndCallNow_OnGRXInventoryStateChanged( LootCeremony_UpdateOpenAdditionalButton )
		thread LootBoxOpenSequenceUI( true )
	}
}
#endif


#if UI
void function OnLootBoxMenu_Close()
{
	fileLevel.forceParticularPackFlav = null
	if ( IsSpecialItemPresentationModeActive() )
	{
		fileLevel.specialItemPresentationModeActive = false
		RunClientScript( "UIToClient_SpecialItemPresentationExit" )

		RemoveCallback_OnGRXInventoryStateChanged( UpdateSpecialItemPresentationPurchaseButton )
		RemoveCallback_OnGRXOffersRefreshed( UpdateSpecialItemPresentationPurchaseButton )

		fileLevel.specialItemPresentationModeActive = false
		fileLevel.storeItemPresentationModeOffer = null
		                                                  
		fileLevel.specialItemPresentationModeItemQty = -1
		fileLevel.specialItemPresentationModeItemBadgeTier = -1
		fileLevel.storeItemPresentationModeItemPrereq = null
		fileLevel.specialItemFormattedPrice = ""
		fileLevel.specialItemOverrideOwned = null
		fileLevel.specialItemHideEquipButton = false
		fileLevel.specialItemHidePurchaseButton = false
		fileLevel.specialItemPriceHeader = ""
		fileLevel.specialItemLockPurchaseButton = false
		fileLevel.onNavigatingBackFunc = null
	}
	else
	{
		RunClientScript( "UIToClient_LootCeremonyExit" )
		RemoveCallback_OnGRXInventoryStateChanged( LootCeremony_UpdateOpenAdditionalButton )
	}
}
#endif


#if UI
bool function ShouldShowBackButton()
{
	if ( IsSpecialItemPresentationModeActive() )
		return true

	return HasLootBeenPresented()
}
#endif


#if UI
void function OnClickStoreButton( var button )
{
	if ( fileLevel.heirloomShards )
		JumpToHeirloomShop()
	else
		JumpToStorePacks()
}
#endif


#if UI
void function OnLootBoxMenu_NavBack()
{
	if ( !HasLootBeenPresented() && !IsSpecialItemPresentationModeActive() )
		return

	if ( IsInspectModeActive() && !IsSpecialItemPresentationModeActive() )
	{
		RunClientScript( "UIToClient_RewardInspectNavBack" )
		return
	}

	if ( IsSpecialItemPresentationModeActive() && (fileLevel.onNavigatingBackFunc != null) )
		fileLevel.onNavigatingBackFunc()

	CloseActiveMenu()
}
#endif


#if UI
void function LootBoxOpenAdditional( var button )
{
	thread LootBoxOpenSequenceUI( false )
}
#endif


#if UI
void function EquipButtonOnClick( var button )
{
	RunClientScript( "UIToClient_RewardEquipOnClick" )
}

void function TrackButtonOnClick( var button )
{
	RunClientScript( "UIToClient_TrackButtonOnClick" )
}

void function ClientToUI_EquipButtonShowDialog( SettingsAssetGUID itemGUID )
{
	ItemFlavor item             = GetItemFlavorByGUID( itemGUID )
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item )

	              
	OpenSelectSlotDialog( entries, item, GetItemFlavorAssociatedCharacterOrWeapon( item ),
		(void function( int index ) : ()
		{
			RunClientScript( "UIToClient_RewardEquipOnClickWithIndex", index )
		})
	)
}


void function ClientToUI_TrackMythicChallenge( SettingsAssetGUID skinGUID )
{
	SettingsAssetGUID challengeGUID = Mythics_GetChallengeGUIDForSkinGUID( skinGUID )
	ItemFlavor challenge = GetItemFlavorByGUID( challengeGUID )
	Mythics_ToggleTrackChallenge( challenge, fileForever.trackChallengeButton )
}


void function EquipToWheelButtonOnClick( var button )
{
	RunClientScript( "UIToClient_RewardEquipToWheelOnClick" )
}

void function ClientToUI_EquipToWheelButtonShowDialog( SettingsAssetGUID itemGUID )
{
	ItemFlavor item             = GetItemFlavorByGUID( itemGUID )
	int itemType                = ItemFlavor_GetType( item )
	                                                                                                 
	ItemFlavor character        = expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( item ) )
	array<LoadoutEntry> entries = []
	int numSlots
	LoadoutEntry functionref( ItemFlavor, int ) getEntryFunc

	                                                                                                                                 
	                                                                                                                       

	if ( itemType == eItemType.skydive_emote )
	{
		numSlots     = NUM_SKYDIVE_EMOTE_SLOTS
		getEntryFunc = Loadout_SkydiveEmote
	}
	else
	{
		numSlots     = MAX_QUIPS_EQUIPPED
		getEntryFunc = Loadout_CharacterQuip
	}

	for ( int i = 0; i < numSlots; i++ )
	{
		LoadoutEntry entry = getEntryFunc( character, i )
		if ( LoadoutSlot_IsReady( LocalClientEHI(), entry ) )
			entries.append( entry )
	}

	              
	OpenSelectSlotDialog( entries, item, character,
		(void function( int index ) : ()
		{
			RunClientScript( "UIToClient_RewardEquipToWheelOnClickWithIndex", index )
		})
	)
}
#endif


#if UI
void function PurchaseButtonOnClick( var button )
{
	if ( fileLevel.storeItemPresentationModeItemPrereq != null )
	{
		ItemFlavor prereqFlav = expect ItemFlavor( fileLevel.storeItemPresentationModeItemPrereq )
		if ( !GRX_IsItemOwnedByPlayer_AllowOutOfDateData( prereqFlav, null ) )
		{
			ConfirmDialogData dialogData
			dialogData.headerText = "#STORE_REQUIREMENTS_FAILED"
			dialogData.messageText = Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) )
			dialogData.contextImage = $"ui/menu/common/dialog_notice"

			OpenOKDialogFromData( dialogData )

			HudElem_SetRuiArg( fileForever.purchaseButton, "descText", Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) ) )
			return
		}
	}

	if ( fileLevel.specialPurchaseDialogConfig != null )
	{
		PurchaseDialog( expect PurchaseDialogConfig( fileLevel.specialPurchaseDialogConfig ) )
	}
	else if ( fileLevel.storeItemPresentationModeOffer != null )
	{
		PurchaseDialogConfig pdc
		pdc.offer = fileLevel.storeItemPresentationModeOffer
		PurchaseDialog( pdc )
	}
	else
	{
		PurchaseDialogConfig pdc
		pdc.flav = fileLevel.specialItemPresentationModeItemFlav
		PurchaseDialog( pdc )
	}
}
#endif


#if UI
void function PreviewButtonOnClick( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardInspectActivate", button )
}
#endif


#if UI
void function PreviewButtonOnHover( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardPlacard_Hover", button, true )
}
#endif


#if UI
void function PreviewButtonOnLeaveHover( var button )
{
	if ( !IsFullyConnected() )
		return

	RunClientScript( "UIToClient_RewardPlacard_Hover", button, false )
}
#endif


#if UI
void function LootBoxOpenSequenceUI( bool firstTime )
{
	fileLevel.lootHasBeenPresented = false
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, false )
	Hud_SetEnabled( fileForever.storeButton, false )

	                         
	ItemFlavor ornull pack
	if ( fileLevel.forceParticularPackFlav )
	{
		pack = fileLevel.forceParticularPackFlav
	}
	else
	{
		pack = GetNextLootBox()
	}
	Assert( pack != null )
	expect ItemFlavor( pack )
	int quality = ItemFlavor_GetQuality( pack )

	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )

	if ( firstTime )
	{
		RunClientScript( "UIToClient_EnterLootCeremony", ItemFlavor_GetGUID( pack ) )
	}
	else
	{
		RunClientScript( "UIToClient_AdditionalLootTick_Sequence", ItemFlavor_GetGUID( pack ) )
	}

	ScriptGRXOperationInfo operation
	operation.expectedQueryGoal = GRX_HTTPQUERYGOAL_OPEN_PACK
	operation.doOperationFunc = (void function( int opID ) : ( pack ) {
		printt( "GRX_OpenPack", opID, ItemFlavor_GetGRXIndex( pack ) )
		GRX_OpenPack( opID, ItemFlavor_GetGRXIndex( pack ) )
	})
	operation.onDoneCallback = (void function( int status ) : ( operation ) {
		if ( status == eScriptGRXOperationStatus.DONE_SUCCESS )
			RunClientScript( "UIToClient_OnGRXPackOpeningResultsAvailable" )
		else
			CloseActiveMenu()
	})
	QueueGRXOperation( GetLocalClientPlayer(), operation )
}
#endif


#if UI
void function SpecialItemPresentationSequenceUI()
{
	UpdateFooterOptions()
	Hud_SetVisible( fileForever.storeButton, false )
	Hud_SetEnabled( fileForever.storeButton, false )

	RunClientScript( "UIToClient_LootCeremony_SetMenuHandles", fileForever.menu )
	RunClientScript( "UIToClient_SpecialItemPresentation", ItemFlavor_GetGUID( fileLevel.specialItemPresentationModeItemFlav ), fileLevel.specialItemPresentationModeItemQty, fileLevel.specialItemPresentationModeItemBadgeTier )
	           

	UpdateSpecialItemPresentationPurchaseButton()
}

void function ClientToUI_UpdateSpecialItemPresentationPurchaseButton()
{
	UpdateSpecialItemPresentationPurchaseButton()
}
#endif


#if UI
void function UpdateSpecialItemPresentationPurchaseButton()
{
	if ( !IsSpecialItemPresentationModeActive() )
		return

	HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", fileLevel.specialItemPriceHeader )
	HudElem_SetRuiArg( fileForever.purchaseButton, "descText", fileLevel.specialItemFormattedPrice )

	bool isOfferUnavailable = false
	if ( fileLevel.storeItemPresentationModeOffer != null && !(expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer)).isAvailable )
	{
		isOfferUnavailable = true
		HudElem_SetRuiArg( fileForever.purchaseButton, "buttonText", "#UNAVAILABLE" )
		string unavailableReason = (expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer)).unavailableReason
		HudElem_SetRuiArg( fileForever.purchaseButton, "descText", unavailableReason != "#UNAVAILABLE" ? unavailableReason : "" )
	}
	else if ( fileLevel.storeItemPresentationModeItemPrereq != null )
	{
		ItemFlavor prereqFlav = expect ItemFlavor( fileLevel.storeItemPresentationModeItemPrereq )
		if ( !GRX_IsItemOwnedByPlayer_AllowOutOfDateData( prereqFlav, null ) )
			HudElem_SetRuiArg( fileForever.purchaseButton, "descText", Localize( "#STORE_REQUIRES_LOCKED", Localize( ItemFlavor_GetLongName( prereqFlav ) ) ) )
	}

	ItemFlavor itemFlav = fileLevel.specialItemPresentationModeItemFlav
	int itemType = ItemFlavor_GetType( itemFlav )

	bool showPurchase = false
	bool showEquip    = false
	bool isOwned      = false

	if ( GRX_IsInventoryReady() )
	{
		if ( fileLevel.specialItemOverrideOwned != null )
			isOwned = expect bool(fileLevel.specialItemOverrideOwned)
		else if ( itemType == eItemType.gladiator_card_badge )
			isOwned = GladiatorCardBadge_DoesStatSatisfyValue( itemFlav, float(fileLevel.specialItemPresentationModeItemBadgeTier) )
		else if ( ItemFlavor_GetGRXMode( itemFlav ) == eItemFlavorGRXMode.REGULAR )
			isOwned = GRX_IsItemOwnedByPlayer( itemFlav, null )

		if ( IsItemFlavorTypeEquippable( itemFlav ) )
		{
			if ( !fileLevel.specialItemHidePurchaseButton )
				showPurchase = !isOwned

			if ( !fileLevel.specialItemHideEquipButton )
				showEquip = isOwned
		}
		                                                                      
		   
		  	                   
		   
		else if ( fileLevel.storeItemPresentationModeOffer != null )
		{
			showPurchase = !GRXOffer_IsFullyClaimed( expect GRXScriptOffer(fileLevel.storeItemPresentationModeOffer) )
		}
	}

	Hud_SetVisible( fileForever.purchaseButton, showPurchase )
	Hud_SetEnabled( fileForever.purchaseButton, !fileLevel.specialItemLockPurchaseButton && !isOfferUnavailable )
	Hud_SetLocked( fileForever.purchaseButton, fileLevel.specialItemLockPurchaseButton || isOfferUnavailable )

	Hud_SetVisible( fileForever.equipButton, showEquip )
	Hud_SetEnabled( fileForever.equipButton, true )
	Hud_SetLocked( fileForever.equipButton, false )

	if ( showPurchase || showEquip )
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "moveDescDown", true )
	}

	if ( fileLevel.specialItemPackName != null && showPurchase )
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", true )
		HudElem_SetRuiArg( fileForever.inspectMenu, "packName", expect string(fileLevel.specialItemPackName) )
		HudElem_SetRuiArg( fileForever.inspectMenu, "packImg", expect asset(fileLevel.specialItemPackImg), eRuiArgType.IMAGE )
	}
	else
	{
		HudElem_SetRuiArg( fileForever.inspectMenu, "showPackDetails", false )
	}

	bool showUnlockedWithoutEquip = isOwned && ( itemType == eItemType.gladiator_card_badge ||
                
                                             
                      
											  itemType == eItemType.weapon_charm ||
										      itemType == eItemType.music_pack )

	if ( showUnlockedWithoutEquip )
	{
		Hud_SetVisible( fileForever.equipButton, true )
		Hud_SetEnabled( fileForever.equipButton, false )
		Hud_SetLocked( fileForever.equipButton, true )

		HudElem_SetRuiArg( fileForever.equipButton, "buttonText", "#UNLOCKED" )

		string descText = ""
		if ( itemType == eItemType.gladiator_card_badge )
			descText = "#EQUIP_IN_LEGENDS_MENU"
		else if ( itemType == eItemType.weapon_charm || itemType == eItemType.music_pack )
			descText = "#EQUIP_IN_LOADOUT_MENU"
                
                                                                                                           
                                      
                      

		HudElem_SetRuiArg( fileForever.equipButton, "descText", descText )
	}
}
#endif      

const float BLACK_FADE_TIME = 0.25
const float BLACK_FADE_TIME_HOLD = 0.25


#if UI
void function LootCeremonyFlashScreenBlack_Internal()
{
	Hud_SetAlpha( fileForever.blackFlash, 255 )
	Hud_Show( fileForever.blackFlash )
	wait BLACK_FADE_TIME_HOLD
	Hud_FadeOverTime( fileForever.blackFlash, 0, BLACK_FADE_TIME, INTERPOLATOR_ACCEL )
	wait BLACK_FADE_TIME
	Hud_Hide( fileForever.blackFlash )
}
#endif


#if UI
void function ClientToUI_PlayLootCeremonySound( string alias )
{
	EmitUISound( alias )
}
#endif


#if UI
void function ClientToUI_StopLootCeremonySound( string alias )
{
	StopUISoundByName( alias )
}
#endif


#if UI
void function SkipAnimButtonOnClick( var button )
{
	RunClientScript( "UIToClient_SkipAnimation" )
}
#endif


#if UI
void function ClientToUI_LootCeremonyMarkItemAsNoLongerNew( SettingsAssetGUID itemFlavorGUID )
{
	ItemFlavor item = GetItemFlavorByGUID( itemFlavorGUID )
	Newness_IfNecessaryMarkItemFlavorAsNoLongerNewAndInformServer( item )
}
#endif


                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             
  
                                                   
                                                  
                                                 
                                                
                                                 
                                                  
                                                   
  
                                                                                                                             
                                                                                                                             
                                                                                                                             
                                                                                                                             


#if UI
ItemFlavor ornull function GetNextLootBox()
{
	ItemFlavor ornull nextPack = null

	table<ItemFlavor, int> packCountMap = GRX_GetPackCounts()

	int highestQuality = 0
	foreach ( ItemFlavor pack, int count in packCountMap )
	{
		asset packIcon = GRXPack_GetOpenButtonIcon( pack )
		int quality    = ItemFlavor_GetQuality( pack )
		if ( count == 0 || quality < highestQuality || ( quality == highestQuality && packIcon == "" ) )
			continue

		highestQuality = quality
		nextPack = pack
	}

	return nextPack

}
#endif