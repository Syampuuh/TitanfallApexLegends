global function ShPakRequests_LevelInit


#if(CLIENT)
global function RequestPakFile
global function ReleasePakFile
#endif


#if(CLIENT)
global function ClientCodeCallback_PakAsyncLoadFinished
#endif


const float WORKAROUND_UNLOAD_MIN_WAIT_TIME = 0.1 //


//
//
//
//
//
#if(CLIENT)
global typedef PakRequestCompleteCallbackType void functionref()
#endif


#if(CLIENT)
global struct PakHandle
{
	string                         rpakPath = ""
	PakRequestCompleteCallbackType requestCompleteCallback
	bool                           isAvailable
}
#endif


#if(CLIENT)
enum ePakRequestStatus
{
	INVALID,
	QUEUED_TO_LOAD,
	LOAD_REQUESTED,
	LOAD_REQUESTED_BUT_WILL_UNLOAD_IMMEDIATELY,
	LOADED,
	QUEUED_TO_UNLOAD,
	UNLOADED,
	ERROR,
}
#endif

#if(CLIENT)
struct PakRequestState
{
	string                 rpakPath
	table<PakHandle, bool> handleSet
	int                    status = ePakRequestStatus.INVALID
	int                    pakId

	float WORKAROUND_unloadQueueTime = -1.0
}
#endif



//
//
//
//
//
struct
{
	#if(CLIENT)
		PakRequestState ornull activeRequestOrNull = null
		array<PakRequestState> requestQueue
		array<PakRequestState> unloadQueue

		table<string, PakRequestState> rpakPathRequestStateMap

		table signalDummy
	#endif
} file



//
//
//
//
//
void function ShPakRequests_LevelInit()
{
	#if(CLIENT)
		RegisterSignal( "PakFileLoaded" )
		RegisterSignal( "PakHandleReleased" )

		RegisterSignal( "WORKAROUND_ProcessPakQueues" )
		thread WORKAROUND_ProcessPakQueues()
	#endif
}



//
//
//
//
//
#if(CLIENT)
PakHandle function RequestPakFile( string rpakPath, PakRequestCompleteCallbackType requestCompleteCallback = null )
{
	PakHandle handle
	handle.rpakPath = rpakPath
	handle.requestCompleteCallback = requestCompleteCallback

	if ( rpakPath in file.rpakPathRequestStateMap )
	{
		PakRequestState prs = file.rpakPathRequestStateMap[rpakPath]

		prs.handleSet[handle] <- true

		if ( prs.status == ePakRequestStatus.QUEUED_TO_LOAD || prs.status == ePakRequestStatus.LOAD_REQUESTED )
		{
			//
		}
		else if ( prs.status == ePakRequestStatus.LOAD_REQUESTED_BUT_WILL_UNLOAD_IMMEDIATELY )
		{
			//
			prs.status = ePakRequestStatus.LOAD_REQUESTED
		}
		else if ( prs.status == ePakRequestStatus.LOADED )
		{
			//
			handle.isAvailable = true
		}
		else if ( prs.status == ePakRequestStatus.QUEUED_TO_UNLOAD )
		{
			//
			file.unloadQueue.removebyvalue( prs )
			prs.status = ePakRequestStatus.LOADED
			//
			handle.isAvailable = true
		}
		else if ( prs.status == ePakRequestStatus.ERROR )
		{
			//
		}
		else
		{
			Assert( false, "PakRequestState has unexpected status: " + DEV_GetEnumStringSafe( "ePakRequestStatus", prs.status ) )
		}

		if ( handle.isAvailable )
		{
			Signal( handle, "PakFileLoaded" )
			if ( handle.requestCompleteCallback != null )
				handle.requestCompleteCallback()
		}
		return handle
	}

	PakRequestState prs
	prs.rpakPath = rpakPath
	prs.handleSet[handle] <- true
	file.rpakPathRequestStateMap[rpakPath] <- prs

	prs.status = ePakRequestStatus.QUEUED_TO_LOAD
	file.requestQueue.append( prs )
	RunPakRequests()

	return handle
}
#endif


#if(CLIENT)
void function ReleasePakFile( PakHandle handle )
{
	PakRequestState prs = file.rpakPathRequestStateMap[handle.rpakPath]
	Assert( prs.status == ePakRequestStatus.QUEUED_TO_LOAD || prs.status == ePakRequestStatus.LOAD_REQUESTED || prs.status == ePakRequestStatus.LOADED || prs.status == ePakRequestStatus.ERROR )

	Assert( handle.isAvailable == (prs.status == ePakRequestStatus.LOADED) )
	handle.isAvailable = false
	delete prs.handleSet[handle]

	if ( prs.handleSet.len() == 0 ) //
	{
		if ( prs.status == ePakRequestStatus.QUEUED_TO_LOAD )
		{
			//
			file.requestQueue.removebyvalue( prs )
			prs.status = ePakRequestStatus.UNLOADED
			delete file.rpakPathRequestStateMap[prs.rpakPath]
		}
		else if ( prs.status == ePakRequestStatus.LOAD_REQUESTED )
		{
			Assert( file.activeRequestOrNull == prs )
			//
			prs.status = ePakRequestStatus.LOAD_REQUESTED_BUT_WILL_UNLOAD_IMMEDIATELY
		}
		else if ( prs.status == ePakRequestStatus.LOADED )
		{
			//
			prs.status = ePakRequestStatus.QUEUED_TO_UNLOAD
			prs.WORKAROUND_unloadQueueTime = Time()
			file.unloadQueue.push( prs )
			RunPakRequests()
		}
		else if ( prs.status == ePakRequestStatus.ERROR )
		{
			delete file.rpakPathRequestStateMap[prs.rpakPath]
		}
	}

	Signal( handle, "PakHandleReleased" )
}
#endif



//
//
//
//
//
#if(CLIENT)
void function RunPakRequests()
{
	//
	//

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	Signal( file.signalDummy, "WORKAROUND_ProcessPakQueues" )
}
#endif


#if(CLIENT)
void function ClientCodeCallback_PakAsyncLoadFinished( int pakId, int status )
{
	printf( "ClientCodeCallback_PakAsyncLoadFinished: %d %d\n", pakId, status )
	Assert( status == PAK_STATUS_LOADED )

	PakRequestState prs = expect PakRequestState(file.activeRequestOrNull)
	file.activeRequestOrNull = null
	Assert( prs.pakId == pakId )

	if ( prs.status == ePakRequestStatus.LOAD_REQUESTED )
	{
		prs.status = ePakRequestStatus.LOADED
		//
		foreach( PakHandle handle, bool unused in prs.handleSet )
		{
			handle.isAvailable = true
			Signal( handle, "PakFileLoaded" )
			if ( handle.requestCompleteCallback != null )
				handle.requestCompleteCallback()
		}
	}
	else if ( prs.status == ePakRequestStatus.LOAD_REQUESTED_BUT_WILL_UNLOAD_IMMEDIATELY )
	{
		//
		prs.status = ePakRequestStatus.QUEUED_TO_UNLOAD
		prs.WORKAROUND_unloadQueueTime = Time()
		file.unloadQueue.push( prs )
	}
	else
	{
		Assert( false, "PakRequestState has unexpected status: " + DEV_GetEnumStringSafe( "ePakRequestStatus", prs.status ) )
	}

	RunPakRequests()
}
#endif


#if(CLIENT)//
void function WORKAROUND_ProcessPakQueues()
{
	while ( true )
	{
		WaitSignal( file.signalDummy, "WORKAROUND_ProcessPakQueues" )

		if ( file.activeRequestOrNull != null )
			continue

		while ( file.unloadQueue.len() > 0 )
		{
			PakRequestState prs = file.unloadQueue[0] //
			Assert( prs.status == ePakRequestStatus.QUEUED_TO_UNLOAD )

			float waitTime = Time() - (prs.WORKAROUND_unloadQueueTime + WORKAROUND_UNLOAD_MIN_WAIT_TIME)
			if ( waitTime > 0.0 )
				wait waitTime

			waitTime = Time() - (prs.WORKAROUND_unloadQueueTime + WORKAROUND_UNLOAD_MIN_WAIT_TIME)
			if ( file.unloadQueue.len() == 0 || file.unloadQueue[0] != prs || waitTime > 0.0 )
				continue //

			file.unloadQueue.remove( 0 )

			printf( "ClientPakFile_Unload: %s\n", prs.rpakPath + ".rpak" )
			int unloadResult = ClientPakFile_Unload( prs.pakId )
			Assert( unloadResult == PAK_STATUS_FREED )

			prs.status = ePakRequestStatus.UNLOADED
			delete file.rpakPathRequestStateMap[prs.rpakPath]
		}

		while ( file.requestQueue.len() > 0 )
		{
			PakRequestState prs = file.requestQueue.remove( 0 )
			printf( "ClientPakFile_RequestAsyncLoad: %s\n", prs.rpakPath + ".rpak" )
			prs.pakId = ClientPakFile_RequestAsyncLoad( prs.rpakPath + ".rpak" )
			file.activeRequestOrNull = prs

			if ( prs.pakId == -1 )
			{
				//
				Warning( "SCRIPT PAK FILE REQUEST FAILED: %s", prs.rpakPath )
				file.activeRequestOrNull = null
				prs.status = ePakRequestStatus.ERROR
				//
			}
			else
			{
				//
				prs.status = ePakRequestStatus.LOAD_REQUESTED
				break //
			}
		}
	}
}
#endif


